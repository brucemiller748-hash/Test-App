<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="Life Tracker">
  <title>Life Tracker</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    * { -webkit-tap-highlight-color: transparent; }
    body { margin: 0; padding: 0; overscroll-behavior: none; }
    /* Tailwind v2 doesn't have all classes used - add missing ones */
    .tracking-tight { letter-spacing: -0.025em; }
    .tracking-wider { letter-spacing: 0.05em; }
    .backdrop-blur-sm { -webkit-backdrop-filter: blur(4px); backdrop-filter: blur(4px); }
    .min-h-screen { min-height: 100vh; min-height: -webkit-fill-available; }
    .truncate { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .aspect-square { aspect-ratio: 1/1; }
    .gap-0\.5 { gap: 0.125rem; }
    .gap-1\.5 { gap: 0.375rem; }
    .gap-2\.5 { gap: 0.625rem; }
    .gap-3\.5 { gap: 0.875rem; }
    .w-1\.5 { width: 0.375rem; }
    .h-1\.5 { height: 0.375rem; }
    .w-2\.5 { width: 0.625rem; }
    .h-2\.5 { height: 0.625rem; }
    .w-3\.5 { width: 0.875rem; }
    .h-3\.5 { height: 0.875rem; }
    .p-0\.5 { padding: 0.125rem; }
    .p-2\.5 { padding: 0.625rem; }
    .p-3\.5 { padding: 0.875rem; }
    .px-2\.5 { padding-left: 0.625rem; padding-right: 0.625rem; }
    .px-3\.5 { padding-left: 0.875rem; padding-right: 0.875rem; }
    .py-2\.5 { padding-top: 0.625rem; padding-bottom: 0.625rem; }
    .py-3\.5 { padding-top: 0.875rem; padding-bottom: 0.875rem; }
    .pb-2\.5 { padding-bottom: 0.625rem; }
    .pb-3\.5 { padding-bottom: 0.875rem; }
    .mb-1\.5 { margin-bottom: 0.375rem; }
    .mb-2\.5 { margin-bottom: 0.625rem; }
    .mb-3\.5 { margin-bottom: 0.875rem; }
    .mt-0\.5 { margin-top: 0.125rem; }
    .mt-1\.5 { margin-top: 0.375rem; }
    .mt-2\.5 { margin-top: 0.625rem; }
    .ml-0\.5 { margin-left: 0.125rem; }
    .rounded-xl { border-radius: 0.75rem; }
    .rounded-2xl { border-radius: 1rem; }
    .text-\[8px\] { font-size: 8px; line-height: 1.2; }
    .text-\[9px\] { font-size: 9px; line-height: 1.2; }
    .text-\[10px\] { font-size: 10px; line-height: 1.3; }
    .text-\[11px\] { font-size: 11px; line-height: 1.3; }
    .text-\[12px\] { font-size: 12px; line-height: 1.4; }
    .text-\[13px\] { font-size: 13px; line-height: 1.4; }
    .text-\[14px\] { font-size: 14px; line-height: 1.4; }
    .text-\[15px\] { font-size: 15px; line-height: 1.4; }
    .space-y-0\.5 > :not(:first-child) { margin-top: 0.125rem; }
    .space-y-1\.5 > :not(:first-child) { margin-top: 0.375rem; }
    .space-y-2\.5 > :not(:first-child) { margin-top: 0.625rem; }
    .space-y-3\.5 > :not(:first-child) { margin-top: 0.875rem; }
    .ring-2 { box-shadow: 0 0 0 2px; }
    .ring-offset-1 { box-shadow: 0 0 0 1px #fff, 0 0 0 3px; }
    .z-\[1\] { z-index: 1; }
    .bg-slate-50 { background-color: #f8fafc; }
    .bg-slate-100 { background-color: #f1f5f9; }
    .bg-slate-200 { background-color: #e2e8f0; }
    .bg-slate-300 { background-color: #cbd5e1; }
    .bg-slate-400 { background-color: #94a3b8; }
    .bg-slate-500 { background-color: #64748b; }
    .bg-slate-600 { background-color: #475569; }
    .bg-slate-700 { background-color: #334155; }
    .bg-slate-800 { background-color: #1e293b; }
    .bg-slate-900 { background-color: #0f172a; }
    .text-slate-50 { color: #f8fafc; }
    .text-slate-100 { color: #f1f5f9; }
    .text-slate-200 { color: #e2e8f0; }
    .text-slate-300 { color: #cbd5e1; }
    .text-slate-400 { color: #94a3b8; }
    .text-slate-500 { color: #64748b; }
    .text-slate-600 { color: #475569; }
    .text-slate-700 { color: #334155; }
    .text-slate-800 { color: #1e293b; }
    .text-slate-900 { color: #0f172a; }
    .border-slate-100 { border-color: #f1f5f9; }
    .border-slate-200 { border-color: #e2e8f0; }
    .border-slate-300 { border-color: #cbd5e1; }
    .border-slate-700 { border-color: #334155; }
    .bg-emerald-50 { background-color: #ecfdf5; }
    .bg-emerald-100 { background-color: #d1fae5; }
    .bg-emerald-500 { background-color: #10b981; }
    .text-emerald-400 { color: #34d399; }
    .text-emerald-500 { color: #10b981; }
    .text-emerald-600 { color: #059669; }
    .text-emerald-700 { color: #047857; }
    .text-emerald-900 { color: #064e3b; }
    .bg-indigo-50 { background-color: #eef2ff; }
    .bg-red-100 { background-color: #fee2e2; }
    .bg-red-500 { background-color: #ef4444; }
    .text-red-400 { color: #f87171; }
    .text-red-500 { color: #ef4444; }
    .text-red-600 { color: #dc2626; }
    .text-blue-400 { color: #60a5fa; }
    .text-blue-500 { color: #3b82f6; }
    .text-orange-500 { color: #f97316; }
    .text-amber-500 { color: #f59e0b; }
    .bg-gradient-to-b { background-image: linear-gradient(to bottom, var(--tw-gradient-stops)); }
    .from-slate-50 { --tw-gradient-from: #f8fafc; --tw-gradient-stops: #f8fafc, var(--tw-gradient-to, rgba(248, 250, 252, 0)); }
    .to-slate-100 { --tw-gradient-to: #f1f5f9; }
    .shadow-sm { box-shadow: 0 1px 2px 0 rgba(0,0,0,0.05); }
    .shadow-lg { box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05); }
    .shadow-xl { box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04); }
    select { background-image: none; }
    input[type="number"] { -moz-appearance: textfield; }
    input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; }
    .-rotate-90 { --tw-rotate: -90deg; transform: rotate(-90deg); }
    .rotate-90 { --tw-rotate: 90deg; transform: rotate(90deg); }
    .-translate-y-1\/2 { transform: translateY(-50%); }
    .col-span-1 { grid-column: span 1 / span 1; }
    .transition-transform { transition-property: transform; transition-timing-function: cubic-bezier(0.4,0,0.2,1); transition-duration: 150ms; }
    .line-clamp-2 { display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .overflow-x-auto { overflow-x: auto; }
    .snap-x { scroll-snap-type: x mandatory; }
    .snap-center { scroll-snap-align: center; }
    .resize-none { resize: none; }
    .appearance-none { -webkit-appearance: none; -moz-appearance: none; appearance: none; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script>
    // Global error handler to catch Babel transpilation and runtime errors
    window.onerror = function(msg, url, line, col, error) {
      var root = document.getElementById('root');
      if (root && !root.hasChildNodes()) {
        root.innerHTML = '<div style="padding:20px;color:#ef4444;font-family:monospace;font-size:13px"><h2 style="margin:0 0 10px">Error loading app</h2><p>' + msg + '</p><p>Line: ' + line + '</p></div>';
      }
      console.error('Global error:', msg, error);
    };
  </script>
  <script type="text/babel">
    const { useState, useEffect, useMemo, useCallback, useRef } = React;


// ===== Lucide Icon Components =====
const iconProps = { width: "100%", height: "100%", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" };

const Camera = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('path', {d: "M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"}),
  React.createElement('circle', {cx: "12", cy: "13", r: "3"})
);
const Book = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('path', {d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"})
);
const Music = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('path', {d: "M9 18V5l12-2v13"}),
  React.createElement('circle', {cx: "6", cy: "18", r: "3"}),
  React.createElement('circle', {cx: "18", cy: "16", r: "3"})
);
const Film = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('rect', {width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2"}),
  React.createElement('line', {x1: "7", y1: "3", x2: "7", y2: "21"}),
  React.createElement('line', {x1: "17", y1: "3", x2: "17", y2: "21"}),
  React.createElement('line', {x1: "3", y1: "7", x2: "7", y2: "7"}),
  React.createElement('line', {x1: "17", y1: "7", x2: "21", y2: "7"}),
  React.createElement('line', {x1: "3", y1: "12", x2: "21", y2: "12"}),
  React.createElement('line', {x1: "3", y1: "17", x2: "7", y2: "17"}),
  React.createElement('line', {x1: "17", y1: "17", x2: "21", y2: "17"})
);
const Target = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('circle', {cx: "12", cy: "12", r: "10"}),
  React.createElement('circle', {cx: "12", cy: "12", r: "6"}),
  React.createElement('circle', {cx: "12", cy: "12", r: "2"})
);
const CheckCircle2 = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('circle', {cx: "12", cy: "12", r: "10"}),
  React.createElement('path', {d: "m9 12 2 2 4-4"})
);
const Check = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('path', {d: "M20 6 9 17l-5-5"})
);
const Circle = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('circle', {cx: "12", cy: "12", r: "10"})
);
const Plus = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('path', {d: "M5 12h14"}),
  React.createElement('path', {d: "M12 5v14"})
);
const Minus = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('path', {d: "M5 12h14"})
);
const X = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('path', {d: "M18 6 6 18"}),
  React.createElement('path', {d: "m6 6 12 12"})
);
const ChevronLeft = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('path', {d: "m15 18-6-6 6-6"})
);
const ChevronRight = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('path', {d: "m9 18 6-6-6-6"})
);
const ChevronUp = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('path', {d: "m18 15-6-6-6 6"})
);
const ChevronDown = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('path', {d: "m6 9 6 6 6-6"})
);
const Trash2 = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('path', {d: "M3 6h18"}),
  React.createElement('path', {d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"}),
  React.createElement('path', {d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"}),
  React.createElement('line', {x1: "10", y1: "11", x2: "10", y2: "17"}),
  React.createElement('line', {x1: "14", y1: "11", x2: "14", y2: "17"})
);
const Settings = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('path', {d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"}),
  React.createElement('circle', {cx: "12", cy: "12", r: "3"})
);
const Sun = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('circle', {cx: "12", cy: "12", r: "4"}),
  React.createElement('path', {d: "M12 2v2"}),
  React.createElement('path', {d: "M12 20v2"}),
  React.createElement('path', {d: "m4.93 4.93 1.41 1.41"}),
  React.createElement('path', {d: "m17.66 17.66 1.41 1.41"}),
  React.createElement('path', {d: "M2 12h2"}),
  React.createElement('path', {d: "M20 12h2"}),
  React.createElement('path', {d: "m6.34 17.66-1.41 1.41"}),
  React.createElement('path', {d: "m19.07 4.93-1.41 1.41"})
);
const Moon = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('path', {d: "M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"})
);
const Star = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('polygon', {points: "12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"})
);
const Flame = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('path', {d: "M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z"})
);
const Zap = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('polygon', {points: "13 2 3 14 12 14 11 22 21 10 12 10 13 2"})
);
const Clock = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('circle', {cx: "12", cy: "12", r: "10"}),
  React.createElement('polyline', {points: "12 6 12 12 16 14"})
);
const Heart = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('path', {d: "M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z"})
);
const Trophy = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('path', {d: "M6 9H4.5a2.5 2.5 0 0 1 0-5H6"}),
  React.createElement('path', {d: "M18 9h1.5a2.5 2.5 0 0 0 0-5H18"}),
  React.createElement('path', {d: "M4 22h16"}),
  React.createElement('path', {d: "M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"}),
  React.createElement('path', {d: "M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"}),
  React.createElement('path', {d: "M18 2H6v7a6 6 0 0 0 12 0V2Z"})
);
const Sliders = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('line', {x1: "4", x2: "4", y1: "21", y2: "14"}),
  React.createElement('line', {x1: "4", x2: "4", y1: "10", y2: "3"}),
  React.createElement('line', {x1: "12", x2: "12", y1: "21", y2: "12"}),
  React.createElement('line', {x1: "12", x2: "12", y1: "8", y2: "3"}),
  React.createElement('line', {x1: "20", x2: "20", y1: "21", y2: "16"}),
  React.createElement('line', {x1: "20", x2: "20", y1: "12", y2: "3"}),
  React.createElement('line', {x1: "2", x2: "6", y1: "14", y2: "14"}),
  React.createElement('line', {x1: "10", x2: "14", y1: "8", y2: "8"}),
  React.createElement('line', {x1: "18", x2: "22", y1: "16", y2: "16"})
);
const Hash = (props) => React.createElement('svg', {...iconProps, className: props.className, style: props.style},
  React.createElement('line', {x1: "4", x2: "20", y1: "9", y2: "9"}),
  React.createElement('line', {x1: "4", x2: "20", y1: "15", y2: "15"}),
  React.createElement('line', {x1: "10", x2: "8", y1: "3", y2: "21"}),
  React.createElement('line', {x1: "16", x2: "14", y1: "3", y2: "21"})
);
// ===== End Icon Components =====



// Format date to YYYY-MM-DD using LOCAL time (not UTC)
// This prevents the bug where late-night entries get saved to the wrong day
const toLocalDateKey = (date) => {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
};

// Haptic feedback helper
const triggerHaptic = () => {
  if (navigator.vibrate) {
    navigator.vibrate([15, 40, 50]); // Success pattern
  }
};

// Get progress bar color based on percentage
const getProgressColor = (percentage) => {
  if (percentage < 50) return '#f97316'; // orange
  if (percentage < 75) return '#eab308'; // yellow
  const greenProgress = (percentage - 75) / 25;
  const r = Math.round(134 - (134 - 34) * greenProgress);
  const g = Math.round(239 - (239 - 197) * greenProgress);
  const b = Math.round(172 - (172 - 94) * greenProgress);
  return `rgb(${r}, ${g}, ${b})`;
};

// Progress bar component - MUST be outside main component for stable React reference
const ProgressBar = React.memo(({ percentage, darkMode }) => {
  const color = getProgressColor(percentage);
  const bgColor = darkMode ? '#334155' : '#e2e8f0';
  
  return (
    <div style={{ height: '6px', width: '100%', backgroundColor: bgColor, overflow: 'hidden' }}>
      <div 
        style={{ 
          height: '6px',
          width: `${percentage}%`,
          backgroundColor: color,
          transition: 'width 0.6s ease-out, background-color 0.4s ease-out'
        }} 
      />
    </div>
  );
});

// Mini progress bar for group headers
const MiniProgressBar = React.memo(({ percentage, darkMode }) => {
  const color = getProgressColor(percentage);
  const bgColor = darkMode ? '#334155' : '#e2e8f0';
  
  return (
    <div style={{ height: '4px', width: '48px', backgroundColor: bgColor, borderRadius: '2px', overflow: 'hidden' }}>
      <div 
        style={{ 
          height: '4px',
          width: `${percentage}%`,
          backgroundColor: color,
          borderRadius: '2px',
          transition: 'width 0.6s ease-out, background-color 0.4s ease-out'
        }} 
      />
    </div>
  );
});

// Mini sparkline for journal slider trends
const MiniSparkline = React.memo(({ data, color = '#6366f1', height = 20, width = 40 }) => {
  const validData = data.filter(d => d !== null);
  if (validData.length < 2) return null;
  
  const max = Math.max(...validData);
  const min = Math.min(...validData);
  const range = max - min || 1;
  
  const points = data.map((val, i) => {
    if (val === null) return null;
    const x = (i / (data.length - 1)) * width;
    const y = height - ((val - min) / range) * (height - 4) - 2;
    return { x, y };
  }).filter(p => p !== null);
  
  if (points.length < 2) return null;
  
  const pathD = points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
  
  return (
    <svg width={width} height={height} style={{ opacity: 0.5 }}>
      <path d={pathD} fill="none" stroke={color} strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" />
      <circle cx={points[points.length - 1].x} cy={points[points.length - 1].y} r="2" fill={color} />
    </svg>
  );
});

const GoalTrackerApp = () => {
  // ============================================
  // UNIFIED STATE
  // ============================================
  const [appState, setAppState] = useState({
    goals: [],
    dailyTasks: {},
    taskCompletions: {},
    journalEntries: {},
    journalConfig: {
      prompts: [
        { id: 1, type: 'text', label: 'How was your day?', placeholder: 'Write about your day...' },
        { id: 2, type: 'slider', label: 'Energy level', min: 0, max: 10 }
      ]
    },
    dailyPhotos: {},
    media: {},
    darkMode: false,
    monthlyIntentions: {},
    categories: [
      { id: 'personal', name: 'Personal Growth', color: '#6366f1' },
      { id: 'health', name: 'Health & Fitness', color: '#10b981' },
      { id: 'career', name: 'Career', color: '#f59e0b' },
      { id: 'creative', name: 'Creative', color: '#ec4899' },
      { id: 'social', name: 'Social', color: '#8b5cf6' },
      { id: 'financial', name: 'Financial', color: '#06b6d4' }
    ]
  });

  const [currentView, setCurrentView] = useState('daily');
  const [calendarMode, setCalendarMode] = useState('week'); // 'week', 'month', 'year'
  const [calendarDate, setCalendarDate] = useState(new Date());
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [showCompletionModal, setShowCompletionModal] = useState(null);
  const [viewingCompletion, setViewingCompletion] = useState(null);
  const [showJournalSettings, setShowJournalSettings] = useState(false);
  const [showGoalForm, setShowGoalForm] = useState(false);
  const [deletingGoalId, setDeletingGoalId] = useState(null);
  const [editingGoal, setEditingGoal] = useState(null);
  const [isLoaded, setIsLoaded] = useState(false);
  const [animatingTasks, setAnimatingTasks] = useState({});
  const [rippleTasks, setRippleTasks] = useState({});
  const [groupCompletionAnim, setGroupCompletionAnim] = useState(new Set());
  const [userOpenedGroups, setUserOpenedGroups] = useState(new Set());
  const [allDoneCelebrating, setAllDoneCelebrating] = useState(false);
  const [showTrophyBadge, setShowTrophyBadge] = useState(false);
  const [showCategorySettings, setShowCategorySettings] = useState(false);
  
  // DailyView state (lifted to prevent remounts)
  const [showMediaForm, setShowMediaForm] = useState(false);
  const [mediaForm, setMediaForm] = useState({ type: 'book', title: '', notes: '' });
  const [collapsedGoals, setCollapsedGoals] = useState(new Set());

  const { goals, dailyTasks, taskCompletions, journalEntries, journalConfig, dailyPhotos, media, darkMode, monthlyIntentions, categories } = appState;

  // Ref to store journal drafts - persists across DailyView remounts
  const journalDraftsRef = useRef({});

  // ============================================
  // PERSISTENCE
  // ============================================
  const saveTimeoutRef = useRef(null);
  const isFirstRender = useRef(true);

  useEffect(() => {
    try {
      const saved = localStorage.getItem('goalTrackerData');
      if (saved) {
        const parsed = JSON.parse(saved);
        setAppState(prev => ({ ...prev, ...parsed }));
      }
    } catch (e) {
      console.error('Failed to load data:', e);
    }
    setIsLoaded(true);
  }, []);

  useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    if (!isLoaded) return;

    if (saveTimeoutRef.current) clearTimeout(saveTimeoutRef.current);

    saveTimeoutRef.current = setTimeout(() => {
      try {
        localStorage.setItem('goalTrackerData', JSON.stringify(appState));
      } catch (e) {
        console.error('Failed to save:', e);
        if (e.name === 'QuotaExceededError') {
          alert('Storage is full! Consider removing some photos.');
        }
      }
    }, 500);

    return () => {
      if (saveTimeoutRef.current) clearTimeout(saveTimeoutRef.current);
    };
  }, [appState, isLoaded]);

  // Save immediately when app goes to background (prevents data loss on iOS)
  useEffect(() => {
    if (!isLoaded) return;
    
    const saveImmediately = () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
        saveTimeoutRef.current = null;
      }
      try {
        localStorage.setItem('goalTrackerData', JSON.stringify(appState));
      } catch (e) {
        console.error('Failed to save on visibility change:', e);
      }
    };
    
    const handleVisibilityChange = () => {
      if (document.visibilityState === 'hidden') {
        saveImmediately();
      }
    };
    
    // Also save on page unload (backup for iOS)
    const handleBeforeUnload = () => {
      saveImmediately();
    };
    
    document.addEventListener('visibilitychange', handleVisibilityChange);
    window.addEventListener('beforeunload', handleBeforeUnload);
    window.addEventListener('pagehide', saveImmediately);
    
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      window.removeEventListener('beforeunload', handleBeforeUnload);
      window.removeEventListener('pagehide', saveImmediately);
    };
  }, [appState, isLoaded]);

  // ============================================
  // STATE HELPERS
  // ============================================
  const updateState = useCallback((key, value) => {
    setAppState(prev => ({
      ...prev,
      [key]: typeof value === 'function' ? value(prev[key]) : value
    }));
  }, []);

  const setGoals = useCallback((value) => updateState('goals', value), [updateState]);
  const setDailyTasks = useCallback((value) => updateState('dailyTasks', value), [updateState]);
  const setTaskCompletions = useCallback((value) => updateState('taskCompletions', value), [updateState]);
  const setJournalEntries = useCallback((value) => updateState('journalEntries', value), [updateState]);
  const setJournalConfig = useCallback((value) => updateState('journalConfig', value), [updateState]);
  const setDailyPhotos = useCallback((value) => updateState('dailyPhotos', value), [updateState]);
  const setMedia = useCallback((value) => updateState('media', value), [updateState]);
  const setDarkMode = useCallback((value) => updateState('darkMode', value), [updateState]);
  const setMonthlyIntentions = useCallback((value) => updateState('monthlyIntentions', value), [updateState]);
  const setCategories = useCallback((value) => updateState('categories', value), [updateState]);

  // Use local time for date keys (not UTC) to prevent timezone bugs
  const formatDate = useCallback((date) => toLocalDateKey(date), []);
  const getDateKey = useCallback((date) => formatDate(date), [formatDate]);

  // Check if a date is today
  const isToday = useCallback((date) => {
    const today = new Date();
    return date.getDate() === today.getDate() &&
           date.getMonth() === today.getMonth() &&
           date.getFullYear() === today.getFullYear();
  }, []);

  // Check if a goal was active (existed) on a given date
  // Goals should only count for dates on or after their creation
  const isGoalActiveOnDate = useCallback((goal, dateKey) => {
    if (!goal.createdAt) return true; // Legacy goals without createdAt are always active
    const createdDateKey = toLocalDateKey(new Date(goal.createdAt));
    return dateKey >= createdDateKey;
  }, []);

  // Animation helper
  const triggerTaskAnimation = useCallback((taskKey) => {
    setAnimatingTasks(prev => ({ ...prev, [taskKey]: true }));
    setRippleTasks(prev => ({ ...prev, [taskKey]: true }));
    triggerHaptic();
    setTimeout(() => {
      setAnimatingTasks(prev => ({ ...prev, [taskKey]: false }));
    }, 800);
    setTimeout(() => {
      setRippleTasks(prev => ({ ...prev, [taskKey]: false }));
    }, 700);
  }, []);

  // ============================================
  // GOAL MANAGEMENT
  // ============================================
  const addGoal = useCallback((goal) => {
    const newGoal = { id: Date.now(), ...goal, createdAt: new Date().toISOString() };
    setGoals(prev => [...prev, newGoal]);
    setShowGoalForm(false);
  }, [setGoals]);

  const updateGoal = useCallback((id, updates) => {
    setGoals(prev => prev.map(g => g.id === id ? { ...g, ...updates } : g));
    setEditingGoal(null);
  }, [setGoals]);

  const deleteGoal = useCallback((id) => {
    setGoals(prev => prev.filter(g => g.id !== id));
    setDailyTasks(prev => {
      const newTasks = { ...prev };
      Object.keys(newTasks).forEach(dateKey => {
        const dateTasks = { ...newTasks[dateKey] };
        Object.keys(dateTasks).forEach(taskKey => {
          if (taskKey === id || taskKey.startsWith(`${id}-`)) delete dateTasks[taskKey];
        });
        newTasks[dateKey] = dateTasks;
      });
      return newTasks;
    });
  }, [setGoals, setDailyTasks]);

  const archiveGoal = useCallback((id) => {
    setGoals(prev => prev.map(g => g.id === id ? { ...g, archived: true, archivedAt: new Date().toISOString() } : g));
  }, [setGoals]);

  const unarchiveGoal = useCallback((id) => {
    setGoals(prev => prev.map(g => g.id === id ? { ...g, archived: false, archivedAt: null } : g));
  }, [setGoals]);

  // ============================================
  // WEEK HELPERS (must be before task management)
  // ============================================
  const getWeekRange = useCallback((date) => {
    const day = date.getDay(); // 0 = Sunday
    const weekStart = new Date(date);
    weekStart.setDate(date.getDate() - day); // Go back to Sunday
    weekStart.setHours(0, 0, 0, 0);
    const weekEnd = new Date(weekStart);
    weekEnd.setDate(weekStart.getDate() + 6); // Saturday
    weekEnd.setHours(23, 59, 59, 999);
    return { weekStart, weekEnd };
  }, []);

  // Get a week key for weekly points goal tracking
  const getWeekKey = useCallback((date) => {
    const { weekStart } = getWeekRange(date);
    return `week-${toLocalDateKey(weekStart)}`;
  }, [getWeekRange]);

  // ============================================
  // TASK MANAGEMENT
  // ============================================
  const toggleTask = useCallback((dateKey, goalId, taskId, checkIndex = 0, task = null, goal = null) => {
    // For weekly points goals, use week key instead of date key
    const isWeeklyPointsGoal = goal?.goalType === 'points' && goal?.pointTargetFrequency === 'weekly';
    const storageKey = isWeeklyPointsGoal ? getWeekKey(new Date(dateKey)) : dateKey;
    
    const taskKey = `${goalId}-${taskId}-${checkIndex}`;
    const currentValue = dailyTasks[storageKey]?.[taskKey];

    if (currentValue) {
      setDailyTasks(prev => ({ ...prev, [storageKey]: { ...prev[storageKey], [taskKey]: false } }));
      // Reset celebration states if unchecking
      setAllDoneCelebrating(false);
      setShowTrophyBadge(false);
      return;
    }

    // Trigger animation when completing (not uncompleting)
    triggerTaskAnimation(taskKey);

    if (task && task.promptForNote) {
      setShowCompletionModal({ dateKey: storageKey, goalId, taskId, checkIndex, task });
      return;
    }

    setDailyTasks(prev => {
      const newState = { ...prev, [storageKey]: { ...prev[storageKey], [taskKey]: true } };
      
      // Check group completion for 2B: Celebrate & Fold
      if (goal && goal.tasks && goal.tasks.length > 1) {
        const allGroupDone = goal.tasks.every(t => {
          const checksNeeded = t.dailyChecks || 1;
          for (let i = 0; i < checksNeeded; i++) {
            const k = `${goalId}-${t.id}-${i}`;
            if (k === taskKey) continue; // This one is being set to true
            if (!newState[storageKey]?.[k]) return false;
          }
          return true;
        });
        
        if (allGroupDone) {
          // Determine the collapse key prefix (daily or weekly)
          const isWeeklyTask = task?.frequency === 'weekly';
          const collapsePrefix = isWeeklyTask ? 'weekly' : 'daily';
          const collapseKey = `${collapsePrefix}-${goalId}`;
          
          setGroupCompletionAnim(prev => new Set([...prev, collapseKey]));
          if (navigator.vibrate) navigator.vibrate([20, 60, 30, 60, 40]);
          setTimeout(() => {
            setCollapsedGoals(prev => {
              // Only auto-collapse if user hasn't manually re-opened
              if (userOpenedGroups.has(collapseKey)) return prev;
              return new Set([...prev, collapseKey]);
            });
            setGroupCompletionAnim(prev => { const n = new Set(prev); n.delete(collapseKey); return n; });
          }, 1200);
        }
      }
      
      // Check all daily tasks complete for 3B: Golden Glow
      // Compute daily progress with new state
      let totalTasks = 0;
      let completedTasks = 0;
      goals.forEach(g => {
        if (!g.tasks || !Array.isArray(g.tasks) || g.archived) return;
        if (g.goalType === 'points') return; // Points goals have separate completion logic
        g.tasks.forEach(t => {
          if (!t.frequency || t.frequency === 'daily') {
            const checksPerDay = t.dailyChecks || 1;
            totalTasks += checksPerDay;
            for (let i = 0; i < checksPerDay; i++) {
              const k = `${g.id}-${t.id}-${i}`;
              if (k === taskKey) { completedTasks++; continue; }
              if (newState[storageKey]?.[k]) completedTasks++;
            }
          }
        });
      });
      
      if (totalTasks > 0 && completedTasks === totalTasks && !allDoneCelebrating) {
        if (navigator.vibrate) navigator.vibrate([30, 80, 30, 80, 60, 120, 80]);
        setAllDoneCelebrating(true);
        setTimeout(() => setShowTrophyBadge(true), 300);
        setTimeout(() => {
          setAllDoneCelebrating(false);
          setShowTrophyBadge(false);
        }, 4000);
      }
      
      return newState;
    });
  }, [dailyTasks, setDailyTasks, triggerTaskAnimation, getWeekKey, goals, allDoneCelebrating, userOpenedGroups]);

  const saveTaskCompletion = useCallback((dateKey, goalId, taskId, checkIndex, note, photo) => {
    const taskKey = `${goalId}-${taskId}-${checkIndex}`;
    setDailyTasks(prev => ({ ...prev, [dateKey]: { ...prev[dateKey], [taskKey]: true } }));
    
    if (note || photo) {
      const completionKey = `${dateKey}-${taskKey}`;
      setTaskCompletions(prev => ({
        ...prev,
        [completionKey]: { note, photo, timestamp: new Date().toISOString() }
      }));
    }
    setShowCompletionModal(null);
  }, [setDailyTasks, setTaskCompletions]);

  // Set variable task value (for slider and counter task types)
  const setVariableTaskValue = useCallback((dateKey, goalId, taskId, valueType, newValue, goal = null) => {
    // For weekly points goals, use week key
    const isWeeklyPointsGoal = goal?.goalType === 'points' && goal?.pointTargetFrequency === 'weekly';
    const storageKey = isWeeklyPointsGoal ? getWeekKey(new Date(dateKey)) : dateKey;
    
    const taskKey = `${goalId}-${taskId}-${valueType}`; // e.g., "123-456-value" or "123-456-count"
    
    setDailyTasks(prev => ({ 
      ...prev, 
      [storageKey]: { 
        ...prev[storageKey], 
        [taskKey]: Math.max(0, newValue) 
      } 
    }));
  }, [setDailyTasks, getWeekKey]);

  // Get variable task value
  const getVariableTaskValue = useCallback((dateKey, goalId, taskId, valueType, goal = null) => {
    const isWeeklyPointsGoal = goal?.goalType === 'points' && goal?.pointTargetFrequency === 'weekly';
    const storageKey = isWeeklyPointsGoal ? getWeekKey(new Date(dateKey)) : dateKey;
    
    const taskKey = `${goalId}-${taskId}-${valueType}`;
    return dailyTasks[storageKey]?.[taskKey] || 0;
  }, [dailyTasks, getWeekKey]);

  const getTaskCompletionCount = useCallback((dateKey, goalId, taskId, totalChecks, goal = null) => {
    // For weekly points goals, use week key
    const isWeeklyPointsGoal = goal?.goalType === 'points' && goal?.pointTargetFrequency === 'weekly';
    const storageKey = isWeeklyPointsGoal ? getWeekKey(new Date(dateKey)) : dateKey;
    
    const tasks = dailyTasks[storageKey] || {};
    let count = 0;
    for (let i = 0; i < totalChecks; i++) {
      if (tasks[`${goalId}-${taskId}-${i}`]) count++;
    }
    return count;
  }, [dailyTasks, getWeekKey]);

  const isTaskCompleted = useCallback((dateKey, goalId, taskId, goal = null) => {
    // For weekly points goals, use week key
    const isWeeklyPointsGoal = goal?.goalType === 'points' && goal?.pointTargetFrequency === 'weekly';
    const storageKey = isWeeklyPointsGoal ? getWeekKey(new Date(dateKey)) : dateKey;
    
    const tasks = dailyTasks[storageKey] || {};
    const newKey = `${goalId}-${taskId}-0`;
    if (tasks[newKey] !== undefined) return tasks[newKey];
    return tasks[goalId] || false;
  }, [dailyTasks, getWeekKey]);

  // Check if a scheduled task should appear on a given date
  const isTaskScheduledForDate = useCallback((task, date) => {
    if (!task.frequency || task.frequency === 'daily') return true;
    if (task.frequency === 'scheduled') {
      const dayOfWeek = (typeof date === 'string' ? new Date(date + 'T12:00:00') : date).getDay();
      return (task.scheduledDays || []).includes(dayOfWeek);
    }
    return false; // weekly tasks handled separately
  }, []);

  // ============================================
  // POINTS CALCULATION
  // ============================================
  // Calculate points earned for a goal - dateKey for daily, weekKey for weekly
  const calculatePointsEarnedForDate = useCallback((dateKey, goal) => {
    if (goal.goalType !== 'points' || !goal.tasks) return 0;
    
    // For weekly points goals, we don't calculate by date - use calculatePointsEarnedForWeek
    if (goal.pointTargetFrequency === 'weekly') return 0;
    
    let totalPoints = 0;
    goal.tasks.forEach(task => {
      const taskType = task.taskType || 'checkbox';
      
      if (taskType === 'checkbox') {
        // Simple checkbox - checked = pointValue points
        const pointValue = task.pointValue || 1;
        if (dailyTasks[dateKey]?.[`${goal.id}-${task.id}-0`]) {
          totalPoints += pointValue;
        }
      } else if (taskType === 'slider') {
        // Slider - value * pointsPerUnit
        const value = dailyTasks[dateKey]?.[`${goal.id}-${task.id}-value`] || 0;
        const pointsPerUnit = task.pointsPerUnit || 1;
        totalPoints += value * pointsPerUnit;
      } else if (taskType === 'counter') {
        // Counter - floor(count / unitsPerPoint) * pointsPerUnit
        const count = dailyTasks[dateKey]?.[`${goal.id}-${task.id}-count`] || 0;
        const unitsPerPoint = task.unitsPerPoint || 1;
        const pointsPerUnit = task.pointsPerUnit || 1;
        totalPoints += Math.floor(count / unitsPerPoint) * pointsPerUnit;
      }
    });
    return totalPoints;
  }, [dailyTasks]);

  // Calculate points earned for weekly points goals using week key
  const calculatePointsEarnedForWeek = useCallback((weekKey, goal) => {
    if (goal.goalType !== 'points' || !goal.tasks) return 0;
    if (goal.pointTargetFrequency !== 'weekly') return 0;
    
    let totalPoints = 0;
    goal.tasks.forEach(task => {
      const taskType = task.taskType || 'checkbox';
      
      if (taskType === 'checkbox') {
        const pointValue = task.pointValue || 1;
        if (dailyTasks[weekKey]?.[`${goal.id}-${task.id}-0`]) {
          totalPoints += pointValue;
        }
      } else if (taskType === 'slider') {
        const value = dailyTasks[weekKey]?.[`${goal.id}-${task.id}-value`] || 0;
        const pointsPerUnit = task.pointsPerUnit || 1;
        totalPoints += value * pointsPerUnit;
      } else if (taskType === 'counter') {
        const count = dailyTasks[weekKey]?.[`${goal.id}-${task.id}-count`] || 0;
        const unitsPerPoint = task.unitsPerPoint || 1;
        const pointsPerUnit = task.pointsPerUnit || 1;
        totalPoints += Math.floor(count / unitsPerPoint) * pointsPerUnit;
      }
    });
    return totalPoints;
  }, [dailyTasks]);

  // Generic points calculation that handles both daily and weekly
  const calculatePointsEarned = useCallback((dateKey, goal, weekKeyOverride = null) => {
    if (goal.goalType !== 'points' || !goal.tasks) return 0;
    
    if (goal.pointTargetFrequency === 'weekly') {
      const weekKey = weekKeyOverride || getWeekKey(new Date(dateKey));
      return calculatePointsEarnedForWeek(weekKey, goal);
    }
    
    return calculatePointsEarnedForDate(dateKey, goal);
  }, [calculatePointsEarnedForDate, calculatePointsEarnedForWeek, getWeekKey]);

  // ============================================
  // PHOTO & MEDIA
  // ============================================
  const updateDailyPhoto = useCallback((dateKey, photoData) => {
    setDailyPhotos(prev => ({ ...prev, [dateKey]: photoData }));
  }, [setDailyPhotos]);

  const removeDailyPhoto = useCallback((dateKey) => {
    setDailyPhotos(prev => {
      const newPhotos = { ...prev };
      delete newPhotos[dateKey];
      return newPhotos;
    });
  }, [setDailyPhotos]);

  const addMedia = useCallback((dateKey, mediaItem) => {
    setMedia(prev => ({
      ...prev,
      [dateKey]: [...(prev[dateKey] || []), { ...mediaItem, id: Date.now() }]
    }));
  }, [setMedia]);

  const removeMedia = useCallback((dateKey, mediaId) => {
    setMedia(prev => ({
      ...prev,
      [dateKey]: (prev[dateKey] || []).filter(m => m.id !== mediaId)
    }));
  }, [setMedia]);

  // ============================================
  // MEMOIZED CALCULATIONS
  // ============================================
  const goalProgressCache = useMemo(() => {
    const cache = {};
    const today = new Date();
    today.setHours(23, 59, 59, 999);

    goals.forEach(goal => {
      // Use goal creation date, fallback to Jan 1st for legacy goals
      const goalStart = goal.createdAt ? new Date(goal.createdAt) : new Date(today.getFullYear(), 0, 1);
      goalStart.setHours(0, 0, 0, 0);
      const daysPassed = Math.floor((today - goalStart) / (1000 * 60 * 60 * 24)) + 1;

      if (!goal.tasks || !Array.isArray(goal.tasks) || goal.tasks.length === 0) {
        cache[goal.id] = { completedDays: 0, totalDays: daysPassed, percentage: 0 };
        return;
      }

      let totalExpected = 0;
      let totalCompleted = 0;

      goal.tasks.forEach(task => {
        const frequency = task.frequency || 'daily';

        if (frequency === 'daily') {
          // Daily tasks: count each day
          const checksPerDay = task.dailyChecks || 1;
          for (let i = 0; i < daysPassed; i++) {
            const date = new Date(goalStart);
            date.setDate(date.getDate() + i);
            const dateKey = toLocalDateKey(date);
            totalExpected += checksPerDay;
            for (let c = 0; c < checksPerDay; c++) {
              if (dailyTasks[dateKey]?.[`${goal.id}-${task.id}-${c}`]) totalCompleted++;
            }
          }
        } else if (frequency === 'weekly') {
          // Weekly tasks: group by week, compare to weekly target
          const weeklyTarget = task.weeklyTarget || 4;
          
          // Find the Sunday that starts the week containing goalStart
          const firstWeekStart = new Date(goalStart);
          firstWeekStart.setDate(goalStart.getDate() - goalStart.getDay());
          
          // Iterate through each week
          let weekStart = new Date(firstWeekStart);
          while (weekStart <= today) {
            const weekEnd = new Date(weekStart);
            weekEnd.setDate(weekStart.getDate() + 6);
            
            // Count completions in this week (only for days within goal's active period)
            let weeklyCompletions = 0;
            let daysInWeekActive = 0;
            
            for (let d = new Date(weekStart); d <= weekEnd && d <= today; d.setDate(d.getDate() + 1)) {
              if (d >= goalStart) {
                daysInWeekActive++;
                const dateKey = toLocalDateKey(d);
                if (dailyTasks[dateKey]?.[`${goal.id}-${task.id}-0`]) weeklyCompletions++;
              }
            }
            
            // Only count this week if some days were active
            if (daysInWeekActive > 0) {
              // Pro-rate the target if it's a partial week (goal started mid-week or current week)
              const adjustedTarget = daysInWeekActive < 7 
                ? Math.max(1, Math.round(weeklyTarget * (daysInWeekActive / 7)))
                : weeklyTarget;
              
              totalExpected += adjustedTarget;
              totalCompleted += Math.min(weeklyCompletions, adjustedTarget); // Cap at target
            }
            
            // Move to next week
            weekStart.setDate(weekStart.getDate() + 7);
          }
        } else if (frequency === 'scheduled') {
          // Scheduled tasks: only count on scheduled days
          const checksPerDay = task.dailyChecks || 1;
          for (let i = 0; i < daysPassed; i++) {
            const date = new Date(goalStart);
            date.setDate(date.getDate() + i);
            if (isTaskScheduledForDate(task, date)) {
              const dateKey = toLocalDateKey(date);
              totalExpected += checksPerDay;
              for (let c = 0; c < checksPerDay; c++) {
                if (dailyTasks[dateKey]?.[`${goal.id}-${task.id}-${c}`]) totalCompleted++;
              }
            }
          }
        }
      });

      cache[goal.id] = {
        completedDays: totalCompleted, // Now represents completions, not days
        totalDays: totalExpected, // Now represents expected completions
        percentage: totalExpected > 0 ? Math.round((totalCompleted / totalExpected) * 100) : 0
      };
    });
    return cache;
  }, [goals, dailyTasks, isTaskScheduledForDate]);

  const calculateProgress = useCallback((goal) => {
    return goalProgressCache[goal.id] || { completedDays: 0, totalDays: 0, percentage: 0 };
  }, [goalProgressCache]);

  const calculateWeeklyProgress = useCallback((task, goalId, date) => {
    const { weekStart, weekEnd } = getWeekRange(date);
    let completedCount = 0;
    for (let d = new Date(weekStart); d <= weekEnd; d.setDate(d.getDate() + 1)) {
      const dateKey = toLocalDateKey(d);
      if (isTaskCompleted(dateKey, goalId, task.id)) completedCount++;
    }
    const target = task.weeklyTarget || 4;
    return { completed: completedCount, target, percentage: Math.round((completedCount / target) * 100) };
  }, [getWeekRange, isTaskCompleted]);

  const selectedDateKey = useMemo(() => getDateKey(selectedDate), [selectedDate, getDateKey]);

  const dailyProgress = useMemo(() => {
    let totalTasks = 0;
    let completedTasks = 0;
    let totalPoints = 0;
    let earnedPoints = 0;
    
    goals.forEach(goal => {
      if (!goal.tasks || !Array.isArray(goal.tasks)) return;
      if (goal.archived) return; // Skip archived goals
      if (!isGoalActiveOnDate(goal, selectedDateKey)) return; // Skip goals created after this date
      
      // Handle daily points goals
      if (goal.goalType === 'points' && (!goal.pointTargetFrequency || goal.pointTargetFrequency === 'daily')) {
        totalPoints += goal.pointTarget || 10;
        earnedPoints += calculatePointsEarnedForDate(selectedDateKey, goal);
        return;
      }
      
      // Skip weekly points goals and other points goals
      if (goal.goalType === 'points') return;
      
      // Handle checkbox goals
      goal.tasks.forEach(task => {
        if ((!task.frequency || task.frequency === 'daily') || 
            (task.frequency === 'scheduled' && isTaskScheduledForDate(task, selectedDate))) {
          const checksPerDay = task.dailyChecks || 1;
          totalTasks += checksPerDay;
          for (let i = 0; i < checksPerDay; i++) {
            if (dailyTasks[selectedDateKey]?.[`${goal.id}-${task.id}-${i}`]) completedTasks++;
          }
        }
      });
    });
    
    // Combine checkbox progress and points progress
    const checkboxPercentage = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;
    const pointsPercentage = totalPoints > 0 ? Math.min(100, (earnedPoints / totalPoints) * 100) : 0;
    
    // Weighted average based on whether we have both types
    let percentage = 0;
    if (totalTasks > 0 && totalPoints > 0) {
      percentage = Math.round((checkboxPercentage + pointsPercentage) / 2);
    } else if (totalTasks > 0) {
      percentage = Math.round(checkboxPercentage);
    } else if (totalPoints > 0) {
      percentage = Math.round(pointsPercentage);
    }
    
    return {
      completed: completedTasks,
      total: totalTasks,
      earnedPoints,
      totalPoints,
      percentage
    };
  }, [goals, dailyTasks, selectedDateKey, calculatePointsEarnedForDate]);

  const calculateDailyProgress = useCallback((dateKey) => {
    let totalTasks = 0;
    let completedTasks = 0;
    goals.forEach(goal => {
      if (goal.goalType === 'points') return;
      if (goal.archived) return; // Skip archived goals
      if (!isGoalActiveOnDate(goal, dateKey)) return; // Skip goals created after this date
      if (!goal.tasks || !Array.isArray(goal.tasks)) return;
      goal.tasks.forEach(task => {
        if ((!task.frequency || task.frequency === 'daily') ||
            (task.frequency === 'scheduled' && isTaskScheduledForDate(task, dateKey))) {
          const checksPerDay = task.dailyChecks || 1;
          totalTasks += checksPerDay;
          for (let i = 0; i < checksPerDay; i++) {
            if (dailyTasks[dateKey]?.[`${goal.id}-${task.id}-${i}`]) completedTasks++;
          }
        }
      });
    });
    return {
      completed: completedTasks,
      total: totalTasks,
      percentage: totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0
    };
  }, [goals, dailyTasks, isTaskScheduledForDate, isGoalActiveOnDate]);

  const weeklyOverallProgress = useMemo(() => {
    const { weekStart, weekEnd } = getWeekRange(selectedDate);
    const weekKey = getWeekKey(selectedDate);
    let totalExpected = 0;
    let totalCompleted = 0;
    let totalPoints = 0;
    let earnedPoints = 0;

    goals.forEach(goal => {
      if (!goal.tasks || !Array.isArray(goal.tasks)) return;
      if (goal.archived) return; // Skip archived goals
      
      // Handle weekly points goals
      if (goal.goalType === 'points' && goal.pointTargetFrequency === 'weekly') {
        // Only count if goal was created before or during this week
        const weekEndKey = toLocalDateKey(weekEnd);
        if (!isGoalActiveOnDate(goal, weekEndKey)) return;
        totalPoints += goal.pointTarget || 10;
        earnedPoints += calculatePointsEarnedForWeek(weekKey, goal);
        return;
      }
      
      // Skip daily points goals
      if (goal.goalType === 'points') return;
      
      // Handle checkbox goals
      goal.tasks.forEach(task => {
        if (!task.frequency || task.frequency === 'daily') {
          const checksPerDay = task.dailyChecks || 1;
          for (let d = new Date(weekStart); d <= weekEnd; d.setDate(d.getDate() + 1)) {
            const dateKey = toLocalDateKey(d);
            if (!isGoalActiveOnDate(goal, dateKey)) continue; // Skip days before goal was created
            totalExpected += checksPerDay;
            for (let i = 0; i < checksPerDay; i++) {
              if (dailyTasks[dateKey]?.[`${goal.id}-${task.id}-${i}`]) totalCompleted++;
            }
          }
        } else if (task.frequency === 'scheduled') {
          const checksPerDay = task.dailyChecks || 1;
          for (let d = new Date(weekStart); d <= weekEnd; d.setDate(d.getDate() + 1)) {
            const dateKey = toLocalDateKey(d);
            if (!isGoalActiveOnDate(goal, dateKey)) continue; // Skip days before goal was created
            if (isTaskScheduledForDate(task, d)) {
              totalExpected += checksPerDay;
              for (let i = 0; i < checksPerDay; i++) {
                if (dailyTasks[dateKey]?.[`${goal.id}-${task.id}-${i}`]) totalCompleted++;
              }
            }
          }
        } else if (task.frequency === 'weekly') {
          // For weekly tasks, count proportionally based on days active
          const target = task.weeklyTarget || 4;
          let daysActive = 0;
          for (let d = new Date(weekStart); d <= weekEnd; d.setDate(d.getDate() + 1)) {
            const dateKey = toLocalDateKey(d);
            if (isGoalActiveOnDate(goal, dateKey)) daysActive++;
          }
          if (daysActive === 0) return;
          // Adjust target proportionally if goal was created mid-week
          const adjustedTarget = daysActive < 7 ? Math.ceil(target * (daysActive / 7)) : target;
          totalExpected += adjustedTarget;
          for (let d = new Date(weekStart); d <= weekEnd; d.setDate(d.getDate() + 1)) {
            const dateKey = toLocalDateKey(d);
            if (!isGoalActiveOnDate(goal, dateKey)) continue;
            if (isTaskCompleted(dateKey, goal.id, task.id)) totalCompleted++;
          }
        }
      });
    });
    
    // Combine checkbox progress and points progress
    const checkboxPercentage = totalExpected > 0 ? (totalCompleted / totalExpected) * 100 : 0;
    const pointsPercentage = totalPoints > 0 ? Math.min(100, (earnedPoints / totalPoints) * 100) : 0;
    
    let percentage = 0;
    if (totalExpected > 0 && totalPoints > 0) {
      percentage = Math.round((checkboxPercentage + pointsPercentage) / 2);
    } else if (totalExpected > 0) {
      percentage = Math.round(checkboxPercentage);
    } else if (totalPoints > 0) {
      percentage = Math.round(pointsPercentage);
    }
    
    return {
      completed: totalCompleted,
      total: totalExpected,
      earnedPoints,
      totalPoints,
      percentage
    };
  }, [goals, dailyTasks, selectedDate, getWeekRange, getWeekKey, isTaskCompleted, calculatePointsEarnedForWeek]);

  // ============================================
  // THEME CLASSES - Clean Navy Design
  // ============================================
  const theme = {
    // Backgrounds
    pageBg: darkMode ? 'bg-slate-900' : 'bg-gradient-to-b from-slate-50 to-slate-100',
    headerBg: darkMode ? 'bg-slate-900/90' : 'bg-slate-50/90',
    cardBg: darkMode ? 'bg-slate-800' : 'bg-white',
    inputBg: darkMode ? 'bg-slate-700' : 'bg-slate-50',
    
    // Text
    textPrimary: darkMode ? 'text-slate-100' : 'text-slate-800',
    textSecondary: darkMode ? 'text-slate-400' : 'text-slate-500',
    textMuted: darkMode ? 'text-slate-500' : 'text-slate-400',
    
    // Borders
    border: darkMode ? 'border-slate-700' : 'border-slate-200',
    divider: darkMode ? 'border-slate-700' : 'border-slate-100',
    
    // Accents
    accent: darkMode ? 'bg-slate-200 text-slate-900' : 'bg-slate-700 text-white',
    accentMuted: darkMode ? 'bg-slate-700' : 'bg-slate-200',
    checkDone: darkMode ? 'text-slate-500' : 'text-slate-400',
    checkUndone: darkMode ? 'text-slate-600' : 'text-slate-300',
    
    // Progress
    progressBg: darkMode ? 'bg-slate-700' : 'bg-slate-200',
    progressFill: darkMode ? 'bg-slate-300' : 'bg-slate-700',
    progressSuccess: 'bg-emerald-500',
    
    // Buttons
    btnPrimary: darkMode ? 'bg-slate-200 text-slate-900' : 'bg-slate-700 text-white',
    btnSecondary: darkMode ? 'bg-slate-700 text-slate-300' : 'bg-slate-100 text-slate-700',
    btnIcon: darkMode ? 'bg-slate-800 text-slate-400' : 'bg-white text-slate-400',
  };

  // ============================================
  // MODAL COMPONENTS
  // ============================================
  const JournalSettingsModal = ({ config, onSave, onCancel }) => {
    const [prompts, setPrompts] = useState(config.prompts || []);
    const addPrompt = (type) => {
      setPrompts([...prompts, {
        id: Date.now(),
        type,
        label: type === 'text' ? 'New text prompt' : type === 'yesno' ? 'New yes/no question' : 'New rating',
        placeholder: type === 'text' ? 'Write here...' : '',
        min: type === 'slider' ? 0 : undefined,
        max: type === 'slider' ? 10 : undefined
      }]);
    };
    const updatePrompt = (id, field, value) => setPrompts(prompts.map(p => p.id === id ? { ...p, [field]: value } : p));
    const deletePrompt = (id) => setPrompts(prompts.filter(p => p.id !== id));
    const movePrompt = (index, direction) => {
      const newPrompts = [...prompts];
      const newIndex = index + direction;
      if (newIndex >= 0 && newIndex < prompts.length) {
        [newPrompts[index], newPrompts[newIndex]] = [newPrompts[newIndex], newPrompts[index]];
        setPrompts(newPrompts);
      }
    };

    return (
      <div className="fixed inset-0 bg-black/30 backdrop-blur-sm flex items-center justify-center z-50 p-4">
        <div className={`${theme.cardBg} rounded-2xl w-full max-w-md max-h-[90vh] overflow-hidden shadow-xl flex flex-col`}>
          {/* Header */}
          <div className={`px-5 py-4 border-b ${theme.border} flex items-center justify-between flex-shrink-0`}>
            <h3 className={`text-base font-semibold ${theme.textPrimary}`}>Journal Prompts</h3>
            <button onClick={onCancel} className="p-1 rounded-lg">
              <X className={`w-5 h-5 ${theme.textMuted}`} />
            </button>
          </div>
          
          {/* Add Buttons */}
          <div className={`px-5 py-3 border-b ${theme.border} flex-shrink-0`}>
            <p className={`text-xs font-medium mb-2 ${theme.textMuted}`}>Add prompt</p>
            <div className="flex gap-2">
              <button onClick={() => addPrompt('text')} className={`flex-1 py-2 px-3 rounded-lg text-xs font-medium ${theme.btnSecondary}`}>+ Text</button>
              <button onClick={() => addPrompt('slider')} className={`flex-1 py-2 px-3 rounded-lg text-xs font-medium ${theme.btnSecondary}`}>+ Slider</button>
              <button onClick={() => addPrompt('yesno')} className={`flex-1 py-2 px-3 rounded-lg text-xs font-medium ${theme.btnSecondary}`}>+ Yes/No</button>
            </div>
          </div>
          
          {/* Prompts List */}
          <div className="flex-1 overflow-y-auto px-5 py-3">
            {prompts.length === 0 ? (
              <p className={`text-center py-8 text-sm ${theme.textMuted}`}>No prompts yet</p>
            ) : (
              <div className="space-y-2">
                {prompts.map((prompt, index) => (
                  <div key={prompt.id} className={`rounded-xl border ${theme.border} overflow-hidden`}>
                    <div className={`flex items-center gap-2 p-3 ${theme.inputBg}`}>
                      {/* Reorder */}
                      <div className="flex flex-col gap-0.5">
                        <button onClick={() => movePrompt(index, -1)} disabled={index === 0} className={index === 0 ? 'opacity-30' : ''}>
                          <ChevronUp className={`w-3 h-3 ${theme.textMuted}`} />
                        </button>
                        <button onClick={() => movePrompt(index, 1)} disabled={index === prompts.length - 1} className={index === prompts.length - 1 ? 'opacity-30' : ''}>
                          <ChevronDown className={`w-3 h-3 ${theme.textMuted}`} />
                        </button>
                      </div>
                      
                      {/* Type badge */}
                      <span className={`text-xs px-2 py-0.5 rounded-full flex-shrink-0 ${theme.btnSecondary}`}>
                        {prompt.type}
                      </span>
                      
                      {/* Label input */}
                      <input
                        type="text"
                        value={prompt.label}
                        onChange={(e) => updatePrompt(prompt.id, 'label', e.target.value)}
                        className={`flex-1 px-2 py-1 rounded text-sm ${theme.cardBg} ${theme.textPrimary} border ${theme.border}`}
                      />
                      
                      {/* Delete */}
                      <button onClick={() => deletePrompt(prompt.id)} className="p-1 text-red-500">
                        <Trash2 className="w-4 h-4" />
                      </button>
                    </div>
                    
                    {/* Type-specific settings */}
                    {prompt.type === 'text' && (
                      <div className={`px-3 pb-3 pt-1`}>
                        <label className={`text-xs ${theme.textMuted}`}>Placeholder</label>
                        <input
                          type="text"
                          value={prompt.placeholder || ''}
                          onChange={(e) => updatePrompt(prompt.id, 'placeholder', e.target.value)}
                          className={`w-full mt-1 px-2 py-1.5 rounded text-sm ${theme.cardBg} ${theme.textPrimary} border ${theme.border}`}
                        />
                      </div>
                    )}
                    
                    {prompt.type === 'slider' && (
                      <div className={`px-3 pb-3 pt-1 flex gap-3`}>
                        <div className="flex-1">
                          <label className={`text-xs ${theme.textMuted}`}>Min</label>
                          <input
                            type="number"
                            value={prompt.min || 0}
                            onChange={(e) => updatePrompt(prompt.id, 'min', parseInt(e.target.value))}
                            className={`w-full mt-1 px-2 py-1.5 rounded text-sm ${theme.cardBg} ${theme.textPrimary} border ${theme.border}`}
                          />
                        </div>
                        <div className="flex-1">
                          <label className={`text-xs ${theme.textMuted}`}>Max</label>
                          <input
                            type="number"
                            value={prompt.max || 10}
                            onChange={(e) => updatePrompt(prompt.id, 'max', parseInt(e.target.value))}
                            className={`w-full mt-1 px-2 py-1.5 rounded text-sm ${theme.cardBg} ${theme.textPrimary} border ${theme.border}`}
                          />
                        </div>
                      </div>
                    )}
                  </div>
                ))}
              </div>
            )}
          </div>
          
          {/* Footer */}
          <div className={`px-5 py-4 border-t ${theme.border} flex gap-2 flex-shrink-0`}>
            <button onClick={() => onSave({ prompts })} className={`flex-1 py-2.5 rounded-lg text-sm font-medium ${theme.btnPrimary}`}>Save</button>
            <button onClick={onCancel} className={`px-4 py-2.5 rounded-lg text-sm font-medium ${theme.btnSecondary}`}>Cancel</button>
          </div>
        </div>
      </div>
    );
  };

  // ============================================
  // CATEGORY SETTINGS MODAL
  // ============================================
  const CategorySettingsModal = ({ categories: cats, onSave, onCancel }) => {
    const [localCategories, setLocalCategories] = useState(cats || []);
    const colorOptions = ['#6366f1', '#10b981', '#f59e0b', '#ec4899', '#8b5cf6', '#06b6d4', '#ef4444', '#84cc16', '#f97316', '#14b8a6'];
    
    const addCategory = () => {
      setLocalCategories([...localCategories, {
        id: `cat-${Date.now()}`,
        name: 'New Category',
        color: colorOptions[localCategories.length % colorOptions.length]
      }]);
    };
    
    const updateCategory = (id, field, value) => {
      setLocalCategories(localCategories.map(c => c.id === id ? { ...c, [field]: value } : c));
    };
    
    const deleteCategory = (id) => {
      if (localCategories.length <= 1) return;
      setLocalCategories(localCategories.filter(c => c.id !== id));
    };

    return (
      <div className="fixed inset-0 bg-black/30 backdrop-blur-sm flex items-center justify-center z-50 p-4">
        <div className={`${theme.cardBg} rounded-2xl p-5 w-full max-w-md max-h-[90vh] overflow-y-auto shadow-xl`}>
          <div className="flex items-center justify-between mb-4">
            <h3 className={`text-base font-semibold ${theme.textPrimary}`}>Edit Categories</h3>
            <button onClick={onCancel} className={`p-1 rounded-lg`}>
              <X className={`w-5 h-5 ${theme.textMuted}`} />
            </button>
          </div>
          
          <div className="space-y-2 mb-4">
            {localCategories.map((cat) => (
              <div key={cat.id} className={`p-3 rounded-lg ${theme.inputBg}`}>
                <div className="flex items-center gap-3">
                  <div className="flex gap-1">
                    {colorOptions.map(color => (
                      <button
                        key={color}
                        onClick={() => updateCategory(cat.id, 'color', color)}
                        className={`w-5 h-5 rounded-full ${cat.color === color ? 'ring-2 ring-offset-1 ring-slate-400' : ''}`}
                        style={{ backgroundColor: color }}
                      />
                    ))}
                  </div>
                </div>
                <div className="flex items-center gap-2 mt-2">
                  <div className="w-3 h-3 rounded-full flex-shrink-0" style={{ backgroundColor: cat.color }} />
                  <input
                    type="text"
                    value={cat.name}
                    onChange={(e) => updateCategory(cat.id, 'name', e.target.value)}
                    className={`flex-1 rounded-lg px-2 py-1.5 text-sm ${theme.cardBg} ${theme.textPrimary}`}
                  />
                  <button 
                    onClick={() => deleteCategory(cat.id)} 
                    disabled={localCategories.length <= 1}
                    className={`p-1 rounded-lg ${localCategories.length <= 1 ? 'opacity-30' : 'text-red-500 hover:bg-red-500/10'}`}
                  >
                    <Trash2 className="w-3.5 h-3.5" />
                  </button>
                </div>
              </div>
            ))}
          </div>
          
          <button onClick={addCategory} className={`w-full py-2 rounded-lg text-sm font-medium mb-4 ${theme.btnSecondary}`}>+ Add Category</button>
          
          <div className="flex gap-2">
            <button onClick={() => onSave(localCategories)} className={`flex-1 py-2 rounded-lg text-sm font-medium ${theme.btnPrimary}`}>Save</button>
            <button onClick={onCancel} className={`px-4 py-2 rounded-lg text-sm font-medium ${theme.btnSecondary}`}>Cancel</button>
          </div>
        </div>
      </div>
    );
  };

  const ViewCompletionModal = ({ completion, taskName, onClose }) => (
    <div className="fixed inset-0 bg-black/30 backdrop-blur-sm flex items-center justify-center z-50 p-4">
      <div className={`${theme.cardBg} rounded-2xl p-5 w-full max-w-md shadow-xl`}>
        <div className="flex items-start justify-between mb-4">
          <h3 className={`text-base font-semibold ${theme.textPrimary}`}>{taskName}</h3>
          <button onClick={onClose} className={`p-1 rounded-lg`}><X className={`w-5 h-5 ${theme.textMuted}`} /></button>
        </div>
        <div className="space-y-3">
          {completion.note && <div><p className={`text-xs font-medium mb-1 ${theme.textMuted}`}>Note</p><p className={`p-2 rounded-lg text-sm ${theme.inputBg} ${theme.textSecondary}`}>{completion.note}</p></div>}
          {completion.photo && <div><p className={`text-xs font-medium mb-1 ${theme.textMuted}`}>Photo</p><img src={completion.photo} alt="Completion" className="w-full h-48 object-cover rounded-lg" /></div>}
          {completion.timestamp && <p className={`text-xs ${theme.textMuted}`}>Completed {new Date(completion.timestamp).toLocaleString()}</p>}
        </div>
        <button onClick={onClose} className={`w-full mt-4 py-2 rounded-lg text-sm font-medium ${theme.btnSecondary}`}>Close</button>
      </div>
    </div>
  );

  const TaskCompletionModal = ({ onSave, onCancel, taskName }) => {
    const [note, setNote] = useState('');
    const [photo, setPhoto] = useState(null);
    const [photoPreview, setPhotoPreview] = useState(null);
    const handlePhotoChange = (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onloadend = () => { setPhoto(reader.result); setPhotoPreview(reader.result); };
        reader.readAsDataURL(file);
      }
    };
    return (
      <div className="fixed inset-0 bg-black/30 backdrop-blur-sm flex items-center justify-center z-50 p-4">
        <div className={`${theme.cardBg} rounded-2xl p-5 w-full max-w-md shadow-xl`}>
          <h3 className={`text-base font-semibold mb-4 ${theme.textPrimary}`}>{taskName} completed! </h3>
          <div className="space-y-3">
            <div>
              <label className={`block text-xs font-medium mb-1 ${theme.textMuted}`}>Note (optional)</label>
              <textarea value={note} onChange={(e) => setNote(e.target.value)} placeholder="How did it go?" className={`w-full rounded-lg px-3 py-2 text-sm ${theme.inputBg} ${theme.textPrimary}`} rows="2" />
            </div>
            <div>
              <label className={`block text-xs font-medium mb-1 ${theme.textMuted}`}>Photo (optional)</label>
              <input type="file" accept="image/*" onChange={handlePhotoChange} className={`w-full text-xs ${theme.textMuted}`} />
              {photoPreview && (
                <div className="mt-2 relative">
                  <img src={photoPreview} alt="Preview" className="w-full h-32 object-cover rounded-lg" />
                  <button onClick={() => { setPhoto(null); setPhotoPreview(null); }} className="absolute top-1 right-1 p-1 bg-red-500 rounded-full"><X className="w-3 h-3 text-white" /></button>
                </div>
              )}
            </div>
          </div>
          <div className="flex gap-2 mt-4">
            <button onClick={() => onSave(note, photo)} className={`flex-1 py-2 rounded-lg text-sm font-medium ${theme.btnPrimary}`}>{note || photo ? 'Save' : 'Done'}</button>
            <button onClick={onCancel} className={`px-4 py-2 rounded-lg text-sm font-medium ${theme.btnSecondary}`}>Cancel</button>
          </div>
        </div>
      </div>
    );
  };

  // ============================================
  // GOAL FORM - OPTION E CARD-BASED DESIGN
  // ============================================
  const GoalForm = ({ goal, onSave, onCancel }) => {
    const isEditing = !!goal;
    
    const migrateOldGoal = (oldGoal) => {
      if (!oldGoal) return null;
      if (oldGoal.tasks && Array.isArray(oldGoal.tasks)) {
        // Ensure all tasks have the new fields
        const migratedTasks = oldGoal.tasks.map(task => ({
          ...task,
          importance: task.importance || 'medium',
          difficulty: task.difficulty || 'medium',
          timeEstimate: task.timeEstimate || 15
        }));
        return { ...oldGoal, tasks: migratedTasks, motivation: oldGoal.motivation || '' };
      }
      return { ...oldGoal, motivation: '', tasks: [{ 
        id: Date.now(), 
        action: oldGoal.dailyAction || '', 
        frequency: oldGoal.frequency || 'daily', 
        weeklyTarget: oldGoal.weeklyTarget || 4, 
        dailyChecks: 1, 
        pointValue: 1,
        importance: 'medium',
        difficulty: 'medium',
        timeEstimate: 15
      }] };
    };
    
    const migratedGoal = goal ? migrateOldGoal(goal) : null;
    const [formData, setFormData] = useState(migratedGoal || {
      title: '', 
      yearlyGoal: '', 
      motivation: '',
      checkpoint: 'weekly', 
      checkpointValue: '', 
      category: 'personal',
      goalType: 'checkbox',
      pointTarget: 10,
      pointTargetFrequency: 'daily',
      tasks: [{ 
        id: Date.now(), 
        action: '', 
        frequency: 'daily', 
        weeklyTarget: 4, 
        dailyChecks: 1, 
        pointValue: 1,
        importance: 'medium',
        difficulty: 'medium',
        timeEstimate: 15
      }]
    });

    // Helper function to update a task field
    const updateTask = (index, field, value) => {
      const newTasks = [...formData.tasks];
      newTasks[index] = { ...newTasks[index], [field]: value };
      setFormData({ ...formData, tasks: newTasks });
    };

    // Card wrapper style (inline to avoid re-render issues)
    const cardClass = `p-3 rounded-xl ${theme.cardBg} border ${darkMode ? 'border-slate-700' : 'border-slate-200'}`;
    const cardHeaderClass = "flex items-center gap-2 mb-2";

    // Metrics Row - defined as a function that returns JSX
    const renderMetricsRow = (task, index, showTime = true) => (
      <div className={`grid ${showTime ? 'grid-cols-3' : 'grid-cols-2'} gap-2`}>
        {/* Importance */}
        <div className={`p-2 rounded-lg ${darkMode ? 'bg-slate-700' : 'bg-white'} border ${darkMode ? 'border-slate-600' : 'border-slate-200'}`}>
          <div className="flex items-center gap-1 mb-1">
            <Flame className="w-3 h-3 text-orange-500" />
            <span className={`text-[10px] ${theme.textMuted} uppercase tracking-wider`}>Priority</span>
          </div>
          <select 
            value={task.importance || 'medium'} 
            onChange={(e) => updateTask(index, 'importance', e.target.value)}
            className={`w-full text-xs font-medium ${theme.textPrimary} bg-transparent border-none outline-none -ml-0.5`}
          >
            <option value="low">Low</option>
            <option value="medium">Medium</option>
            <option value="high">High</option>
            <option value="critical">Critical</option>
          </select>
        </div>
        
        {/* Difficulty */}
        <div className={`p-2 rounded-lg ${darkMode ? 'bg-slate-700' : 'bg-white'} border ${darkMode ? 'border-slate-600' : 'border-slate-200'}`}>
          <div className="flex items-center gap-1 mb-1">
            <Zap className="w-3 h-3 text-purple-500" />
            <span className={`text-[10px] ${theme.textMuted} uppercase tracking-wider`}>Effort</span>
          </div>
          <select 
            value={task.difficulty || 'medium'} 
            onChange={(e) => updateTask(index, 'difficulty', e.target.value)}
            className={`w-full text-xs font-medium ${theme.textPrimary} bg-transparent border-none outline-none -ml-0.5`}
          >
            <option value="easy">Easy</option>
            <option value="medium">Medium</option>
            <option value="hard">Hard</option>
          </select>
        </div>
        
        {/* Time Estimate */}
        {showTime && (
          <div className={`p-2 rounded-lg ${darkMode ? 'bg-slate-700' : 'bg-white'} border ${darkMode ? 'border-slate-600' : 'border-slate-200'}`}>
            <div className="flex items-center gap-1 mb-1">
              <Clock className="w-3 h-3 text-blue-500" />
              <span className={`text-[10px] ${theme.textMuted} uppercase tracking-wider`}>Time</span>
            </div>
            <div className="flex items-baseline">
              <input 
                type="text"
                inputMode="numeric"
                value={task.timeEstimate || ''} 
                onChange={(e) => {
                  const val = e.target.value;
                  if (val === '' || /^\d+$/.test(val)) {
                    updateTask(index, 'timeEstimate', val === '' ? '' : parseInt(val));
                  }
                }}
                className={`w-8 text-xs font-medium ${theme.textPrimary} bg-transparent border-none outline-none`}
              />
              <span className={`text-[10px] ${theme.textMuted}`}>min</span>
            </div>
          </div>
        )}
      </div>
    );

    // Compact Metrics Row - for edit mode
    const renderCompactMetricsRow = (task, index) => (
      <div className="flex items-center gap-2 flex-wrap mt-2">
        <div className={`flex items-center gap-1 px-2 py-1 rounded text-xs ${darkMode ? 'bg-orange-900/30' : 'bg-orange-50'}`}>
          <Flame className="w-3 h-3 text-orange-500" />
          <select 
            value={task.importance || 'medium'} 
            onChange={(e) => updateTask(index, 'importance', e.target.value)}
            className={`bg-transparent border-none outline-none font-medium ${darkMode ? 'text-orange-400' : 'text-orange-700'}`}
          >
            <option value="low">Low</option>
            <option value="medium">Med</option>
            <option value="high">High</option>
            <option value="critical">Crit</option>
          </select>
        </div>
        <div className={`flex items-center gap-1 px-2 py-1 rounded text-xs ${darkMode ? 'bg-purple-900/30' : 'bg-purple-50'}`}>
          <Zap className="w-3 h-3 text-purple-500" />
          <select 
            value={task.difficulty || 'medium'} 
            onChange={(e) => updateTask(index, 'difficulty', e.target.value)}
            className={`bg-transparent border-none outline-none font-medium ${darkMode ? 'text-purple-400' : 'text-purple-700'}`}
          >
            <option value="easy">Easy</option>
            <option value="medium">Med</option>
            <option value="hard">Hard</option>
          </select>
        </div>
        <div className={`flex items-center gap-1 px-2 py-1 rounded text-xs ${darkMode ? 'bg-blue-900/30' : 'bg-blue-50'}`}>
          <Clock className="w-3 h-3 text-blue-500" />
          <input 
            type="text"
            inputMode="numeric"
            value={task.timeEstimate || ''} 
            onChange={(e) => {
              const val = e.target.value;
              if (val === '' || /^\d+$/.test(val)) {
                updateTask(index, 'timeEstimate', val === '' ? '' : parseInt(val));
              }
            }}
            className={`w-6 bg-transparent border-none outline-none font-medium ${darkMode ? 'text-blue-400' : 'text-blue-700'}`}
          />
          <span className={darkMode ? 'text-blue-400' : 'text-blue-600'}>m</span>
        </div>
      </div>
    );

    // Task Type Badge - as function
    const renderTaskTypeBadge = (type) => {
      const config = {
        checkbox: { Icon: CheckCircle2, bg: 'bg-green-100', color: 'text-green-600', label: 'Checkbox' },
        slider: { Icon: Sliders, bg: 'bg-blue-100', color: 'text-blue-600', label: 'Slider' },
        counter: { Icon: Hash, bg: 'bg-purple-100', color: 'text-purple-600', label: 'Counter' }
      };
      const c = config[type] || config.checkbox;
      return (
        <div className={`flex items-center gap-1 px-2 py-0.5 rounded ${darkMode ? 'bg-slate-700' : c.bg}`}>
          <c.Icon className={`w-3 h-3 ${c.color}`} />
          <span className={`text-[10px] font-medium uppercase ${c.color}`}>{c.label}</span>
        </div>
      );
    };

    return (
      <div className="fixed inset-0 bg-black/30 backdrop-blur-sm flex items-center justify-center z-50 p-4">
        <div 
          className={`${theme.cardBg} rounded-2xl w-full max-w-md shadow-xl`}
          style={{ maxHeight: '90vh', display: 'flex', flexDirection: 'column', overflow: 'hidden' }}
        >
          {/* Fixed Header */}
          <div className="px-5 pt-5 pb-3" style={{ flexShrink: 0 }}>
            <h3 className={`text-base font-semibold ${theme.textPrimary}`}>{isEditing ? 'Edit Goal' : 'New Goal'}</h3>
          </div>
          
          {/* Scrollable Content */}
          <div className="px-5 pb-4" style={{ flex: 1, overflowY: 'auto', minHeight: 0 }}>
            <div className="space-y-3">
              
              {/* Goal Title Card - INLINE */}
              <div className={cardClass}>
                <div className={cardHeaderClass}>
                  <div className={`w-7 h-7 rounded-lg ${darkMode ? 'bg-indigo-900/50' : 'bg-indigo-100'} flex items-center justify-center`}>
                    <Target className="w-4 h-4 text-indigo-500" />
                  </div>
                  <span className={`text-xs font-medium ${theme.textSecondary}`}>Goal</span>
                </div>
                <input 
                  type="text" 
                  value={formData.title} 
                  onChange={(e) => setFormData({ ...formData, title: e.target.value })}
                  className={`w-full text-sm font-medium ${theme.textPrimary} bg-transparent border-none outline-none`}
                  placeholder="What do you want to achieve?"
                />
              </div>

              {/* Yearly Target Card - INLINE */}
              <div className={cardClass}>
                <div className={cardHeaderClass}>
                  <div className={`w-7 h-7 rounded-lg ${darkMode ? 'bg-amber-900/50' : 'bg-amber-100'} flex items-center justify-center`}>
                    <Trophy className="w-4 h-4 text-amber-500" />
                  </div>
                  <span className={`text-xs font-medium ${theme.textSecondary}`}>Target</span>
                  <span className={`text-xs ${theme.textMuted} ml-auto`}>(optional)</span>
                </div>
                <input 
                  type="text" 
                  value={formData.yearlyGoal} 
                  onChange={(e) => setFormData({ ...formData, yearlyGoal: e.target.value })}
                  className={`w-full text-sm ${theme.textSecondary} bg-transparent border-none outline-none`}
                  placeholder="What's the big picture outcome?"
                />
              </div>

              {/* Category Card - INLINE */}
              <div className={cardClass}>
                <div className={cardHeaderClass}>
                  <div className={`w-7 h-7 rounded-lg ${darkMode ? 'bg-emerald-900/50' : 'bg-emerald-100'} flex items-center justify-center`}>
                    <Book className="w-4 h-4 text-emerald-500" />
                  </div>
                  <span className={`text-xs font-medium ${theme.textSecondary}`}>Category</span>
                </div>
                <select 
                  value={formData.category} 
                  onChange={(e) => setFormData({ ...formData, category: e.target.value })}
                  className={`w-full text-sm font-medium ${theme.textPrimary} bg-transparent border-none outline-none -ml-1`}
                >
                  {(categories || []).map(cat => (
                    <option key={cat.id} value={cat.id}>{cat.name}</option>
                  ))}
                </select>
              </div>

              {/* Goal Type Selector */}
              <div className={`p-3 rounded-xl ${theme.cardBg} border ${darkMode ? 'border-slate-700' : 'border-slate-200'}`}>
                <div className="flex items-center gap-2 mb-2">
                  <span className={`text-xs font-medium ${theme.textSecondary}`}>Goal Type</span>
                </div>
                <div className="flex gap-2">
                  <button
                    type="button"
                    onClick={() => setFormData({ ...formData, goalType: 'checkbox' })}
                    className={`flex-1 py-2 px-3 rounded-lg text-sm font-medium flex items-center justify-center gap-2 transition-all ${
                      formData.goalType === 'checkbox' ? theme.btnPrimary : theme.btnSecondary
                    }`}
                  >
                    <CheckCircle2 className="w-4 h-4" />
                    Checkbox
                  </button>
                  <button
                    type="button"
                    onClick={() => setFormData({ ...formData, goalType: 'points' })}
                    className={`flex-1 py-2 px-3 rounded-lg text-sm font-medium flex items-center justify-center gap-2 transition-all ${
                      formData.goalType === 'points' ? theme.btnPrimary : theme.btnSecondary
                    }`}
                  >
                    <Star className="w-4 h-4" />
                    Points
                  </button>
                </div>
              </div>

              {/* Points Target (only for points goals) - INLINE */}
              {formData.goalType === 'points' && (
                <div className={cardClass}>
                  <div className={cardHeaderClass}>
                    <div className={`w-7 h-7 rounded-lg ${darkMode ? 'bg-amber-900/50' : 'bg-amber-100'} flex items-center justify-center`}>
                      <Star className="w-4 h-4 text-amber-500" />
                    </div>
                    <span className={`text-xs font-medium ${theme.textSecondary}`}>Points Target</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <Star className="w-4 h-4 text-amber-500" />
                    <input 
                      type="text" 
                      inputMode="numeric"
                      pattern="[0-9]*"
                      value={formData.pointTarget || ''} 
                      onChange={(e) => {
                        const val = e.target.value;
                        if (val === '' || /^\d+$/.test(val)) {
                          setFormData({ ...formData, pointTarget: val === '' ? '' : parseInt(val) });
                        }
                      }}
                      onBlur={(e) => {
                        if (!e.target.value || parseInt(e.target.value) < 1) {
                          setFormData({ ...formData, pointTarget: 1 });
                        }
                      }}
                      className={`w-16 text-lg font-bold ${theme.textPrimary} bg-transparent border-none outline-none`}
                    />
                    <span className={`text-sm ${theme.textMuted}`}>points per</span>
                    <select 
                      value={formData.pointTargetFrequency} 
                      onChange={(e) => setFormData({ ...formData, pointTargetFrequency: e.target.value })}
                      className={`text-sm font-medium ${theme.textPrimary} ${theme.inputBg} rounded-lg px-2 py-1 border-none`}
                    >
                      <option value="daily">day</option>
                      <option value="weekly">week</option>
                    </select>
                  </div>
                </div>
              )}

              {/* Why / Motivation Card - INLINE */}
              <div className={cardClass}>
                <div className={cardHeaderClass}>
                  <div className={`w-7 h-7 rounded-lg ${darkMode ? 'bg-rose-900/50' : 'bg-rose-100'} flex items-center justify-center`}>
                    <Heart className="w-4 h-4 text-rose-500" />
                  </div>
                  <span className={`text-xs font-medium ${theme.textSecondary}`}>Why This Matters</span>
                  <span className={`text-xs ${theme.textMuted} ml-auto`}>(optional)</span>
                </div>
                <textarea 
                  value={formData.motivation || ''}
                  onChange={(e) => setFormData({ ...formData, motivation: e.target.value })}
                  className={`w-full text-sm ${theme.textSecondary} bg-transparent border-none outline-none resize-none`}
                  rows={2}
                  placeholder="Connect this goal to your deeper purpose..."
                />
              </div>

              {/* Tasks Divider */}
              <div className="flex items-center gap-2 py-2">
                <div className={`flex-1 h-px ${darkMode ? 'bg-slate-700' : 'bg-slate-200'}`} />
                <span className={`text-xs font-medium ${theme.textMuted}`}>
                  {formData.goalType === 'points' ? 'POINT-EARNING TASKS' : 'TASKS'}
                </span>
                <div className={`flex-1 h-px ${darkMode ? 'bg-slate-700' : 'bg-slate-200'}`} />
              </div>

              {/* Tasks List */}
              <div className="space-y-3">
                {formData.tasks.map((task, index) => (
                  <div key={task.id} className={`p-3 rounded-xl ${theme.inputBg} border ${darkMode ? 'border-slate-700' : 'border-slate-200'}`}>
                    
                    {/* Task Type Badge (for points goals) */}
                    {formData.goalType === 'points' && (
                      <div className="flex items-center justify-between mb-2">
                        {renderTaskTypeBadge(task.taskType || 'checkbox')}
                        {formData.tasks.length > 1 && (
                          <button 
                            type="button" 
                            onClick={() => setFormData({ ...formData, tasks: formData.tasks.filter((_, i) => i !== index) })}
                            className="p-1 text-red-400 hover:text-red-500 hover:bg-red-500/10 rounded"
                          >
                            <X className="w-4 h-4" />
                          </button>
                        )}
                      </div>
                    )}

                    {/* Task Name */}
                    <div className="flex items-start gap-2 mb-3">
                      <input 
                        type="text" 
                        value={task.action} 
                        onChange={(e) => updateTask(index, 'action', e.target.value)}
                        className={`flex-1 rounded-lg px-3 py-2 text-sm font-medium ${theme.cardBg} ${theme.textPrimary} border ${darkMode ? 'border-slate-600' : 'border-slate-200'}`}
                        placeholder="What's the action?"
                      />
                      {formData.goalType !== 'points' && formData.tasks.length > 1 && (
                        <button 
                          type="button" 
                          onClick={() => setFormData({ ...formData, tasks: formData.tasks.filter((_, i) => i !== index) })}
                          className="p-2 text-red-400 hover:text-red-500"
                        >
                          <X className="w-4 h-4" />
                        </button>
                      )}
                    </div>

                    {/* Metrics Row - use compact for edit mode, full for create */}
                    {isEditing ? (
                      renderCompactMetricsRow(task, index)
                    ) : (
                      renderMetricsRow(task, index, formData.goalType !== 'points' || task.taskType === 'checkbox' || !task.taskType)
                    )}

                    {/* Points Goal Specific Fields */}
                    {formData.goalType === 'points' && (
                      <div className="mt-3 space-y-2">
                        {/* Task Type Selector */}
                        <div className="flex items-center gap-2">
                          <span className={`text-xs ${theme.textMuted}`}>Type:</span>
                          <select 
                            value={task.taskType || 'checkbox'} 
                            onChange={(e) => { 
                              const newTasks = [...formData.tasks]; 
                              newTasks[index].taskType = e.target.value; 
                              if (e.target.value === 'slider') {
                                newTasks[index].maxValue = newTasks[index].maxValue || 10;
                                newTasks[index].pointsPerUnit = newTasks[index].pointsPerUnit || 1;
                              } else if (e.target.value === 'counter') {
                                newTasks[index].unitsPerPoint = newTasks[index].unitsPerPoint || 1;
                                newTasks[index].pointsPerUnit = newTasks[index].pointsPerUnit || 1;
                              }
                              setFormData({ ...formData, tasks: newTasks }); 
                            }} 
                            className={`flex-1 rounded-lg px-2 py-1.5 text-xs ${theme.cardBg} ${theme.textPrimary} border ${darkMode ? 'border-slate-600' : 'border-slate-200'}`}
                          >
                            <option value="checkbox">Checkbox (+X pts)</option>
                            <option value="slider">Slider (0 to max)</option>
                            <option value="counter">Counter (+/)</option>
                          </select>
                        </div>

                        {/* Checkbox type - point value */}
                        {(!task.taskType || task.taskType === 'checkbox') && (
                          <div className={`flex items-center gap-2 p-2 rounded-lg ${darkMode ? 'bg-amber-900/20' : 'bg-amber-50'}`}>
                            <Star className="w-4 h-4 text-amber-500" />
                            <span className={`text-xs ${darkMode ? 'text-amber-400' : 'text-amber-700'}`}>Earns</span>
                            <input 
                              type="text" 
                              inputMode="numeric"
                              value={task.pointValue || ''} 
                              onChange={(e) => {
                                const val = e.target.value;
                                if (val === '' || /^\d+$/.test(val)) {
                                  updateTask(index, 'pointValue', val === '' ? '' : parseInt(val));
                                }
                              }}
                              onBlur={(e) => {
                                if (!e.target.value || parseInt(e.target.value) < 1) {
                                  updateTask(index, 'pointValue', 1);
                                }
                              }}
                              className={`w-12 text-sm font-bold ${darkMode ? 'text-amber-400 bg-slate-800' : 'text-amber-700 bg-white'} rounded px-2 py-0.5 border ${darkMode ? 'border-amber-800' : 'border-amber-200'}`}
                            />
                            <span className={`text-xs ${darkMode ? 'text-amber-400' : 'text-amber-700'}`}>points when done</span>
                          </div>
                        )}

                        {/* Slider type config */}
                        {task.taskType === 'slider' && (
                          <div className="space-y-2">
                            <div className={`p-2 rounded-lg ${darkMode ? 'bg-blue-900/20' : 'bg-blue-50'}`}>
                              <div className={`flex items-center gap-2 text-xs ${darkMode ? 'text-blue-400' : 'text-blue-700'}`}>
                                <span>Track 0 to</span>
                                <input 
                                  type="text" 
                                  inputMode="numeric"
                                  value={task.maxValue || ''} 
                                  onChange={(e) => {
                                    const val = e.target.value;
                                    if (val === '' || /^\d+$/.test(val)) {
                                      updateTask(index, 'maxValue', val === '' ? '' : parseInt(val));
                                    }
                                  }}
                                  className={`w-12 text-sm font-bold ${darkMode ? 'bg-slate-800 text-blue-400' : 'bg-white text-blue-700'} rounded px-2 py-0.5 border ${darkMode ? 'border-blue-800' : 'border-blue-200'}`}
                                />
                              </div>
                            </div>
                            <div className={`flex items-center gap-2 p-2 rounded-lg ${darkMode ? 'bg-amber-900/20' : 'bg-amber-50'}`}>
                              <Star className="w-4 h-4 text-amber-500" />
                              <span className={`text-xs ${darkMode ? 'text-amber-400' : 'text-amber-700'}`}>Each unit earns</span>
                              <input 
                                type="text" 
                                inputMode="numeric"
                                value={task.pointsPerUnit || ''} 
                                onChange={(e) => {
                                  const val = e.target.value;
                                  if (val === '' || /^\d+$/.test(val)) {
                                    updateTask(index, 'pointsPerUnit', val === '' ? '' : parseInt(val));
                                  }
                                }}
                                className={`w-10 text-sm font-bold ${darkMode ? 'text-amber-400 bg-slate-800' : 'text-amber-700 bg-white'} rounded px-2 py-0.5 border ${darkMode ? 'border-amber-800' : 'border-amber-200'}`}
                              />
                              <span className={`text-xs ${darkMode ? 'text-amber-400' : 'text-amber-700'}`}>point(s)</span>
                            </div>
                          </div>
                        )}

                        {/* Counter type config */}
                        {task.taskType === 'counter' && (
                          <div className="space-y-2">
                            <div className={`p-2 rounded-lg ${darkMode ? 'bg-purple-900/20' : 'bg-purple-50'}`}>
                              <div className={`flex items-center gap-1 text-xs ${darkMode ? 'text-purple-400' : 'text-purple-700'} flex-wrap`}>
                                <span>Every</span>
                                <input 
                                  type="text" 
                                  inputMode="numeric"
                                  value={task.unitsPerPoint || ''} 
                                  onChange={(e) => {
                                    const val = e.target.value;
                                    if (val === '' || /^\d+$/.test(val)) {
                                      updateTask(index, 'unitsPerPoint', val === '' ? '' : parseInt(val));
                                    }
                                  }}
                                  className={`w-10 text-sm font-bold ${darkMode ? 'bg-slate-800 text-purple-400' : 'bg-white text-purple-700'} rounded px-2 py-0.5 border ${darkMode ? 'border-purple-800' : 'border-purple-200'}`}
                                />
                                <input 
                                  type="text" 
                                  value={task.unitLabel || ''} 
                                  onChange={(e) => updateTask(index, 'unitLabel', e.target.value)}
                                  placeholder="min"
                                  className={`w-12 text-sm ${darkMode ? 'bg-slate-800 text-purple-400' : 'bg-white text-purple-700'} rounded px-2 py-0.5 border ${darkMode ? 'border-purple-800' : 'border-purple-200'}`}
                                />
                                <span>=</span>
                                <Star className="w-3.5 h-3.5 text-amber-500" />
                                <input 
                                  type="text" 
                                  inputMode="numeric"
                                  value={task.pointsPerUnit || ''} 
                                  onChange={(e) => {
                                    const val = e.target.value;
                                    if (val === '' || /^\d+$/.test(val)) {
                                      updateTask(index, 'pointsPerUnit', val === '' ? '' : parseInt(val));
                                    }
                                  }}
                                  className={`w-10 text-sm font-bold ${darkMode ? 'bg-slate-800 text-amber-400' : 'bg-white text-amber-700'} rounded px-2 py-0.5 border ${darkMode ? 'border-amber-800' : 'border-amber-200'}`}
                                />
                                <span>pts</span>
                              </div>
                            </div>
                          </div>
                        )}
                      </div>
                    )}

                    {/* Frequency (checkbox goals only) */}
                    {formData.goalType !== 'points' && (
                      <div className="grid grid-cols-2 gap-2 mt-3">
                        <div>
                          <label className={`block text-[10px] ${theme.textMuted} uppercase tracking-wider mb-1`}>Frequency</label>
                          <select 
                            value={task.frequency} 
                            onChange={(e) => updateTask(index, 'frequency', e.target.value)}
                            className={`w-full rounded-lg px-2 py-1.5 text-xs ${theme.cardBg} ${theme.textPrimary} border ${darkMode ? 'border-slate-600' : 'border-slate-200'}`}
                          >
                            <option value="daily">Daily</option>
                            <option value="weekly">Weekly</option>
                            <option value="scheduled">Scheduled</option>
                          </select>
                        </div>
                        {task.frequency === 'scheduled' ? (
                          <div className="col-span-1">
                            <label className={`block text-[10px] ${theme.textMuted} uppercase tracking-wider mb-1`}>Days</label>
                            <div className="flex gap-1">
                              {['S','M','T','W','T','F','S'].map((dayLabel, dayIndex) => {
                                const isSelected = (task.scheduledDays || []).includes(dayIndex);
                                return (
                                  <button
                                    key={dayIndex}
                                    type="button"
                                    onClick={() => {
                                      const current = task.scheduledDays || [];
                                      const updated = isSelected 
                                        ? current.filter(d => d !== dayIndex)
                                        : [...current, dayIndex].sort();
                                      updateTask(index, 'scheduledDays', updated);
                                    }}
                                    className={`w-7 h-7 rounded-full text-[10px] font-medium transition-all ${
                                      isSelected 
                                        ? (darkMode ? 'bg-slate-200 text-slate-900' : 'bg-slate-700 text-white')
                                        : (darkMode ? 'bg-slate-700 text-slate-400' : 'bg-slate-100 text-slate-400')
                                    }`}
                                  >
                                    {dayLabel}
                                  </button>
                                );
                              })}
                            </div>
                          </div>
                        ) : (
                        <div>
                          <label className={`block text-[10px] ${theme.textMuted} uppercase tracking-wider mb-1`}>
                            {task.frequency === 'weekly' ? 'Target/week' : 'Times/day'}
                          </label>
                          <input 
                            type="text" 
                            inputMode="numeric"
                            value={task.frequency === 'weekly' ? (task.weeklyTarget || '') : (task.dailyChecks || '')} 
                            onChange={(e) => {
                              const val = e.target.value;
                              if (val === '' || /^\d+$/.test(val)) {
                                const field = task.frequency === 'weekly' ? 'weeklyTarget' : 'dailyChecks';
                                const max = task.frequency === 'weekly' ? 7 : 10;
                                updateTask(index, field, val === '' ? '' : Math.min(max, parseInt(val)));
                              }
                            }}
                            onBlur={(e) => {
                              if (!e.target.value || parseInt(e.target.value) < 1) {
                                const field = task.frequency === 'weekly' ? 'weeklyTarget' : 'dailyChecks';
                                updateTask(index, field, 1);
                              }
                            }}
                            className={`w-full rounded-lg px-2 py-1.5 text-xs ${theme.cardBg} ${theme.textPrimary} border ${darkMode ? 'border-slate-600' : 'border-slate-200'}`}
                          />
                        </div>
                        )}
                      </div>
                    )}

                    {/* Prompt for note/photo */}
                    <div className="flex items-center gap-2 mt-3">
                      <input 
                        type="checkbox" 
                        id={`prompt-${task.id}`} 
                        checked={task.promptForNote || false} 
                        onChange={(e) => updateTask(index, 'promptForNote', e.target.checked)}
                        className="w-3.5 h-3.5 rounded" 
                      />
                      <label htmlFor={`prompt-${task.id}`} className={`text-xs ${theme.textMuted}`}>Prompt for note/photo</label>
                    </div>
                  </div>
                ))}
              </div>

              {/* Add Task Button */}
              <button 
                type="button"
                onClick={() => setFormData({ 
                  ...formData, 
                  tasks: [...formData.tasks, { 
                    id: Date.now(), 
                    action: '', 
                    frequency: 'daily', 
                    weeklyTarget: 4, 
                    dailyChecks: 1, 
                    pointValue: 1,
                    importance: 'medium',
                    difficulty: 'medium',
                    timeEstimate: 15
                  }] 
                })}
                className={`w-full py-2.5 rounded-xl border-2 border-dashed ${darkMode ? 'border-slate-600 text-slate-400 hover:border-slate-500' : 'border-slate-300 text-slate-500 hover:border-slate-400'} text-sm font-medium flex items-center justify-center gap-2`}
              >
                <Plus className="w-4 h-4" />
                Add Task
              </button>

            </div>
          </div>
          
          {/* Fixed Footer */}
          <div className={`px-5 pb-5 pt-4 border-t ${theme.divider}`} style={{ flexShrink: 0 }}>
            <div className="flex gap-2">
              <button onClick={() => onSave(formData)} className={`flex-1 py-2.5 rounded-lg text-sm font-medium ${theme.btnPrimary}`}>
                {isEditing ? 'Save Changes' : 'Create Goal'}
              </button>
              <button onClick={onCancel} className={`px-4 py-2.5 rounded-lg text-sm font-medium ${theme.btnSecondary}`}>Cancel</button>
            </div>
          </div>
        </div>
      </div>
    );
  };

  // ============================================
  // CALENDAR VIEW (Week / Month / Year)
  // ============================================
  const getHeatColor = useCallback((pct) => {
    if (pct === 0) return darkMode ? '#1e293b' : '#f1f5f9';
    if (pct < 50) return '#fb923c';
    if (pct < 75) return '#facc15';
    const t = (pct - 75) / 25;
    const r = Math.round(134 - (134 - 34) * t);
    const g = Math.round(239 - (239 - 197) * t);
    const b = Math.round(172 - (172 - 94) * t);
    return `rgb(${r}, ${g}, ${b})`;
  }, [darkMode]);

  const getHeatTextColor = useCallback((pct, isFuture) => {
    if (isFuture) return darkMode ? '#475569' : '#cbd5e1';
    if (pct >= 75) return '#166534';
    if (pct >= 50) return '#854d0e';
    if (pct > 0) return '#9a3412';
    return darkMode ? '#94a3b8' : '#64748b';
  }, [darkMode]);

  const getHeatSubColor = useCallback((pct) => {
    if (pct >= 75) return '#15803d';
    return darkMode ? '#64748b' : '#94a3b8';
  }, [darkMode]);

  const CalendarView = () => {
    const goToDay = (date) => { setSelectedDate(date); setCurrentView('daily'); };
    const todayKey = toLocalDateKey(new Date());

    // ---- Date navigation helpers ----
    const changeWeek = (offset) => {
      const newDate = new Date(calendarDate);
      newDate.setDate(newDate.getDate() + offset * 7);
      setCalendarDate(newDate);
    };
    const changeMonth = (offset) => {
      const newDate = new Date(calendarDate);
      newDate.setMonth(newDate.getMonth() + offset);
      setCalendarDate(newDate);
    };
    const changeYear = (offset) => {
      const newDate = new Date(calendarDate);
      newDate.setFullYear(newDate.getFullYear() + offset);
      setCalendarDate(newDate);
    };

    // ---- Week data ----
    const getWeekDays = () => {
      const { weekStart } = getWeekRange(calendarDate);
      const days = [];
      for (let i = 0; i < 7; i++) {
        const d = new Date(weekStart);
        d.setDate(weekStart.getDate() + i);
        const dateKey = toLocalDateKey(d);
        const progress = calculateDailyProgress(dateKey);
        const isFuture = dateKey > todayKey;
        const isToday = dateKey === todayKey;
        const hasJournal = journalConfig.prompts.some(p => { const v = journalEntries[`${dateKey}-${p.id}`]; return v && (typeof v === 'string' ? v.trim().length > 0 : true); });
        const hasPhoto = !!dailyPhotos[dateKey];
        // Scheduled tasks for this day
        const scheduledTasks = [];
        goals.forEach(g => {
          if (!g.tasks) return;
          g.tasks.forEach(t => {
            if (t.frequency === 'scheduled' && isTaskScheduledForDate(t, d)) {
              scheduledTasks.push(t.action);
            }
          });
        });
        days.push({ date: d, dateKey, label: d.toLocaleDateString('en-US', { weekday: 'short' }), dayNum: d.getDate(), progress, isFuture, isToday, hasJournal, hasPhoto, scheduledTasks });
      }
      return days;
    };

    const weekDays = calendarMode === 'week' ? getWeekDays() : [];

    // ---- Week header label ----
    const getWeekLabel = () => {
      if (weekDays.length === 0) return '';
      const s = weekDays[0].date;
      const e = weekDays[6].date;
      if (s.getMonth() === e.getMonth()) {
        return `${s.toLocaleDateString('en-US', { month: 'long' })} ${s.getDate()}  ${e.getDate()}`;
      }
      return `${s.toLocaleDateString('en-US', { month: 'long' })} ${s.getDate()}  ${e.toLocaleDateString('en-US', { month: 'long' })} ${e.getDate()}`;
    };

    // Check if showing current week/month/year
    const isCurrentWeek = () => {
      const today = new Date();
      const { weekStart: currentWeekStart } = getWeekRange(today);
      const { weekStart: viewingWeekStart } = getWeekRange(calendarDate);
      return toLocalDateKey(currentWeekStart) === toLocalDateKey(viewingWeekStart);
    };

    // ---- Navigation label ----
    const navLabel = calendarMode === 'week' ? getWeekLabel()
      : calendarMode === 'month' ? calendarDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })
      : `${calendarDate.getFullYear()}`;
    
    const isThisWeek = calendarMode === 'week' && isCurrentWeek();
    const navSub = calendarMode === 'week' 
      ? (isThisWeek ? 'This week' : calendarDate.getFullYear().toString())
      : calendarMode === 'month' ? '' : '';

    const navPrev = () => { calendarMode === 'week' ? changeWeek(-1) : calendarMode === 'month' ? changeMonth(-1) : changeYear(-1); };
    const navNext = () => { calendarMode === 'week' ? changeWeek(1) : calendarMode === 'month' ? changeMonth(1) : changeYear(1); };

    // ==== WEEKLY VIEW ====
    const WeeklyCalendar = () => {
      const weekTotal = weekDays.reduce((s, d) => s + d.progress.total, 0);
      const weekDone = weekDays.reduce((s, d) => s + d.progress.completed, 0);
      const weekPct = weekTotal > 0 ? Math.round(weekDone / weekTotal * 100) : 0;
      const journalDays = weekDays.filter(d => d.hasJournal).length;
      const photoDays = weekDays.filter(d => d.hasPhoto).length;
      const scheduledDays = weekDays.filter(d => d.scheduledTasks.length > 0);

      // Journal slider prompts
      const sliderPrompts = journalConfig.prompts.filter(p => p.type === 'slider');

      // Category progress for this week
      const categoryProgress = (categories || []).map(cat => {
        const catGoals = goals.filter(g => g.category === cat.id && g.goalType !== 'points');
        if (catGoals.length === 0) return null;
        let totalAll = 0, totalDone = 0;
        const dailyBars = weekDays.map(day => {
          let dayTotal = 0, dayDone = 0;
          catGoals.forEach(goal => {
            if (!goal.tasks) return;
            goal.tasks.forEach(task => {
              if ((!task.frequency || task.frequency === 'daily') || (task.frequency === 'scheduled' && isTaskScheduledForDate(task, day.date))) {
                const checks = task.dailyChecks || 1;
                dayTotal += checks;
                for (let c = 0; c < checks; c++) {
                  if (dailyTasks[day.dateKey]?.[`${goal.id}-${task.id}-${c}`]) dayDone++;
                }
              }
            });
          });
          totalAll += dayTotal;
          totalDone += dayDone;
          return dayTotal > 0 ? dayDone / dayTotal : 0;
        });
        const pct = totalAll > 0 ? Math.round(totalDone / totalAll * 100) : 0;
        return { ...cat, pct, dailyBars };
      }).filter(Boolean);

      // ---- Effort Distribution for this week ----
      const weeklyEffortData = weekDays.map(day => {
        let easy = 0, medium = 0, hard = 0;
        goals.forEach(goal => {
          if (!goal.tasks) return;
          goal.tasks.forEach(task => {
            const diff = task.difficulty || 'medium';
            const isDaily = !task.frequency || task.frequency === 'daily';
            const isSched = task.frequency === 'scheduled' && isTaskScheduledForDate(task, day.date);
            if (!isDaily && !isSched) return;
            const checks = task.dailyChecks || 1;
            for (let c = 0; c < checks; c++) {
              if (dailyTasks[day.dateKey]?.[`${goal.id}-${task.id}-${c}`]) {
                if (diff === 'easy') easy++;
                else if (diff === 'hard') hard++;
                else medium++;
              }
            }
          });
        });
        return { easy, medium, hard, total: easy + medium + hard };
      });
      const weekEffortTotals = weeklyEffortData.reduce(
        (acc, d) => ({ easy: acc.easy + d.easy, medium: acc.medium + d.medium, hard: acc.hard + d.hard }),
        { easy: 0, medium: 0, hard: 0 }
      );
      const weekEffortTotal = weekEffortTotals.easy + weekEffortTotals.medium + weekEffortTotals.hard;

      // ---- Weekly Time Budget ----
      const weekTimeData = (() => {
        let scheduled = 0, completed = 0;
        goals.forEach(goal => {
          if (!goal.tasks) return;
          goal.tasks.forEach(task => {
            const est = task.timeEstimate || 0;
            if (!est) return;
            weekDays.forEach(day => {
              const isDaily = !task.frequency || task.frequency === 'daily';
              const isSched = task.frequency === 'scheduled' && isTaskScheduledForDate(task, day.date);
              if (!isDaily && !isSched) return;
              if (day.isFuture) return;
              const checks = task.dailyChecks || 1;
              for (let c = 0; c < checks; c++) {
                scheduled += est;
                if (dailyTasks[day.dateKey]?.[`${goal.id}-${task.id}-${c}`]) {
                  completed += est;
                }
              }
            });
          });
        });
        const remaining = Math.max(0, scheduled - completed);
        const pct = scheduled > 0 ? Math.round((completed / scheduled) * 100) : 0;
        return { scheduled, completed, remaining, pct };
      })();
      const fmtTime = (m) => { const h = Math.floor(m / 60); const mm = m % 60; return h > 0 ? `${h}h ${mm}m` : `${mm}m`; };

      // ---- Enhanced Category Data (for expanded cards) ----
      const categoryDepthData = (categories || []).map(cat => {
        const catGoals = goals.filter(g => g.category === cat.id && g.goalType !== 'points');
        if (catGoals.length === 0) return null;
        let totalAll = 0, totalDone = 0, timeScheduled = 0, timeCompleted = 0;
        let easyCount = 0, mediumCount = 0, hardCount = 0;
        const dailyBars = weekDays.map(day => {
          let dayTotal = 0, dayDone = 0;
          catGoals.forEach(goal => {
            if (!goal.tasks) return;
            goal.tasks.forEach(task => {
              const isDaily = !task.frequency || task.frequency === 'daily';
              const isSched = task.frequency === 'scheduled' && isTaskScheduledForDate(task, day.date);
              if (!isDaily && !isSched) return;
              const checks = task.dailyChecks || 1;
              const diff = task.difficulty || 'medium';
              const est = task.timeEstimate || 0;
              for (let c = 0; c < checks; c++) {
                if (!day.isFuture) {
                  dayTotal++; totalAll++;
                  timeScheduled += est;
                  if (dailyTasks[day.dateKey]?.[`${goal.id}-${task.id}-${c}`]) {
                    dayDone++; totalDone++;
                    timeCompleted += est;
                    if (diff === 'easy') easyCount++;
                    else if (diff === 'hard') hardCount++;
                    else mediumCount++;
                  }
                }
              }
            });
          });
          return dayTotal > 0 ? dayDone / dayTotal : 0;
        });
        const pct = totalAll > 0 ? Math.round(totalDone / totalAll * 100) : 0;
        const effortTotal = easyCount + mediumCount + hardCount;
        const effortMix = effortTotal > 0 ? {
          easy: Math.round((easyCount / effortTotal) * 100),
          medium: Math.round((mediumCount / effortTotal) * 100),
          hard: Math.round((hardCount / effortTotal) * 100),
        } : { easy: 0, medium: 0, hard: 0 };
        return { ...cat, pct, dailyBars, timeScheduled, timeCompleted, effortMix };
      }).filter(Boolean);

      return (
        <>
          {/* Heat map calendar card */}
          <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
            <div className="p-3 pb-2.5">
              <div className="grid grid-cols-7 gap-1.5">
                {weekDays.map((day, i) => {
                  const pct = day.progress.percentage;
                  const bgColor = day.isFuture ? (darkMode ? '#0f172a' : '#f8fafc') : getHeatColor(pct);
                  const textColor = getHeatTextColor(pct, day.isFuture);
                  const subColor = getHeatSubColor(pct);
                  return (
                    <div key={i} onClick={() => goToDay(day.date)} className="text-center cursor-pointer">
                      <div style={{ fontSize: 10, fontWeight: 600, marginBottom: 3, color: day.isToday ? '#6366f1' : (darkMode ? '#64748b' : '#94a3b8') }}>
                        {day.label}
                      </div>
                      <div style={{
                        borderRadius: 10, background: bgColor, padding: '10px 2px 8px',
                        border: day.isToday ? '2px solid #6366f1' : '2px solid transparent',
                        transition: 'all 0.3s'
                      }}>
                        <div style={{ fontSize: 14, fontWeight: 700, lineHeight: 1, color: textColor }}>
                          {day.dayNum}
                        </div>
                        {!day.isFuture && day.progress.total > 0 && (
                          <div style={{ fontSize: 9, color: subColor, fontWeight: 600, marginTop: 3 }}>
                            {day.progress.completed}/{day.progress.total}
                          </div>
                        )}
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
            {/* Summary strip */}
            <div className={`px-3.5 py-2.5 border-t ${theme.divider} flex justify-around`}>
              {[
                { value: `${weekPct}%`, label: 'complete' },
                { value: `${journalDays}/7`, label: 'journaled' },
                { value: `${photoDays}/7`, label: 'photos' },
              ].map((s, i) => (
                <div key={i} className="text-center">
                  <div className={`text-base font-bold ${theme.textPrimary}`}>{s.value}</div>
                  <div className={`text-[9px] ${theme.textMuted}`}>{s.label}</div>
                </div>
              ))}
            </div>
          </div>


          {/* Category Depth - Expanded Cards */}
          {categoryDepthData.length > 0 && (
            <div>
              <p className={`text-[11px] font-semibold uppercase tracking-wider mb-2 ml-1 ${theme.textMuted}`}>Category Depth</p>
              <div className="space-y-2.5">
                {categoryDepthData.map((cat, ci) => {
                  const timePct = cat.timeScheduled > 0 ? Math.round((cat.timeCompleted / cat.timeScheduled) * 100) : 0;
                  return (
                    <div key={ci} className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
                      <div className="h-1.5" style={{ backgroundColor: darkMode ? '#1e293b' : '#e2e8f0' }}>
                        <div className="h-full" style={{ width: `${cat.pct}%`, backgroundColor: cat.color }} />
                      </div>
                      <div className="p-3.5">
                        <div className="flex items-center justify-between mb-3">
                          <div className="flex items-center gap-2">
                            <div className="w-2.5 h-2.5 rounded-full" style={{ backgroundColor: cat.color }} />
                            <span className={`text-[13px] font-semibold ${theme.textPrimary}`}>{cat.name}</span>
                          </div>
                          <span className="text-[14px] font-bold" style={{ color: cat.color }}>{cat.pct}%</span>
                        </div>
                        <div className="grid grid-cols-2 gap-3">
                          <div className={`rounded-lg p-2.5 ${theme.inputBg}`}>
                            <div className={`text-[9px] font-semibold uppercase tracking-wider mb-1 ${theme.textMuted}`}>Time</div>
                            <div className="flex items-baseline gap-1">
                              <span className={`text-[14px] font-bold ${theme.textPrimary}`}>{fmtTime(cat.timeCompleted)}</span>
                            </div>
                            <div className={`text-[9px] ${theme.textMuted}`}>of {fmtTime(cat.timeScheduled)} scheduled</div>
                          </div>
                          <div className={`rounded-lg p-2.5 ${theme.inputBg}`}>
                            <div className={`text-[9px] font-semibold uppercase tracking-wider mb-1.5 ${theme.textMuted}`}>Effort Mix</div>
                            <div className="flex rounded-full overflow-hidden h-2 mb-1.5">
                              <div style={{ width: `${cat.effortMix.easy}%`, backgroundColor: '#86efac' }} />
                              <div style={{ width: `${cat.effortMix.medium}%`, backgroundColor: '#fde68a' }} />
                              <div style={{ width: `${cat.effortMix.hard}%`, backgroundColor: '#f87171' }} />
                            </div>
                            <div className={`text-[9px] ${theme.textMuted}`}>{cat.effortMix.hard}% hard tasks</div>
                          </div>
                        </div>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          )}

          {/* Scheduled tasks */}
          {scheduledDays.length > 0 && (
            <div>
              <p className={`text-[11px] font-semibold uppercase tracking-wider mb-2 ml-1 ${theme.textMuted}`}>Scheduled</p>
              <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
                {scheduledDays.map((day, i) => (
                  <div key={i} className={`flex items-center gap-2.5 px-3.5 py-2.5 ${i < scheduledDays.length - 1 ? `border-b ${theme.divider}` : ''}`}
                    style={{ opacity: day.isFuture ? 0.6 : 1 }}>
                    <div className={`w-8 h-8 rounded-lg flex flex-col items-center justify-center flex-shrink-0 ${day.isToday ? 'bg-indigo-50' : theme.inputBg}`}
                      style={day.isToday ? { background: darkMode ? '#312e81' : '#eef2ff' } : {}}>
                      <div style={{ fontSize: 8, fontWeight: 600, color: day.isToday ? '#6366f1' : (darkMode ? '#64748b' : '#94a3b8'), lineHeight: 1 }}>{day.label}</div>
                      <div style={{ fontSize: 12, fontWeight: 700, color: day.isToday ? '#6366f1' : (darkMode ? '#cbd5e1' : '#475569'), lineHeight: 1.2 }}>{day.dayNum}</div>
                    </div>
                    <div className="flex-1 flex flex-wrap gap-1">
                      {day.scheduledTasks.map((s, j) => (
                        <span key={j} className={`text-xs px-2.5 py-0.5 rounded-lg font-medium ${theme.inputBg} ${theme.textSecondary}`}>{s}</span>
                      ))}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Journal slider trends (bar charts) */}
          {sliderPrompts.length > 0 && (
            <div>
              <p className={`text-[11px] font-semibold uppercase tracking-wider mb-2 ml-1 ${theme.textMuted}`}>Journal Trends</p>
              <div className={`${theme.cardBg} rounded-xl shadow-sm p-3.5`}>
                {sliderPrompts.map((slider, sliderIdx) => {
                  const values = weekDays.map(d => {
                    const v = journalEntries[`${d.dateKey}-${slider.id}`];
                    return v !== undefined && v !== '' ? Number(v) : null;
                  });
                  const validValues = values.filter(v => v !== null);
                  const avg = validValues.length > 0 ? (validValues.reduce((a, b) => a + b, 0) / validValues.length).toFixed(1) : null;
                  const maxVal = slider.max || 10;

                  return (
                    <div key={slider.id} className={sliderIdx < sliderPrompts.length - 1 ? 'mb-4' : ''}>
                      <div className="flex justify-between items-center mb-1.5">
                        <span className={`text-xs font-semibold ${theme.textSecondary}`}>{slider.label}</span>
                        {avg && <span className={`text-xs font-bold ${theme.textPrimary}`}>avg {avg}</span>}
                      </div>
                      <div className="flex items-end gap-1.5" style={{ height: 44 }}>
                        {weekDays.map((day, i) => {
                          const val = values[i];
                          const h = val !== null ? (val / maxVal) * 40 : 0;
                          const pctOfMax = val !== null ? val / maxVal : 0;
                          const barColor = pctOfMax >= 0.7 ? '#86efac' : pctOfMax >= 0.5 ? '#fde68a' : pctOfMax > 0 ? '#fdba74' : (darkMode ? '#1e293b' : '#f1f5f9');
                          return (
                            <div key={i} className="flex-1 flex flex-col items-center">
                              {val !== null && <div className={`text-[9px] font-semibold mb-0.5 ${theme.textMuted}`}>{val}</div>}
                              <div style={{
                                width: '100%', height: Math.max(h, 3), borderRadius: 4,
                                background: barColor, transition: 'height 0.5s'
                              }} />
                            </div>
                          );
                        })}
                      </div>
                      <div className="flex gap-1.5 mt-1">
                        {weekDays.map((d, i) => (
                          <div key={i} className={`flex-1 text-center text-[9px] font-medium ${theme.textMuted}`}>{d.label.charAt(0)}</div>
                        ))}
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          )}

          {/* Categories with rhythm bars */}
          {categoryProgress.length > 0 && (
            <div>
              <p className={`text-[11px] font-semibold uppercase tracking-wider mb-2 ml-1 ${theme.textMuted}`}>Categories</p>
              <div className={`${theme.cardBg} rounded-xl shadow-sm py-1`}>
                {categoryProgress.map((cat) => (
                  <div key={cat.id} className="flex items-center gap-2 px-3.5 py-2">
                    <div className="w-1.5 h-1.5 rounded-full flex-shrink-0" style={{ backgroundColor: cat.color }} />
                    <span className={`text-xs font-medium flex-1 truncate ${theme.textSecondary}`}>{cat.name}</span>
                    <div className="flex gap-0.5 flex-shrink-0">
                      {cat.dailyBars.map((pct, i) => (
                        <div key={i} style={{
                          width: 8, height: 18, borderRadius: 3,
                          background: pct === 0 ? (darkMode ? '#1e293b' : '#f1f5f9') : cat.color,
                          opacity: pct === 0 ? 1 : 0.3 + pct * 0.7
                        }} />
                      ))}
                    </div>
                    <span className={`text-[11px] font-bold w-8 text-right flex-shrink-0 ${theme.textPrimary}`}>{cat.pct}%</span>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Effort Distribution */}
          {weekEffortTotal > 0 && (
            <div>
              <p className={`text-[11px] font-semibold uppercase tracking-wider mb-2 ml-1 ${theme.textMuted}`}>Effort Distribution</p>
              <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
                <div className="px-3.5 py-3">
                  <div className="flex items-center gap-2 mb-2.5">
                    <div className="flex-1 flex rounded-full overflow-hidden h-2.5">
                      {weekEffortTotal > 0 && <>
                        <div style={{ width: `${(weekEffortTotals.easy / weekEffortTotal) * 100}%`, backgroundColor: '#86efac' }} />
                        <div style={{ width: `${(weekEffortTotals.medium / weekEffortTotal) * 100}%`, backgroundColor: '#fde68a' }} />
                        <div style={{ width: `${(weekEffortTotals.hard / weekEffortTotal) * 100}%`, backgroundColor: '#f87171' }} />
                      </>}
                    </div>
                  </div>
                  <div className="flex justify-around">
                    {[
                      { label: 'Easy', count: weekEffortTotals.easy, pct: weekEffortTotal > 0 ? Math.round((weekEffortTotals.easy / weekEffortTotal) * 100) : 0, dotColor: '#22c55e' },
                      { label: 'Medium', count: weekEffortTotals.medium, pct: weekEffortTotal > 0 ? Math.round((weekEffortTotals.medium / weekEffortTotal) * 100) : 0, dotColor: '#eab308' },
                      { label: 'Hard', count: weekEffortTotals.hard, pct: weekEffortTotal > 0 ? Math.round((weekEffortTotals.hard / weekEffortTotal) * 100) : 0, dotColor: '#ef4444' },
                    ].map((e, i) => (
                      <div key={i} className="text-center">
                        <div className="flex items-center justify-center gap-1">
                          <div className="w-2 h-2 rounded-full" style={{ backgroundColor: e.dotColor }} />
                          <span className={`text-[13px] font-bold ${theme.textPrimary}`}>{e.count}</span>
                        </div>
                        <div className={`text-[9px] ${theme.textMuted}`}>{e.label} ({e.pct}%)</div>
                      </div>
                    ))}
                  </div>
                </div>
                {/* Daily stacked bars */}
                <div className={`px-3.5 pb-3.5 border-t ${theme.divider} pt-3`}>
                  <div className="flex items-end gap-1.5" style={{ height: 56 }}>
                    {weeklyEffortData.map((day, i) => {
                      const maxTotal = Math.max(...weeklyEffortData.map(d => d.total), 1);
                      const scale = 44 / maxTotal;
                      return (
                        <div key={i} className="flex-1 flex flex-col items-center">
                          <span className={`text-[9px] font-semibold mb-0.5 ${theme.textMuted}`}>{day.total || ''}</span>
                          <div className="w-full flex flex-col-reverse rounded-md overflow-hidden" style={{ height: day.total * scale || 2 }}>
                            <div style={{ height: day.easy * scale, backgroundColor: '#86efac' }} />
                            <div style={{ height: day.medium * scale, backgroundColor: '#fde68a' }} />
                            <div style={{ height: day.hard * scale, backgroundColor: '#f87171' }} />
                          </div>
                        </div>
                      );
                    })}
                  </div>
                  <div className="flex gap-1.5 mt-1">
                    {weekDays.map((d, i) => (
                      <div key={i} className={`flex-1 text-center text-[9px] font-medium ${theme.textMuted}`}>{d.label.charAt(0)}</div>
                    ))}
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* Weekly Time Budget */}
          {weekTimeData.scheduled > 0 && (
            <div>
              <p className={`text-[11px] font-semibold uppercase tracking-wider mb-2 ml-1 ${theme.textMuted}`}>Weekly Time Budget</p>
              <div className={`${theme.cardBg} rounded-xl shadow-sm p-3.5`}>
                <div className="flex items-center gap-4">
                  <div className="relative w-20 h-20 flex-shrink-0">
                    <svg viewBox="0 0 80 80" className="w-full h-full" style={{ transform: 'rotate(-90deg)' }}>
                      <circle cx="40" cy="40" r="32" fill="none" stroke={darkMode ? '#1e293b' : '#e2e8f0'} strokeWidth="8" />
                      <circle cx="40" cy="40" r="32" fill="none" stroke="#3b82f6" strokeWidth="8"
                        strokeDasharray={`${weekTimeData.pct * 2.01} ${201 - weekTimeData.pct * 2.01}`}
                        strokeLinecap="round" />
                    </svg>
                    <div className="absolute inset-0 flex flex-col items-center justify-center">
                      <span className={`text-lg font-bold ${theme.textPrimary}`}>{weekTimeData.pct}%</span>
                    </div>
                  </div>
                  <div className="flex-1 space-y-1.5">
                    <div>
                      <div className="flex items-center justify-between">
                        <span className={`text-[10px] font-medium ${theme.textMuted}`}>Scheduled</span>
                        <span className={`text-[11px] font-bold ${theme.textPrimary}`}>{fmtTime(weekTimeData.scheduled)}</span>
                      </div>
                      <div className={`h-1 rounded-full mt-0.5 ${theme.progressBg}`}>
                        <div className={`h-full rounded-full ${darkMode ? 'bg-slate-500' : 'bg-slate-400'}`} style={{ width: '100%' }} />
                      </div>
                    </div>
                    <div>
                      <div className="flex items-center justify-between">
                        <span className={`text-[10px] font-medium ${theme.textMuted}`}>Completed</span>
                        <span className="text-[11px] font-bold text-blue-500">{fmtTime(weekTimeData.completed)}</span>
                      </div>
                      <div className={`h-1 rounded-full mt-0.5 ${theme.progressBg}`}>
                        <div className="h-full rounded-full bg-blue-500" style={{ width: `${weekTimeData.pct}%` }} />
                      </div>
                    </div>
                    <div>
                      <div className="flex items-center justify-between">
                        <span className={`text-[10px] font-medium ${theme.textMuted}`}>Remaining</span>
                        <span className="text-[11px] font-bold text-orange-500">{fmtTime(weekTimeData.remaining)}</span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}

        </>
      );
    };

    // ==== MONTHLY VIEW ====
    const MonthlyCalendar = () => {
      const year = calendarDate.getFullYear();
      const month = calendarDate.getMonth();
      const monthKey = `${year}-${String(month + 1).padStart(2, '0')}`;
      const firstDay = new Date(year, month, 1);
      const lastDay = new Date(year, month + 1, 0);
      const daysInMonth = lastDay.getDate();
      const startingDayOfWeek = firstDay.getDay();
      
      // Previous month for comparison
      const prevMonthDate = new Date(year, month - 1, 1);
      const prevMonthKey = `${prevMonthDate.getFullYear()}-${String(prevMonthDate.getMonth() + 1).padStart(2, '0')}`;
      const prevMonthName = prevMonthDate.toLocaleDateString('en-US', { month: 'long' });
      
      // Local state for intention editing
      const [isEditingIntention, setIsEditingIntention] = useState(false);
      const [intentionDraft, setIntentionDraft] = useState(monthlyIntentions[monthKey] || '');
      
      // Build calendar cells
      const cells = [];
      for (let i = 0; i < startingDayOfWeek; i++) cells.push(null);
      for (let day = 1; day <= daysInMonth; day++) cells.push(day);
      
      // Calculate days passed (for current month, it's today; for past months, it's all days)
      const today = new Date();
      const isCurrentMonth = year === today.getFullYear() && month === today.getMonth();
      const daysPassed = isCurrentMonth ? today.getDate() : daysInMonth;
      
      // Build day data with stats
      const dayData = [];
      let totalCompleted = 0, totalExpected = 0, daysWithActivity = 0, daysJournaled = 0;
      let bestDay = { day: 1, pct: 0 }, perfectDays = 0, currentStreak = 0, longestStreak = 0, tempStreak = 0;
      const distribution = { high: 0, medium: 0, low: 0, zero: 0 };
      
      for (let day = 1; day <= daysInMonth; day++) {
        const date = new Date(year, month, day);
        const dateKey = toLocalDateKey(date);
        const isFuture = dateKey > todayKey;
        const progress = calculateDailyProgress(dateKey);
        const hasJournal = journalConfig.prompts.some(p => { 
          const v = journalEntries[`${dateKey}-${p.id}`]; 
          return v && (typeof v === 'string' ? v.trim().length > 0 : true); 
        });
        
        dayData.push({ day, dateKey, progress, isFuture, isToday: dateKey === todayKey, hasJournal });
        
        if (!isFuture) {
          totalCompleted += progress.completed;
          totalExpected += progress.total;
          if (progress.completed > 0) daysWithActivity++;
          if (hasJournal) daysJournaled++;
          
          const pct = progress.percentage;
          if (pct > bestDay.pct) bestDay = { day, pct };
          if (pct === 100) perfectDays++;
          
          // Distribution
          if (pct >= 80) distribution.high++;
          else if (pct >= 50) distribution.medium++;
          else if (pct > 0) distribution.low++;
          else distribution.zero++;
          
          // Streak calculation
          if (pct > 0) {
            tempStreak++;
            if (tempStreak > longestStreak) longestStreak = tempStreak;
          } else {
            tempStreak = 0;
          }
        }
      }
      
      // Current streak (counting back from today/end of month)
      for (let day = daysPassed; day >= 1; day--) {
        const dateKey = toLocalDateKey(new Date(year, month, day));
        const progress = calculateDailyProgress(dateKey);
        if (progress.percentage > 0) currentStreak++;
        else break;
      }
      
      const overallPct = totalExpected > 0 ? Math.round((totalCompleted / totalExpected) * 100) : 0;
      const consistencyScore = daysPassed > 0 ? Math.round((daysWithActivity / daysPassed) * 100) : 0;
      
      // Previous month stats for comparison
      const prevMonthLastDay = new Date(prevMonthDate.getFullYear(), prevMonthDate.getMonth() + 1, 0).getDate();
      let prevCompleted = 0, prevExpected = 0, prevDaysWithActivity = 0;
      for (let day = 1; day <= prevMonthLastDay; day++) {
        const dateKey = toLocalDateKey(new Date(prevMonthDate.getFullYear(), prevMonthDate.getMonth(), day));
        const progress = calculateDailyProgress(dateKey);
        prevCompleted += progress.completed;
        prevExpected += progress.total;
        if (progress.completed > 0) prevDaysWithActivity++;
      }
      const prevOverallPct = prevExpected > 0 ? Math.round((prevCompleted / prevExpected) * 100) : 0;
      const prevConsistency = prevMonthLastDay > 0 ? Math.round((prevDaysWithActivity / prevMonthLastDay) * 100) : 0;
      const pctChange = overallPct - prevOverallPct;
      const consistencyChange = consistencyScore - prevConsistency;
      
      // Build weeks data
      const weeksData = [];
      let weekStart = new Date(year, month, 1);
      // Adjust to Sunday start
      weekStart.setDate(weekStart.getDate() - weekStart.getDay());
      
      // Iterate max 6 weeks (any month fits in 6 weeks)
      for (let weekNum = 0; weekNum < 6; weekNum++) {
        const weekEnd = new Date(weekStart);
        weekEnd.setDate(weekStart.getDate() + 6);
        
        // Check if this week has any days in the target month
        const weekHasDaysInMonth = (weekStart.getMonth() === month && weekStart.getFullYear() === year) ||
                                    (weekEnd.getMonth() === month && weekEnd.getFullYear() === year);
        
        if (!weekHasDaysInMonth) {
          weekStart.setDate(weekStart.getDate() + 7);
          continue;
        }
        
        // Stop if we've passed the month entirely
        if (weekStart.getMonth() > month && weekStart.getFullYear() === year) break;
        if (weekStart.getFullYear() > year) break;
        
        let weekCompleted = 0, weekExpected = 0;
        const weekIsFuture = toLocalDateKey(weekStart) > todayKey;
        
        for (let i = 0; i < 7; i++) {
          const d = new Date(weekStart);
          d.setDate(weekStart.getDate() + i);
          if (d.getMonth() !== month || d.getFullYear() !== year) continue;
          const dateKey = toLocalDateKey(d);
          if (dateKey > todayKey) continue;
          const progress = calculateDailyProgress(dateKey);
          weekCompleted += progress.completed;
          weekExpected += progress.total;
        }
        
        const weekPct = weekExpected > 0 ? Math.round((weekCompleted / weekExpected) * 100) : 0;
        const startLabel = `${weekStart.toLocaleDateString('en-US', { month: 'short' })} ${weekStart.getDate()}`;
        const endLabel = `${weekEnd.toLocaleDateString('en-US', { month: 'short' })} ${weekEnd.getDate()}`;
        
        weeksData.push({ startLabel, endLabel, percentage: weekPct, completed: weekCompleted, total: weekExpected, isFuture: weekIsFuture });
        weekStart.setDate(weekStart.getDate() + 7);
      }
      
      const bestWeekPct = Math.max(...weeksData.filter(w => !w.isFuture).map(w => w.percentage), 0);
      
      // Journal slider trends (weekly averages)
      const sliderPrompts = journalConfig.prompts.filter(p => p.type === 'slider');
      const journalTrends = sliderPrompts.map(prompt => {
        const weeklyAvgs = weeksData.map((week, wi) => {
          if (week.isFuture) return null;
          let sum = 0, count = 0;
          const ws = new Date(year, month, 1);
          ws.setDate(ws.getDate() - ws.getDay() + wi * 7);
          for (let i = 0; i < 7; i++) {
            const d = new Date(ws);
            d.setDate(ws.getDate() + i);
            if (d.getMonth() !== month) continue;
            const dateKey = toLocalDateKey(d);
            if (dateKey > todayKey) continue;
            const val = journalEntries[`${dateKey}-${prompt.id}`];
            if (val !== undefined && val !== null && val !== '') {
              sum += Number(val);
              count++;
            }
          }
          return count > 0 ? Math.round((sum / count) * 10) / 10 : null;
        });
        return { label: prompt.label, weeklyAvgs, max: prompt.max || 10 };
      });
      
      // Category progress (weekly)
      const categoryProgress = categories.map(cat => {
        const catGoals = goals.filter(g => g.category === cat.id);
        if (catGoals.length === 0) return null;
        
        const weeklyPcts = weeksData.map((week, wi) => {
          if (week.isFuture) return 0;
          let completed = 0, expected = 0;
          const ws = new Date(year, month, 1);
          ws.setDate(ws.getDate() - ws.getDay() + wi * 7);
          
          catGoals.forEach(goal => {
            if (!goal.tasks) return;
            goal.tasks.forEach(task => {
              for (let i = 0; i < 7; i++) {
                const d = new Date(ws);
                d.setDate(ws.getDate() + i);
                if (d.getMonth() !== month) continue;
                const dateKey = toLocalDateKey(d);
                if (dateKey > todayKey) continue;
                
                if (!task.frequency || task.frequency === 'daily') {
                  const checks = task.dailyChecks || 1;
                  expected += checks;
                  for (let c = 0; c < checks; c++) {
                    if (dailyTasks[dateKey]?.[`${goal.id}-${task.id}-${c}`]) completed++;
                  }
                } else if (task.frequency === 'scheduled' && isTaskScheduledForDate(task, d)) {
                  expected++;
                  if (dailyTasks[dateKey]?.[`${goal.id}-${task.id}-0`]) completed++;
                }
              }
            });
          });
          
          return expected > 0 ? Math.round((completed / expected) * 100) : 0;
        });
        
        const avgPct = weeklyPcts.filter(p => p > 0).length > 0
          ? Math.round(weeklyPcts.filter(p => p > 0).reduce((a, b) => a + b, 0) / weeklyPcts.filter(p => p > 0).length)
          : 0;
        
        return { ...cat, weeklyPcts, avgPct };
      }).filter(Boolean);
      
      // Find worst performing goal (needs attention)
      const goalPerformance = goals.map(goal => {
        if (!goal.tasks || goal.tasks.length === 0) return null;
        let completed = 0, expected = 0;
        
        for (let day = 1; day <= daysPassed; day++) {
          const dateKey = toLocalDateKey(new Date(year, month, day));
          goal.tasks.forEach(task => {
            if (!task.frequency || task.frequency === 'daily') {
              const checks = task.dailyChecks || 1;
              expected += checks;
              for (let c = 0; c < checks; c++) {
                if (dailyTasks[dateKey]?.[`${goal.id}-${task.id}-${c}`]) completed++;
              }
            } else if (task.frequency === 'scheduled') {
              const d = new Date(year, month, day);
              if (isTaskScheduledForDate(task, d)) {
                expected++;
                if (dailyTasks[dateKey]?.[`${goal.id}-${task.id}-0`]) completed++;
              }
            }
          });
        }
        
        const pct = expected > 0 ? Math.round((completed / expected) * 100) : 100;
        const cat = categories.find(c => c.id === goal.category);
        return { ...goal, pct, categoryName: cat?.name || 'Uncategorized', categoryColor: cat?.color || '#64748b' };
      }).filter(Boolean);
      
      const worstGoal = goalPerformance.length > 0 
        ? goalPerformance.reduce((min, g) => g.pct < min.pct ? g : min, goalPerformance[0])
        : null;
      
      // Save intention
      const saveIntention = () => {
        setMonthlyIntentions(prev => ({ ...prev, [monthKey]: intentionDraft }));
        setIsEditingIntention(false);
      };


      // ---- Monthly Effort Distribution ----
      const monthlyEffortCounts = (() => {
        let easy = 0, medium = 0, hard = 0;
        const weeklyBreakdown = weeksData.map((week, wi) => {
          let wEasy = 0, wMedium = 0, wHard = 0;
          const ws = new Date(year, month, 1);
          ws.setDate(ws.getDate() - ws.getDay() + wi * 7);
          for (let i = 0; i < 7; i++) {
            const d = new Date(ws);
            d.setDate(ws.getDate() + i);
            if (d.getMonth() !== month || d.getFullYear() !== year) continue;
            const dateKey = toLocalDateKey(d);
            if (dateKey > todayKey) continue;
            goals.forEach(goal => {
              if (!goal.tasks) return;
              goal.tasks.forEach(task => {
                const diff = task.difficulty || 'medium';
                const isDaily = !task.frequency || task.frequency === 'daily';
                const isSched = task.frequency === 'scheduled' && isTaskScheduledForDate(task, d);
                if (!isDaily && !isSched) return;
                const checks = task.dailyChecks || 1;
                for (let c = 0; c < checks; c++) {
                  if (dailyTasks[dateKey]?.[`${goal.id}-${task.id}-${c}`]) {
                    if (diff === 'easy') { wEasy++; easy++; }
                    else if (diff === 'hard') { wHard++; hard++; }
                    else { wMedium++; medium++; }
                  }
                }
              });
            });
          }
          return { easy: wEasy, medium: wMedium, hard: wHard, total: wEasy + wMedium + wHard };
        });
        return { easy, medium, hard, total: easy + medium + hard, weeklyBreakdown };
      })();

      // ---- Monthly Time by Goal ----
      const monthlyGoalTime = goals.filter(g => g.goalType !== 'points').map(goal => {
        if (!goal.tasks || goal.tasks.length === 0) return null;
        let scheduled = 0, completed = 0;
        const cat = (categories || []).find(c => c.id === goal.category);
        for (let day = 1; day <= daysPassed; day++) {
          const d = new Date(year, month, day);
          const dateKey = toLocalDateKey(d);
          goal.tasks.forEach(task => {
            const est = task.timeEstimate || 0;
            if (!est) return;
            const isDaily = !task.frequency || task.frequency === 'daily';
            const isSched = task.frequency === 'scheduled' && isTaskScheduledForDate(task, d);
            if (!isDaily && !isSched) return;
            const checks = task.dailyChecks || 1;
            for (let c = 0; c < checks; c++) {
              scheduled += est;
              if (dailyTasks[dateKey]?.[`${goal.id}-${task.id}-${c}`]) completed += est;
            }
          });
        }
        if (scheduled === 0) return null;
        return { id: goal.id, name: goal.title, color: cat?.color || '#64748b', scheduled, completed };
      }).filter(Boolean).sort((a, b) => b.scheduled - a.scheduled);
      const monthTotalScheduled = monthlyGoalTime.reduce((s, g) => s + g.scheduled, 0);
      const monthTotalCompleted = monthlyGoalTime.reduce((s, g) => s + g.completed, 0);
      const fmtTime = (m) => { const h = Math.floor(m / 60); const mm = m % 60; return h > 0 ? `${h}h ${mm > 0 ? mm + 'm' : ''}` : `${mm}m`; };

      // ---- Monthly Category Depth (Comparative Matrix) ----
      const monthlyCategoryDepth = (categories || []).map(cat => {
        const catGoals = goals.filter(g => g.category === cat.id && g.goalType !== 'points');
        if (catGoals.length === 0) return null;
        let totalDone = 0, totalAll = 0, timeSched = 0, timeComp = 0;
        let easyC = 0, medC = 0, hardC = 0;
        const weeklyPcts = weeksData.map((week, wi) => {
          if (week.isFuture) return 0;
          let wDone = 0, wAll = 0;
          const ws = new Date(year, month, 1);
          ws.setDate(ws.getDate() - ws.getDay() + wi * 7);
          catGoals.forEach(goal => {
            if (!goal.tasks) return;
            goal.tasks.forEach(task => {
              const diff = task.difficulty || 'medium';
              const est = task.timeEstimate || 0;
              for (let i = 0; i < 7; i++) {
                const d = new Date(ws);
                d.setDate(ws.getDate() + i);
                if (d.getMonth() !== month) continue;
                const dateKey = toLocalDateKey(d);
                if (dateKey > todayKey) continue;
                const isDaily = !task.frequency || task.frequency === 'daily';
                const isSched = task.frequency === 'scheduled' && isTaskScheduledForDate(task, d);
                if (!isDaily && !isSched) return;
                const checks = task.dailyChecks || 1;
                for (let c = 0; c < checks; c++) {
                  wAll++; totalAll++; timeSched += est;
                  if (dailyTasks[dateKey]?.[`${goal.id}-${task.id}-${c}`]) {
                    wDone++; totalDone++; timeComp += est;
                    if (diff === 'easy') easyC++;
                    else if (diff === 'hard') hardC++;
                    else medC++;
                  }
                }
              }
            });
          });
          return wAll > 0 ? Math.round((wDone / wAll) * 100) : 0;
        });
        const pct = totalAll > 0 ? Math.round((totalDone / totalAll) * 100) : 0;
        const effortTotal = easyC + medC + hardC;
        const effortMix = effortTotal > 0 ? {
          easy: Math.round((easyC / effortTotal) * 100),
          medium: Math.round((medC / effortTotal) * 100),
          hard: Math.round((hardC / effortTotal) * 100),
        } : { easy: 0, medium: 0, hard: 0 };
        return { ...cat, pct, weeklyPcts, timeScheduled: timeSched, timeCompleted: timeComp, effortMix };
      }).filter(Boolean);
      return (
        <div className="space-y-3">
          {/* Monthly Intention */}
          <div className={`${theme.cardBg} rounded-xl shadow-sm p-3.5`}>
            <div className="flex items-center justify-between mb-2">
              <div className="flex items-center gap-1.5">
                <span className="text-sm"></span>
                <span className={`text-[11px] font-bold uppercase tracking-wider ${theme.textMuted}`}>Monthly Intention</span>
              </div>
              <button 
                onClick={() => {
                  if (isEditingIntention) saveIntention();
                  else {
                    setIntentionDraft(monthlyIntentions[monthKey] || '');
                    setIsEditingIntention(true);
                  }
                }}
                className="text-[10px] font-semibold text-indigo-500"
              >
                {isEditingIntention ? 'Save' : 'Edit'}
              </button>
            </div>
            {isEditingIntention ? (
              <textarea
                value={intentionDraft}
                onChange={(e) => setIntentionDraft(e.target.value)}
                placeholder="What's your focus this month?"
                className={`w-full rounded-lg px-3 py-2 text-sm resize-none ${theme.inputBg} ${theme.textPrimary}`}
                rows={2}
                autoFocus
              />
            ) : (
              <p className={`text-[13px] leading-relaxed ${monthlyIntentions[monthKey] ? theme.textSecondary : theme.textMuted}`}>
                {monthlyIntentions[monthKey] || <span className="italic">Tap edit to set your monthly intention...</span>}
              </p>
            )}
          </div>

          {/* Calendar + Summary */}
          <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
            {/* Calendar Grid */}
            <div className="p-3">
              <div className="grid grid-cols-7 gap-1 mb-2">
                {['S', 'M', 'T', 'W', 'T', 'F', 'S'].map((d, i) => (
                  <div key={i} className={`text-center text-[10px] font-semibold py-1 ${theme.textMuted}`}>{d}</div>
                ))}
              </div>
              <div className="grid grid-cols-7 gap-1">
                {cells.map((day, index) => {
                  if (!day) return <div key={`empty-${index}`} className="aspect-square" />;
                  const dd = dayData[day - 1];
                  const pct = dd.progress.percentage;
                  const bgColor = dd.isFuture ? (darkMode ? '#0f172a' : '#f8fafc') : getHeatColor(pct);
                  const textColor = getHeatTextColor(pct, dd.isFuture);
                  return (
                    <button key={day} onClick={() => goToDay(new Date(year, month, day))}
                      className="aspect-square flex items-center justify-center transition-all"
                      style={{ borderRadius: 8, background: bgColor, border: dd.isToday ? '2px solid #6366f1' : '2px solid transparent' }}>
                      <span style={{ fontSize: 12, fontWeight: 600, color: textColor }}>{day}</span>
                    </button>
                  );
                })}
              </div>
            </div>
            
            {/* Summary Strip */}
            <div className={`px-3.5 py-2.5 border-t ${theme.divider}`}>
              <div className={`text-[11px] font-bold uppercase tracking-wider text-center mb-2.5 ${theme.textSecondary}`}>
                vs {prevMonthName}
              </div>
              <div className="flex justify-around">
                {[
                  { value: `${overallPct}%`, label: 'complete', change: pctChange },
                  { value: `${consistencyScore}%`, label: 'consistency', change: consistencyChange },
                  { value: `${daysJournaled}/${daysPassed}`, label: 'journaled' },
                  { value: `${currentStreak}d`, label: 'streak' },
                ].map((s, i) => (
                  <div key={i} className="text-center">
                    <div className="flex items-center justify-center gap-1">
                      <span className={`text-[15px] font-bold ${theme.textPrimary}`}>{s.value}</span>
                      {s.change !== undefined && (
                        <span className={`text-[9px] font-bold px-1 py-0.5 rounded ${
                          s.change >= 0 ? 'text-emerald-600 bg-emerald-100' : 'text-red-600 bg-red-100'
                        } ${darkMode && (s.change >= 0 ? 'bg-emerald-900/50 text-emerald-400' : 'bg-red-900/50 text-red-400')}`}>
                          {s.change >= 0 ? '+' : ''}{s.change}%
                        </span>
                      )}
                    </div>
                    <div className={`text-[9px] ${theme.textMuted}`}>{s.label}</div>
                  </div>
                ))}
              </div>
            </div>
          </div>

          {/* Day Distribution */}
          <div>
            <p className={`text-[11px] font-bold uppercase tracking-wider mb-2 pl-1 ${theme.textMuted}`}>Day Distribution</p>
            <div className={`${theme.cardBg} rounded-xl shadow-sm p-3.5`}>
              <div className="flex items-end gap-2 h-20 mb-2">
                {[
                  { label: '80-100%', count: distribution.high, color: '#22c55e' },
                  { label: '50-79%', count: distribution.medium, color: '#facc15' },
                  { label: '1-49%', count: distribution.low, color: '#fb923c' },
                  { label: '0%', count: distribution.zero, color: darkMode ? '#334155' : '#e2e8f0' },
                ].map((bucket, i) => {
                  const maxCount = Math.max(distribution.high, distribution.medium, distribution.low, distribution.zero, 1);
                  const height = (bucket.count / maxCount) * 60;
                  return (
                    <div key={i} className="flex-1 flex flex-col items-center">
                      <span className={`text-[11px] font-bold mb-1 ${theme.textPrimary}`}>{bucket.count}</span>
                      <div className="w-full rounded-md" style={{ height: Math.max(height, 4), background: bucket.color }} />
                    </div>
                  );
                })}
              </div>
              <div className="flex gap-2">
                {['80-100%', '50-79%', '1-49%', '0%'].map((label, i) => (
                  <div key={i} className={`flex-1 text-center text-[9px] font-medium ${theme.textMuted}`}>{label}</div>
                ))}
              </div>
              <div className={`text-center mt-2.5 text-[10px] ${theme.textSecondary}`}>
                <span className="font-semibold">{distribution.high}</span> great days, <span className="font-semibold">{distribution.medium}</span> good days
              </div>
            </div>
          </div>

          {/* Weeks */}
          <div>
            <p className={`text-[11px] font-bold uppercase tracking-wider mb-2 pl-1 ${theme.textMuted}`}>Weeks</p>
            <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
              {weeksData.map((week, i) => {
                const barColor = week.isFuture ? (darkMode ? '#334155' : '#e2e8f0') : getHeatColor(week.percentage);
                const isBest = !week.isFuture && week.percentage === bestWeekPct && week.percentage > 0;
                return (
                  <div key={i} className={`px-3.5 py-3 ${i < weeksData.length - 1 ? `border-b ${theme.divider}` : ''} ${week.isFuture ? 'opacity-50' : ''}`}>
                    <div className="flex items-center justify-between mb-1.5">
                      <div className="flex items-center gap-2">
                        <span className={`text-[13px] font-semibold ${theme.textPrimary}`}>{week.startLabel}  {week.endLabel}</span>
                        {isBest && <span className="text-[9px] font-semibold text-emerald-600 bg-emerald-100 px-1.5 py-0.5 rounded">BEST</span>}
                      </div>
                      <span className={`text-[13px] font-bold ${week.isFuture ? theme.textMuted : theme.textPrimary}`}>{week.percentage}%</span>
                    </div>
                    <div className={`h-1.5 rounded-full ${theme.progressBg}`}>
                      <div className="h-full rounded-full transition-all" style={{ width: `${week.percentage}%`, background: barColor }} />
                    </div>
                    {!week.isFuture && week.total > 0 && (
                      <p className={`text-[10px] mt-1 ${theme.textMuted}`}>{week.completed} of {week.total} tasks</p>
                    )}
                  </div>
                );
              })}
            </div>
          </div>

          {/* Highlights */}
          <div>
            <p className={`text-[11px] font-bold uppercase tracking-wider mb-2 pl-1 ${theme.textMuted}`}>Highlights</p>
            <div className={`${theme.cardBg} rounded-xl shadow-sm p-3.5`}>
              <div className="grid grid-cols-2 gap-2.5">
                {[
                  { icon: '', value: bestDay.pct > 0 ? `${calendarDate.toLocaleDateString('en-US', { month: 'short' })} ${bestDay.day}` : '-', label: `Best day (${bestDay.pct}%)` },
                  { icon: '', value: perfectDays, label: 'Perfect days' },
                  { icon: '', value: `${longestStreak}d`, label: 'Longest streak' },
                  { icon: '', value: totalCompleted, label: 'Tasks done' },
                ].map((h, i) => (
                  <div key={i} className={`flex items-center gap-2.5 p-2.5 rounded-lg ${theme.inputBg}`}>
                    <span className="text-base">{h.icon}</span>
                    <div>
                      <div className={`text-sm font-bold ${theme.textPrimary}`}>{h.value}</div>
                      <div className={`text-[9px] ${theme.textMuted}`}>{h.label}</div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </div>

          {/* Journal Trends */}
          {journalTrends.length > 0 && (
            <div>
              <p className={`text-[11px] font-bold uppercase tracking-wider mb-2 pl-1 ${theme.textMuted}`}>Journal Trends</p>
              <div className={`${theme.cardBg} rounded-xl shadow-sm p-3.5`}>
                {journalTrends.map((trend, ti) => {
                  const validAvgs = trend.weeklyAvgs.filter(v => v !== null);
                  const overallAvg = validAvgs.length > 0 ? (validAvgs.reduce((a, b) => a + b, 0) / validAvgs.length).toFixed(1) : null;
                  return (
                    <div key={ti} className={ti < journalTrends.length - 1 ? 'mb-4' : ''}>
                      <div className="flex justify-between items-center mb-1.5">
                        <span className={`text-xs font-semibold ${theme.textSecondary}`}>{trend.label}</span>
                        {overallAvg && <span className={`text-[11px] font-bold ${theme.textPrimary}`}>avg {overallAvg}</span>}
                      </div>
                      <div className="flex items-end gap-2 h-12">
                        {trend.weeklyAvgs.map((avg, i) => {
                          const h = avg !== null ? (avg / trend.max) * 44 : 0;
                          const pctOfMax = avg !== null ? avg / trend.max : 0;
                          const barColor = pctOfMax >= 0.7 ? '#86efac' : pctOfMax >= 0.5 ? '#fde68a' : pctOfMax > 0 ? '#fdba74' : (darkMode ? '#1e293b' : '#f1f5f9');
                          return (
                            <div key={i} className="flex-1 flex flex-col items-center">
                              {avg !== null && <span className={`text-[9px] font-semibold mb-0.5 ${theme.textMuted}`}>{avg}</span>}
                              <div className="w-full rounded" style={{ height: Math.max(h, 4), background: barColor }} />
                            </div>
                          );
                        })}
                      </div>
                      <div className="flex gap-2 mt-1">
                        {weeksData.map((_, i) => (
                          <div key={i} className={`flex-1 text-center text-[9px] font-medium ${theme.textMuted}`}>Wk {i + 1}</div>
                        ))}
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          )}

          {/* Categories */}
          {categoryProgress.length > 0 && (
            <div>
              <p className={`text-[11px] font-bold uppercase tracking-wider mb-2 pl-1 ${theme.textMuted}`}>Categories</p>
              <div className={`${theme.cardBg} rounded-xl shadow-sm py-1.5`}>
                {categoryProgress.map((cat) => (
                  <div key={cat.id} className="flex items-center gap-2.5 px-3.5 py-2.5">
                    <div className="w-1.5 h-1.5 rounded-full flex-shrink-0" style={{ background: cat.color }} />
                    <span className={`text-xs font-medium flex-1 ${theme.textSecondary}`}>{cat.name}</span>
                    <div className="flex gap-1 flex-shrink-0">
                      {cat.weeklyPcts.map((pct, i) => (
                        <div key={i} className="w-3.5 h-6 rounded" style={{
                          background: pct === 0 ? (darkMode ? '#0f172a' : '#f1f5f9') : cat.color,
                          opacity: pct === 0 ? 1 : 0.3 + (pct / 100) * 0.7
                        }} />
                      ))}
                    </div>
                    <span className={`text-[11px] font-bold w-8 text-right ${theme.textPrimary}`}>{cat.avgPct}%</span>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Goal Needing Attention */}
          {worstGoal && worstGoal.pct < 60 && (
            <div className="rounded-xl p-3.5" style={{ 
              background: `linear-gradient(135deg, ${worstGoal.categoryColor}15, ${worstGoal.categoryColor}05)`,
              border: `1px solid ${worstGoal.categoryColor}30`
            }}>
              <div className="flex items-center gap-2 mb-2">
                <span className="text-sm"></span>
                <span className={`text-[11px] font-bold uppercase tracking-wider ${theme.textMuted}`}>Needs Attention</span>
              </div>
              <div className="flex items-center justify-between">
                <div>
                  <div className={`text-sm font-semibold ${theme.textPrimary}`}>{worstGoal.title}</div>
                  <div className={`text-[11px] ${theme.textMuted}`}>{worstGoal.categoryName}</div>
                </div>
                <div className="text-right">
                  <div className="text-xl font-extrabold" style={{ color: worstGoal.categoryColor }}>{worstGoal.pct}%</div>
                  <div className={`text-[9px] ${theme.textMuted}`}>this month</div>
                </div>
              </div>
              <div className="mt-2.5 h-1.5 rounded-full" style={{ background: `${worstGoal.categoryColor}20` }}>
                <div className="h-full rounded-full" style={{ width: `${worstGoal.pct}%`, background: worstGoal.categoryColor }} />
              </div>
            </div>
          )}


          {/* Effort Distribution */}
          {monthlyEffortCounts.total > 0 && (
            <div>
              <p className={`text-[11px] font-bold uppercase tracking-wider mb-2 pl-1 ${theme.textMuted}`}>Effort Distribution</p>
              <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
                <div className="px-3.5 py-3">
                  <div className="flex items-center gap-2 mb-3">
                    <div className="flex-1 flex rounded-full overflow-hidden h-3">
                      <div style={{ width: `${(monthlyEffortCounts.easy / monthlyEffortCounts.total) * 100}%`, backgroundColor: '#86efac' }} />
                      <div style={{ width: `${(monthlyEffortCounts.medium / monthlyEffortCounts.total) * 100}%`, backgroundColor: '#fde68a' }} />
                      <div style={{ width: `${(monthlyEffortCounts.hard / monthlyEffortCounts.total) * 100}%`, backgroundColor: '#f87171' }} />
                    </div>
                  </div>
                  <div className="flex justify-around">
                    {[
                      { label: 'Easy', count: monthlyEffortCounts.easy, pct: Math.round((monthlyEffortCounts.easy / monthlyEffortCounts.total) * 100), dotColor: '#22c55e' },
                      { label: 'Medium', count: monthlyEffortCounts.medium, pct: Math.round((monthlyEffortCounts.medium / monthlyEffortCounts.total) * 100), dotColor: '#eab308' },
                      { label: 'Hard', count: monthlyEffortCounts.hard, pct: Math.round((monthlyEffortCounts.hard / monthlyEffortCounts.total) * 100), dotColor: '#ef4444' },
                    ].map((e, i) => (
                      <div key={i} className="text-center">
                        <div className="flex items-center justify-center gap-1">
                          <div className="w-2 h-2 rounded-full" style={{ backgroundColor: e.dotColor }} />
                          <span className={`text-[13px] font-bold ${theme.textPrimary}`}>{e.count}</span>
                        </div>
                        <div className={`text-[9px] ${theme.textMuted}`}>{e.label} ({e.pct}%)</div>
                      </div>
                    ))}
                  </div>
                </div>
                {/* Weekly stacked bars */}
                <div className={`px-3.5 pb-3.5 border-t ${theme.divider} pt-3`}>
                  <div className="flex items-end gap-3" style={{ height: 70 }}>
                    {monthlyEffortCounts.weeklyBreakdown.map((week, i) => {
                      const maxTotal = Math.max(...monthlyEffortCounts.weeklyBreakdown.map(w => w.total), 1);
                      const scale = 56 / maxTotal;
                      return (
                        <div key={i} className="flex-1 flex flex-col items-center">
                          <span className={`text-[9px] font-semibold mb-0.5 ${theme.textMuted}`}>{week.total || ''}</span>
                          <div className="w-full flex flex-col-reverse rounded-md overflow-hidden" style={{ height: week.total * scale || 2 }}>
                            <div style={{ height: week.easy * scale, backgroundColor: '#86efac' }} />
                            <div style={{ height: week.medium * scale, backgroundColor: '#fde68a' }} />
                            <div style={{ height: week.hard * scale, backgroundColor: '#f87171' }} />
                          </div>
                        </div>
                      );
                    })}
                  </div>
                  <div className="flex gap-3 mt-1">
                    {monthlyEffortCounts.weeklyBreakdown.map((_, i) => (
                      <div key={i} className={`flex-1 text-center text-[9px] font-medium ${theme.textMuted}`}>Wk {i + 1}</div>
                    ))}
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* Time by Goal */}
          {monthlyGoalTime.length > 0 && (
            <div>
              <p className={`text-[11px] font-bold uppercase tracking-wider mb-2 pl-1 ${theme.textMuted}`}>Time by Goal</p>
              <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
                <div className={`px-3.5 py-2.5 flex justify-around border-b ${theme.divider}`}>
                  <div className="text-center">
                    <div className={`text-[14px] font-bold ${theme.textPrimary}`}>{fmtTime(monthTotalCompleted)}</div>
                    <div className={`text-[9px] ${theme.textMuted}`}>completed</div>
                  </div>
                  <div className="text-center">
                    <div className={`text-[14px] font-bold ${theme.textMuted}`}>{fmtTime(monthTotalScheduled)}</div>
                    <div className={`text-[9px] ${theme.textMuted}`}>scheduled</div>
                  </div>
                  <div className="text-center">
                    <div className={`text-[14px] font-bold ${monthTotalScheduled > 0 && Math.round((monthTotalCompleted / monthTotalScheduled) * 100) >= 75 ? 'text-emerald-500' : 'text-orange-500'}`}>
                      {monthTotalScheduled > 0 ? Math.round((monthTotalCompleted / monthTotalScheduled) * 100) : 0}%
                    </div>
                    <div className={`text-[9px] ${theme.textMuted}`}>follow-through</div>
                  </div>
                </div>
                {monthlyGoalTime.map((goal, i) => {
                  const pctDone = Math.round((goal.completed / goal.scheduled) * 100);
                  const maxSched = Math.max(...monthlyGoalTime.map(g => g.scheduled));
                  const barW = (goal.scheduled / maxSched) * 100;
                  return (
                    <div key={i} className={`px-3.5 py-2.5 ${i < monthlyGoalTime.length - 1 ? `border-b ${theme.divider}` : ''}`}>
                      <div className="flex items-center justify-between mb-1">
                        <div className="flex items-center gap-2">
                          <div className="w-1.5 h-1.5 rounded-full flex-shrink-0" style={{ backgroundColor: goal.color }} />
                          <span className={`text-[11px] font-medium ${theme.textPrimary}`}>{goal.name}</span>
                        </div>
                        <div className="flex items-center gap-1.5">
                          <span className={`text-[10px] font-bold ${theme.textPrimary}`}>{fmtTime(goal.completed)}</span>
                          <span className={`text-[9px] ${theme.textMuted}`}>/ {fmtTime(goal.scheduled)}</span>
                        </div>
                      </div>
                      <div className="relative h-2 rounded-full overflow-hidden" style={{ width: `${barW}%` }}>
                        <div className="absolute inset-0 rounded-full" style={{ backgroundColor: darkMode ? '#1e293b' : '#e2e8f0' }} />
                        <div className="absolute inset-y-0 left-0 rounded-full" style={{ width: `${pctDone}%`, backgroundColor: pctDone >= 90 ? '#22c55e' : pctDone >= 60 ? goal.color : '#f97316' }} />
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          )}

          {/* Category Depth - Comparative Matrix */}
          {monthlyCategoryDepth.length > 0 && (
            <div>
              <p className={`text-[11px] font-bold uppercase tracking-wider mb-2 pl-1 ${theme.textMuted}`}>Category Depth</p>
              <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
                {monthlyCategoryDepth.map((cat, ci) => {
                  const timePct = cat.timeScheduled > 0 ? Math.round((cat.timeCompleted / cat.timeScheduled) * 100) : 0;
                  return (
                    <div key={ci} className={`px-3.5 py-3 ${ci < monthlyCategoryDepth.length - 1 ? `border-b ${theme.divider}` : ''}`}>
                      <div className="flex items-center justify-between mb-2">
                        <div className="flex items-center gap-2">
                          <div className="w-2 h-2 rounded-full" style={{ backgroundColor: cat.color }} />
                          <span className={`text-[12px] font-semibold ${theme.textPrimary}`}>{cat.name}</span>
                        </div>
                        <span className="text-[13px] font-bold" style={{ color: cat.color }}>{cat.pct}%</span>
                      </div>
                      <div className="flex items-center gap-4 ml-4">
                        <div className="flex items-center gap-1.5">
                          <div className="relative w-7 h-7 flex-shrink-0">
                            <svg viewBox="0 0 28 28" className="w-full h-full" style={{ transform: 'rotate(-90deg)' }}>
                              <circle cx="14" cy="14" r="10" fill="none" stroke={darkMode ? '#1e293b' : '#e2e8f0'} strokeWidth="3" />
                              <circle cx="14" cy="14" r="10" fill="none" stroke="#3b82f6" strokeWidth="3"
                                strokeDasharray={`${timePct * 0.628} ${62.8 - timePct * 0.628}`} strokeLinecap="round" />
                            </svg>
                          </div>
                          <div>
                            <div className={`text-[10px] font-bold ${theme.textPrimary}`}>{fmtTime(cat.timeCompleted)}</div>
                            <div className={`text-[8px] ${theme.textMuted}`}>time</div>
                          </div>
                        </div>
                        <div className="flex-1">
                          <div className="flex rounded-full overflow-hidden h-2 mb-0.5">
                            <div style={{ width: `${cat.effortMix.easy}%`, backgroundColor: '#86efac' }} />
                            <div style={{ width: `${cat.effortMix.medium}%`, backgroundColor: '#fde68a' }} />
                            <div style={{ width: `${cat.effortMix.hard}%`, backgroundColor: '#f87171' }} />
                          </div>
                          <div className={`text-[8px] ${theme.textMuted}`}>{cat.effortMix.hard}% hard</div>
                        </div>
                        <div className="flex gap-0.5 items-end flex-shrink-0" style={{ height: 16, width: 32 }}>
                          {cat.weeklyPcts.map((pctVal, wi) => (
                            <div key={wi} className="flex-1 rounded-sm" style={{ height: `${Math.max((pctVal / 100) * 14, 1)}px`, backgroundColor: cat.color, opacity: 0.4 + (wi / Math.max(cat.weeklyPcts.length - 1, 1)) * 0.6 }} />
                          ))}
                        </div>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          )}
        </div>
      );
    };

    // ==== YEARLY VIEW (Month Cards + Mini Heat Map) ====
    const YearlyCalendar = () => {
      const [yearlyTab, setYearlyTab] = useState('highlights');
      const year = calendarDate.getFullYear();
      const jan1 = new Date(year, 0, 1);
      const startOffset = jan1.getDay();
      const isLeap = (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
      const totalDays = isLeap ? 366 : 365;
      const today = new Date();
      const todayKey = toLocalDateKey(today);
      const isCurrentYear = year === today.getFullYear();
      const daysPassed = isCurrentYear 
        ? Math.floor((today - jan1) / (1000 * 60 * 60 * 24)) + 1
        : totalDays;

      const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

      // Navigation helpers
      const goToDay = (date) => { setSelectedDate(date); setCurrentView('daily'); };
      const goToMonth = (monthIndex) => { 
        setCalendarDate(new Date(year, monthIndex, 1)); 
        setCalendarMode('month'); 
      };

      // Build weeks for compact heat map
      const weeks = useMemo(() => {
        const result = [];
        let currentWeek = [];
        for (let i = 0; i < startOffset; i++) currentWeek.push(null);
        for (let d = 0; d < totalDays; d++) {
          const date = new Date(year, 0, d + 1);
          const dateKey = toLocalDateKey(date);
          const progress = calculateDailyProgress(dateKey);
          const isFuture = dateKey > todayKey;
          currentWeek.push({ date, dateKey, pct: progress.percentage, isFuture });
          if (currentWeek.length === 7) {
            result.push(currentWeek);
            currentWeek = [];
          }
        }
        if (currentWeek.length > 0) {
          while (currentWeek.length < 7) currentWeek.push(null);
          result.push(currentWeek);
        }
        return result;
      }, [year, startOffset, totalDays, calculateDailyProgress, todayKey]);

      // Calculate monthly stats
      const monthlyStats = useMemo(() => {
        const months = [];
        for (let m = 0; m < 12; m++) {
          const daysInMonth = new Date(year, m + 1, 0).getDate();
          let total = 0, count = 0, perfectDays = 0, totalTasks = 0;

          for (let d = 1; d <= daysInMonth; d++) {
            const date = new Date(year, m, d);
            if (date > today) continue;
            const dateKey = toLocalDateKey(date);
            const progress = calculateDailyProgress(dateKey);
            if (progress.total > 0) {
              total += progress.percentage;
              count++;
              totalTasks += progress.completed;
              if (progress.percentage === 100) perfectDays++;
            }
          }

          const prevMonth = m > 0 ? months[m - 1] : null;
          const avg = count > 0 ? Math.round(total / count) : 0;

          months.push({
            index: m,
            name: new Date(year, m).toLocaleString('default', { month: 'long' }),
            shortName: monthNames[m],
            avg,
            daysTracked: count,
            daysInMonth,
            perfectDays,
            totalTasks,
            isFuture: new Date(year, m, 1) > today,
            isCurrent: m === today.getMonth() && year === today.getFullYear(),
            trend: prevMonth && !prevMonth.isFuture && prevMonth.daysTracked > 0 ? avg - prevMonth.avg : null,
          });
        }
        return months;
      }, [year, calculateDailyProgress]);

      // Calculate yearly stats
      const yearlyStats = useMemo(() => {
        const tracked = monthlyStats.filter(m => !m.isFuture && m.daysTracked > 0);
        const yearAvg = tracked.length > 0 
          ? Math.round(tracked.reduce((s, m) => s + m.avg, 0) / tracked.length) 
          : 0;
        const totalPerfect = monthlyStats.reduce((s, m) => s + m.perfectDays, 0);
        const totalDaysTracked = monthlyStats.reduce((s, m) => s + m.daysTracked, 0);
        const totalTasks = monthlyStats.reduce((s, m) => s + m.totalTasks, 0);
        const bestMonth = tracked.reduce((best, m) => m.avg > (best?.avg || 0) ? m : best, null);

        // Find best day
        let bestDay = { date: null, pct: 0 };
        for (let d = 0; d < daysPassed; d++) {
          const date = new Date(year, 0, d + 1);
          const dateKey = toLocalDateKey(date);
          const progress = calculateDailyProgress(dateKey);
          if (progress.percentage > bestDay.pct && progress.total > 0) {
            bestDay = { date, pct: progress.percentage };
          }
        }

        // Calculate streaks
        let currentStreak = 0;
        let longestStreak = 0;
        let tempStreak = 0;
        
        for (let d = 0; d < daysPassed; d++) {
          const date = new Date(year, 0, d + 1);
          const dateKey = toLocalDateKey(date);
          const progress = calculateDailyProgress(dateKey);
          if (progress.percentage >= 50 && progress.total > 0) {
            tempStreak++;
            longestStreak = Math.max(longestStreak, tempStreak);
          } else {
            tempStreak = 0;
          }
        }

        // Current streak (from today backwards)
        for (let d = daysPassed - 1; d >= 0; d--) {
          const date = new Date(year, 0, d + 1);
          const dateKey = toLocalDateKey(date);
          const progress = calculateDailyProgress(dateKey);
          if (progress.percentage >= 50 && progress.total > 0) {
            currentStreak++;
          } else {
            break;
          }
        }

        // Day of week patterns
        const dayOfWeekData = [
          { day: 'Sun', total: 0, count: 0, pct: 0 },
          { day: 'Mon', total: 0, count: 0, pct: 0 },
          { day: 'Tue', total: 0, count: 0, pct: 0 },
          { day: 'Wed', total: 0, count: 0, pct: 0 },
          { day: 'Thu', total: 0, count: 0, pct: 0 },
          { day: 'Fri', total: 0, count: 0, pct: 0 },
          { day: 'Sat', total: 0, count: 0, pct: 0 },
        ];

        for (let d = 0; d < daysPassed; d++) {
          const date = new Date(year, 0, d + 1);
          const dateKey = toLocalDateKey(date);
          const progress = calculateDailyProgress(dateKey);
          if (progress.total > 0) {
            const dow = date.getDay();
            dayOfWeekData[dow].total += progress.percentage;
            dayOfWeekData[dow].count++;
          }
        }

        dayOfWeekData.forEach(d => {
          d.pct = d.count > 0 ? Math.round(d.total / d.count) : 0;
        });

        const bestDayOfWeek = dayOfWeekData.reduce((best, d) => d.pct > best.pct ? d : best, { pct: 0 });

        // Quarterly data
        const quarterlyData = [0, 1, 2, 3].map(q => {
          const qMonths = monthlyStats.slice(q * 3, q * 3 + 3).filter(m => !m.isFuture && m.daysTracked > 0);
          const qAvg = qMonths.length > 0 
            ? Math.round(qMonths.reduce((s, m) => s + m.avg, 0) / qMonths.length)
            : null;
          return { q: `Q${q + 1}`, pct: qAvg, isFuture: qMonths.length === 0 };
        });

        return {
          yearAvg,
          totalPerfect,
          totalDaysTracked,
          totalTasks,
          bestMonth,
          bestDay,
          currentStreak,
          longestStreak,
          dayOfWeekData,
          bestDayOfWeek,
          quarterlyData,
        };
      }, [monthlyStats, daysPassed, year, calculateDailyProgress]);

      // Goal stats
      const goalStats = useMemo(() => {
        const activeGoals = goals.filter(g => !g.archived);
        const completedGoals = goals.filter(g => g.archived);
        const needsAttention = activeGoals.filter(g => {
          const pct = goalProgressCache[g.id]?.percentage || 0;
          return pct < 50;
        }).length;

        let bestGoal = null;
        let bestPct = 0;
        activeGoals.forEach(g => {
          const pct = goalProgressCache[g.id]?.percentage || 0;
          if (pct > bestPct) {
            bestPct = pct;
            bestGoal = { ...g, pct };
          }
        });

        return { total: activeGoals.length + completedGoals.length, active: activeGoals.length, completed: completedGoals.length, needsAttention, bestGoal };
      }, [goals, goalProgressCache]);

      // Category stats
      const categoryStats = useMemo(() => {
        return (categories || []).map(cat => {
          const catGoals = goals.filter(g => g.category === cat.id && !g.archived);
          if (catGoals.length === 0) return null;
          let totalPct = 0;
          catGoals.forEach(g => { totalPct += goalProgressCache[g.id]?.percentage || 0; });
          const avgPct = Math.round(totalPct / catGoals.length);
          return { ...cat, pct: avgPct, goalCount: catGoals.length };
        }).filter(Boolean).sort((a, b) => b.pct - a.pct);
      }, [categories, goals, goalProgressCache]);

      // Journal stats
      const journalStats = useMemo(() => {
        let entries = 0;
        let sliderTotals = {};
        let sliderCounts = {};

        journalConfig.prompts.forEach(p => {
          if (p.type === 'slider') {
            sliderTotals[p.id] = 0;
            sliderCounts[p.id] = 0;
          }
        });

        for (let d = 0; d < daysPassed; d++) {
          const date = new Date(year, 0, d + 1);
          const dateKey = toLocalDateKey(date);
          let hasEntry = false;
          journalConfig.prompts.forEach(p => {
            const val = journalEntries[`${dateKey}-${p.id}`];
            if (p.type === 'text' && val && val.trim().length > 0) hasEntry = true;
            if (p.type === 'slider' && val !== undefined) {
              sliderTotals[p.id] += val;
              sliderCounts[p.id]++;
            }
          });
          if (hasEntry) entries++;
        }

        const sliderAvgs = journalConfig.prompts
          .filter(p => p.type === 'slider')
          .map(p => ({
            label: p.label,
            avg: sliderCounts[p.id] > 0 ? (sliderTotals[p.id] / sliderCounts[p.id]).toFixed(1) : null,
            max: p.max || 10,
          }))
          .filter(s => s.avg !== null);

        return { entries, sliderAvgs };
      }, [year, daysPassed, journalConfig, journalEntries]);

      // Compact Heat Map Component
      const CompactHeatMap = () => {
        const cellSize = 6;
        const gap = 1;

        return (
          <div className="overflow-x-auto">
            <div className="flex" style={{ gap }}>
              {weeks.map((week, wi) => (
                <div key={wi} className="flex flex-col" style={{ gap }}>
                  {week.map((cell, di) => {
                    if (!cell) return <div key={di} style={{ width: cellSize, height: cellSize }} />;
                    const bgColor = cell.isFuture ? (darkMode ? '#1e293b' : '#f8fafc') : getHeatColor(cell.pct);
                    return (
                      <div
                        key={di}
                        onClick={() => !cell.isFuture && goToDay(cell.date)}
                        style={{
                          width: cellSize,
                          height: cellSize,
                          borderRadius: 1,
                          background: bgColor,
                          opacity: cell.isFuture ? 0.3 : 1,
                          cursor: cell.isFuture ? 'default' : 'pointer'
                        }}
                      />
                    );
                  })}
                </div>
              ))}
            </div>
            
            <div className="flex justify-end items-center gap-1 mt-1.5">
              <span className={`text-[7px] ${theme.textMuted}`} style={{ opacity: 0.6 }}>Less</span>
              {[0, 30, 50, 75, 100].map(pct => (
                <div key={pct} style={{ width: 6, height: 6, borderRadius: 1, background: getHeatColor(pct) }} />
              ))}
              <span className={`text-[7px] ${theme.textMuted}`} style={{ opacity: 0.6 }}>More</span>
            </div>
          </div>
        );
      };

      // Get progress color
      const getYearlyProgressColor = (pct) => {
        if (pct === 0) return darkMode ? '#475569' : '#e2e8f0';
        if (pct < 40) return '#fb923c';
        if (pct < 70) return '#facc15';
        if (pct < 90) return '#4ade80';
        return '#22c55e';
      };

      // ===== HIGHLIGHTS TAB =====
      const HighlightsTab = () => (
        <div className="space-y-3">
          <div className={`${theme.cardBg} rounded-xl shadow-sm p-3`}>
            <span className={`text-xs font-semibold ${theme.textMuted}`}> KEY ACHIEVEMENTS</span>
            <div className="grid grid-cols-2 gap-2 mt-2">
              {[
                { label: 'Best Day', value: yearlyStats.bestDay.date ? yearlyStats.bestDay.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) : '', sub: yearlyStats.bestDay.pct ? `${yearlyStats.bestDay.pct}%` : '', color: '#22c55e' },
                { label: 'Best Month', value: yearlyStats.bestMonth?.shortName || '', sub: yearlyStats.bestMonth ? `${yearlyStats.bestMonth.avg}%` : '', color: '#6366f1' },
                { label: 'Current Streak', value: `${yearlyStats.currentStreak}d`, sub: isCurrentYear ? 'and counting' : '', color: '#f97316' },
                { label: 'Longest Streak', value: `${yearlyStats.longestStreak}d`, sub: 'this year', color: '#8b5cf6' },
              ].map((h, i) => (
                <div key={i} className={`p-2.5 rounded-lg ${theme.inputBg}`}>
                  <div className={`text-[10px] ${theme.textMuted}`}>{h.label}</div>
                  <div className="text-lg font-bold" style={{ color: h.color }}>{h.value}</div>
                  {h.sub && <div className={`text-[10px] ${theme.textMuted}`}>{h.sub}</div>}
                </div>
              ))}
            </div>
          </div>

          <div className={`${theme.cardBg} rounded-xl shadow-sm p-3`}>
            <span className={`text-xs font-semibold ${theme.textMuted}`}> MONTHLY TREND</span>
            <div className="flex items-end gap-1 h-16 mt-2">
              {monthlyStats.map((m, i) => {
                const isFuture = m.isFuture;
                const isMax = !isFuture && m.avg === yearlyStats.bestMonth?.avg;
                return (
                  <div key={i} className="flex-1 flex flex-col items-center">
                    <div
                      className="w-full rounded-t transition-all"
                      style={{
                        height: isFuture ? '4px' : `${Math.max(m.avg * 0.6, 4)}px`,
                        background: isFuture ? (darkMode ? '#334155' : '#e2e8f0') : isMax ? '#6366f1' : getYearlyProgressColor(m.avg),
                        minHeight: 4,
                      }}
                    />
                    <span className={`text-[7px] mt-0.5 ${isMax ? 'text-indigo-500 font-bold' : theme.textMuted}`}>
                      {m.shortName.charAt(0)}
                    </span>
                  </div>
                );
              })}
            </div>
            {monthlyStats[0].daysTracked > 0 && (
              <div className={`text-[10px] text-center mt-2 ${theme.textSecondary}`}>
                {(() => {
                  const firstMonth = monthlyStats.find(m => m.daysTracked > 0);
                  const currentMonth = monthlyStats.filter(m => !m.isFuture && m.daysTracked > 0).pop();
                  if (!firstMonth || !currentMonth || firstMonth === currentMonth) return null;
                  const diff = currentMonth.avg - firstMonth.avg;
                  if (diff > 0) return ` Up ${diff}% since ${firstMonth.shortName}`;
                  if (diff < 0) return ` Down ${Math.abs(diff)}% since ${firstMonth.shortName}`;
                  return ' Holding steady';
                })()}
              </div>
            )}
          </div>
        </div>
      );

      // ===== GOALS TAB =====
      const GoalsTab = () => (
        <div className="space-y-3">
          <div className={`${theme.cardBg} rounded-xl shadow-sm p-3`}>
            <span className={`text-xs font-semibold ${theme.textMuted}`}> GOALS THIS YEAR</span>
            <div className={`text-xs ${theme.textSecondary} mt-1 mb-3`}>
              {goalStats.total} goals  {goalStats.completed} completed  {goalStats.needsAttention > 0 ? `${goalStats.needsAttention} needs attention` : 'all on track'}
            </div>
            
            {goalStats.bestGoal && (
              <div className="p-3 rounded-lg" style={{ 
                background: darkMode 
                  ? 'linear-gradient(135deg, #064e3b 0%, #065f46 100%)' 
                  : 'linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%)', 
                border: darkMode ? '1px solid #10b981' : '1px solid #a7f3d0' 
              }}>
                <div className="flex items-center gap-1 mb-1">
                  <span style={{ fontSize: 12 }}></span>
                  <span className={`text-[10px] font-semibold ${darkMode ? 'text-emerald-400' : 'text-emerald-700'}`}>GOAL OF THE YEAR</span>
                </div>
                <div className="flex items-center gap-3">
                  <div className="w-11 h-11 rounded-full flex items-center justify-center text-sm font-bold text-white bg-emerald-500">
                    {goalStats.bestGoal.pct}%
                  </div>
                  <div>
                    <div className={`text-sm font-semibold ${darkMode ? 'text-emerald-100' : 'text-emerald-900'}`}>{goalStats.bestGoal.title}</div>
                    <div className={`text-[10px] ${darkMode ? 'text-emerald-400' : 'text-emerald-600'}`}>Most consistent goal</div>
                  </div>
                </div>
              </div>
            )}
          </div>

          <div className={`${theme.cardBg} rounded-xl shadow-sm p-3`}>
            <span className={`text-xs font-semibold ${theme.textMuted}`}> BY CATEGORY</span>
            {categoryStats.length === 0 ? (
              <p className={`text-xs ${theme.textMuted} mt-2`}>No category data yet</p>
            ) : (
              <div className="space-y-2.5 mt-2">
                {categoryStats.map((c, i) => (
                  <div key={i}>
                    <div className="flex justify-between text-xs mb-1">
                      <span className={theme.textSecondary}>{c.name}</span>
                      <span className="font-semibold" style={{ color: c.color }}>{c.pct}%</span>
                    </div>
                    <div className={`h-2 rounded-full ${theme.inputBg}`}>
                      <div className="h-full rounded-full transition-all" style={{ width: `${c.pct}%`, background: c.color }} />
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      );

      // ===== PATTERNS TAB =====
      const PatternsTab = () => {
        const maxPct = Math.max(...yearlyStats.dayOfWeekData.map(d => d.pct));
        
        return (
          <div className="space-y-3">
            <div className={`${theme.cardBg} rounded-xl shadow-sm p-3`}>
              <span className={`text-xs font-semibold ${theme.textMuted}`}> WEEKLY PATTERNS</span>
              <div className="flex items-end gap-2 h-20 mt-3">
                {yearlyStats.dayOfWeekData.map((d, i) => {
                  const isMax = d.pct === maxPct && d.pct > 0;
                  return (
                    <div key={i} className="flex-1 flex flex-col items-center">
                      <div className={`text-[9px] font-semibold mb-1`} style={{ color: isMax ? '#22c55e' : (darkMode ? '#64748b' : '#94a3b8') }}>
                        {d.pct}%
                      </div>
                      <div
                        className="w-full rounded-t transition-all"
                        style={{
                          height: `${Math.max(d.pct * 0.6, 4)}px`,
                          background: isMax ? '#22c55e' : (darkMode ? '#475569' : '#cbd5e1'),
                        }}
                      />
                      <span className={`text-[10px] mt-1.5 font-medium ${isMax ? 'text-emerald-500' : theme.textMuted}`}>
                        {d.day.slice(0, 3)}
                      </span>
                    </div>
                  );
                })}
              </div>
              {yearlyStats.bestDayOfWeek.pct > 0 && (
                <div className={`text-[11px] text-center mt-3 ${theme.textSecondary}`}>
                   You're most consistent on <span className="text-emerald-500 font-semibold">{yearlyStats.bestDayOfWeek.day}s</span>
                </div>
              )}
            </div>

            <div className={`${theme.cardBg} rounded-xl shadow-sm p-3`}>
              <span className={`text-xs font-semibold ${theme.textMuted}`}> QUARTERLY</span>
              <div className="grid grid-cols-4 gap-2 mt-2">
                {yearlyStats.quarterlyData.map((q, i) => {
                  const isBest = q.pct !== null && q.pct === Math.max(...yearlyStats.quarterlyData.filter(x => x.pct !== null).map(x => x.pct));
                  return (
                    <div key={i} className={`p-2 rounded-lg text-center ${
                      q.isFuture ? theme.inputBg :
                      isBest ? (darkMode ? 'bg-emerald-900/50 border border-emerald-700' : 'bg-emerald-50 border border-emerald-200') :
                      theme.inputBg
                    }`}>
                      <div className={`text-[10px] font-bold ${isBest ? 'text-emerald-500' : theme.textMuted}`}>{q.q}</div>
                      <div className={`text-lg font-bold ${q.isFuture ? theme.textMuted : isBest ? 'text-emerald-500' : theme.textPrimary}`}>
                        {q.pct === null ? '' : `${q.pct}%`}
                      </div>
                      {isBest && <div className="text-[8px] text-emerald-500">Best</div>}
                    </div>
                  );
                })}
              </div>
            </div>
          </div>
        );
      };

      // ===== JOURNAL TAB =====
      const JournalTab = () => (
        <div className="space-y-3">
          <div className={`${theme.cardBg} rounded-xl shadow-sm p-3`}>
            <span className={`text-xs font-semibold ${theme.textMuted}`}> JOURNAL INSIGHTS</span>
            <div className={`grid grid-cols-${Math.min(3, 1 + journalStats.sliderAvgs.length)} gap-2 mt-2`}>
              <div className={`p-2.5 rounded-lg ${theme.inputBg} text-center`}>
                <div className={`text-lg font-bold ${theme.textPrimary}`}>{journalStats.entries}</div>
                <div className={`text-[9px] ${theme.textMuted}`}>Entries</div>
              </div>
              {journalStats.sliderAvgs.slice(0, 2).map((s, i) => (
                <div key={i} className={`p-2.5 rounded-lg ${theme.inputBg} text-center`}>
                  <div className="text-lg font-bold" style={{ color: parseFloat(s.avg) >= s.max * 0.7 ? '#22c55e' : parseFloat(s.avg) >= s.max * 0.4 ? '#eab308' : '#f97316' }}>
                    {s.avg}
                  </div>
                  <div className={`text-[9px] ${theme.textMuted}`}>Avg {s.label}</div>
                </div>
              ))}
            </div>
          </div>
          {journalStats.entries === 0 && (
            <div className={`${theme.cardBg} rounded-xl shadow-sm p-4 text-center`}>
              <p className={`text-sm ${theme.textMuted}`}>Start journaling to see insights here!</p>
            </div>
          )}
        </div>
      );

      // ===== MAIN RETURN =====
      return (
        <div className="space-y-3">
          {/* Header Card with Mini Heat Map */}
          <div className={`${theme.cardBg} rounded-xl shadow-sm p-4`}>
            <div className="flex items-center justify-between mb-3">
              <div>
                <h2 className={`text-xl font-bold ${theme.textPrimary}`}>{year}</h2>
                <p className={`text-xs ${theme.textMuted} mt-0.5`}>
                  {yearlyStats.totalDaysTracked} days tracked  {yearlyStats.totalPerfect} perfect
                </p>
              </div>
              <div className="text-right">
                <div className="text-2xl font-bold" style={{ color: getYearlyProgressColor(yearlyStats.yearAvg) }}>
                  {yearlyStats.yearAvg}%
                </div>
                <div className={`text-[10px] ${theme.textMuted}`}>Year Average</div>
              </div>
            </div>
            
            <div className={`pt-3 border-t ${theme.divider}`}>
              <CompactHeatMap />
            </div>
          </div>

          {/* Month Cards Grid */}
          <div className="grid grid-cols-2 gap-2.5">
            {monthlyStats.map((month) => (
              <button
                key={month.index}
                onClick={() => !month.isFuture && goToMonth(month.index)}
                disabled={month.isFuture}
                className={`text-left ${theme.cardBg} rounded-xl shadow-sm overflow-hidden transition-all active:scale-[0.98] ${
                  month.isFuture ? 'opacity-40' : ''
                } ${month.isCurrent ? `ring-2 ${darkMode ? 'ring-slate-400' : 'ring-slate-700'} ring-offset-2 ${darkMode ? 'ring-offset-slate-900' : 'ring-offset-slate-100'}` : ''}`}
              >
                {/* Progress bar at top */}
                <div className={`h-1 ${theme.inputBg}`}>
                  <div
                    className="h-full rounded-r"
                    style={{ width: `${month.avg}%`, backgroundColor: getYearlyProgressColor(month.avg) }}
                  />
                </div>
                
                <div className="p-3">
                  <div className="flex items-baseline justify-between mb-1">
                    <span className={`text-sm font-semibold ${theme.textSecondary}`}>{month.shortName}</span>
                    <div className="flex items-baseline gap-1">
                      <span className="text-base font-bold" style={{ color: getYearlyProgressColor(month.avg) }}>
                        {month.isFuture ? '' : `${month.avg}%`}
                      </span>
                      {month.trend !== null && (
                        <span className={`text-[10px] ${month.trend >= 0 ? 'text-emerald-500' : 'text-orange-500'}`}>
                          {month.trend >= 0 ? '' : ''}{Math.abs(month.trend)}
                        </span>
                      )}
                    </div>
                  </div>
                  
                  {!month.isFuture && (
                    <div className={`flex justify-between text-[10px] ${theme.textMuted}`}>
                      <span>{month.daysTracked}d</span>
                      {month.perfectDays > 0 && <span>{month.perfectDays}</span>}
                    </div>
                  )}
                </div>
              </button>
            ))}
          </div>

          {/* Analysis Tabs */}
          <div className={`${theme.cardBg} rounded-xl shadow-sm p-1 flex gap-1`}>
            {[
              { id: 'highlights', label: 'Highlights' },
              { id: 'goals', label: 'Goals' },
              { id: 'patterns', label: 'Patterns' },
              { id: 'journal', label: 'Journal' },
            ].map(t => (
              <button
                key={t.id}
                onClick={() => setYearlyTab(t.id)}
                className={`flex-1 py-2 rounded-lg text-xs font-semibold transition-all ${
                  yearlyTab === t.id ? theme.btnPrimary : theme.textMuted
                }`}
              >
                {t.label}
              </button>
            ))}
          </div>

          {/* Tab Content */}
          {yearlyTab === 'highlights' && <HighlightsTab />}
          {yearlyTab === 'goals' && <GoalsTab />}
          {yearlyTab === 'patterns' && <PatternsTab />}
          {yearlyTab === 'journal' && <JournalTab />}

          {/* ============ TIME & DIFFICULTY ANALYSIS ============ */}
          {(() => {
            // Effort Distribution
            const monthNames12 = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            const yearEffort = (() => {
              let easy = 0, medium = 0, hard = 0;
              const monthly = [];
              for (let m = 0; m < 12; m++) {
                let mE = 0, mM = 0, mH = 0;
                const dim = new Date(year, m + 1, 0).getDate();
                for (let d = 1; d <= dim; d++) {
                  const dt = new Date(year, m, d);
                  if (dt > today) break;
                  const dk = toLocalDateKey(dt);
                  goals.forEach(goal => {
                    if (!goal.tasks) return;
                    goal.tasks.forEach(task => {
                      const diff = task.difficulty || 'medium';
                      const isD = !task.frequency || task.frequency === 'daily';
                      const isS = task.frequency === 'scheduled' && isTaskScheduledForDate(task, dt);
                      if (!isD && !isS) return;
                      const checks = task.dailyChecks || 1;
                      for (let c = 0; c < checks; c++) {
                        if (dailyTasks[dk]?.[`${goal.id}-${task.id}-${c}`]) {
                          if (diff === 'easy') { mE++; easy++; }
                          else if (diff === 'hard') { mH++; hard++; }
                          else { mM++; medium++; }
                        }
                      }
                    });
                  });
                }
                const mT = mE + mM + mH;
                monthly.push({ easy: mE, medium: mM, hard: mH, total: mT, hardPct: mT > 0 ? Math.round((mH / mT) * 100) : 0 });
              }
              return { easy, medium, hard, total: easy + medium + hard, monthly };
            })();
            const yHardTrend = yearEffort.monthly.length >= 2
              ? yearEffort.monthly[yearEffort.monthly.length - 1].hardPct - yearEffort.monthly[0].hardPct
              : 0;

            // Goals Ranked by Time
            const yearGoalTime = goals.filter(g => g.goalType !== 'points').map(goal => {
              if (!goal.tasks || goal.tasks.length === 0) return null;
              let scheduled = 0, completed = 0;
              const cat = (categories || []).find(c => c.id === goal.category);
              for (let m = 0; m < 12; m++) {
                const dim = new Date(year, m + 1, 0).getDate();
                for (let d = 1; d <= dim; d++) {
                  const dt = new Date(year, m, d);
                  if (dt > today) break;
                  const dk = toLocalDateKey(dt);
                  goal.tasks.forEach(task => {
                    const est = task.timeEstimate || 0;
                    if (!est) return;
                    const isD = !task.frequency || task.frequency === 'daily';
                    const isS = task.frequency === 'scheduled' && isTaskScheduledForDate(task, dt);
                    if (!isD && !isS) return;
                    const checks = task.dailyChecks || 1;
                    for (let c = 0; c < checks; c++) {
                      scheduled += est;
                      if (dailyTasks[dk]?.[`${goal.id}-${task.id}-${c}`]) completed += est;
                    }
                  });
                }
              }
              if (scheduled === 0) return null;
              return { id: goal.id, name: goal.title, color: cat?.color || '#64748b', scheduled, completed };
            }).filter(Boolean).sort((a, b) => b.scheduled - a.scheduled);
            const yTotalSched = yearGoalTime.reduce((s, g) => s + g.scheduled, 0);
            const yTotalComp = yearGoalTime.reduce((s, g) => s + g.completed, 0);
            const fmtT = (m) => { const h = Math.floor(m / 60); const mm = m % 60; return h > 0 ? `${h}h${mm > 0 ? ' ' + mm + 'm' : ''}` : `${mm}m`; };

            // Category Full Year Cards
            const yearCatDepth = (categories || []).map(cat => {
              const cGoals = goals.filter(g => g.category === cat.id && g.goalType !== 'points');
              if (cGoals.length === 0) return null;
              let totalDone = 0, totalAll = 0, timeSched = 0, timeComp = 0;
              let eC = 0, mC = 0, hC = 0;
              const monthlyPcts = [];
              for (let m = 0; m < 12; m++) {
                let mDone = 0, mAll = 0;
                const dim = new Date(year, m + 1, 0).getDate();
                for (let d = 1; d <= dim; d++) {
                  const dt = new Date(year, m, d);
                  if (dt > today) { break; }
                  const dk = toLocalDateKey(dt);
                  cGoals.forEach(goal => {
                    if (!goal.tasks) return;
                    goal.tasks.forEach(task => {
                      const diff = task.difficulty || 'medium';
                      const est = task.timeEstimate || 0;
                      const isD = !task.frequency || task.frequency === 'daily';
                      const isS = task.frequency === 'scheduled' && isTaskScheduledForDate(task, dt);
                      if (!isD && !isS) return;
                      const checks = task.dailyChecks || 1;
                      for (let c = 0; c < checks; c++) {
                        mAll++; totalAll++; timeSched += est;
                        if (dailyTasks[dk]?.[`${goal.id}-${task.id}-${c}`]) {
                          mDone++; totalDone++; timeComp += est;
                          if (diff === 'easy') eC++;
                          else if (diff === 'hard') hC++;
                          else mC++;
                        }
                      }
                    });
                  });
                }
                monthlyPcts.push(mAll > 0 ? Math.round((mDone / mAll) * 100) : 0);
              }
              const pct = totalAll > 0 ? Math.round((totalDone / totalAll) * 100) : 0;
              const eT = eC + mC + hC;
              const hardPct = eT > 0 ? Math.round((hC / eT) * 100) : 0;
              const timePct = timeSched > 0 ? Math.round((timeComp / timeSched) * 100) : 0;
              const trend = monthlyPcts.length >= 2 ? monthlyPcts[monthlyPcts.length - 1] - monthlyPcts[0] : 0;
              return { ...cat, pct, monthlyPcts, hoursScheduled: Math.round(timeSched / 60), hoursCompleted: Math.round(timeComp / 60), hardPct, timePct, trend };
            }).filter(Boolean);

            return (
              <div className="space-y-3 mt-3">
                <div className={`h-px ${darkMode ? 'bg-slate-700' : 'bg-slate-200'}`} />

                {/* Effort Distribution */}
                {yearEffort.total > 0 && (
                  <div>
                    <p className={`text-[11px] font-bold uppercase tracking-wider mb-2 pl-1 ${theme.textMuted}`}>Effort Distribution</p>
                    <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
                      <div className="px-3.5 py-3">
                        <div className="flex items-center gap-2 mb-3">
                          <div className="flex-1 flex rounded-full overflow-hidden h-3">
                            <div style={{ width: `${(yearEffort.easy / yearEffort.total) * 100}%`, backgroundColor: '#86efac' }} />
                            <div style={{ width: `${(yearEffort.medium / yearEffort.total) * 100}%`, backgroundColor: '#fde68a' }} />
                            <div style={{ width: `${(yearEffort.hard / yearEffort.total) * 100}%`, backgroundColor: '#f87171' }} />
                          </div>
                        </div>
                        <div className="flex justify-around">
                          {[
                            { label: 'Easy', count: yearEffort.easy, pct: Math.round((yearEffort.easy / yearEffort.total) * 100), dotColor: '#22c55e' },
                            { label: 'Medium', count: yearEffort.medium, pct: Math.round((yearEffort.medium / yearEffort.total) * 100), dotColor: '#eab308' },
                            { label: 'Hard', count: yearEffort.hard, pct: Math.round((yearEffort.hard / yearEffort.total) * 100), dotColor: '#ef4444' },
                          ].map((e, i) => (
                            <div key={i} className="text-center">
                              <div className="flex items-center justify-center gap-1">
                                <div className="w-2 h-2 rounded-full" style={{ backgroundColor: e.dotColor }} />
                                <span className={`text-[13px] font-bold ${theme.textPrimary}`}>{e.count}</span>
                              </div>
                              <div className={`text-[9px] ${theme.textMuted}`}>{e.label} ({e.pct}%)</div>
                            </div>
                          ))}
                        </div>
                      </div>
                      {/* Hard % trend */}
                      <div className={`px-3.5 pb-3.5 border-t ${theme.divider} pt-3`}>
                        <div className="flex items-center justify-between mb-2">
                          <span className={`text-[10px] font-semibold ${theme.textMuted}`}>Hard task % trend</span>
                          <span className={`text-[9px] font-bold px-1.5 py-0.5 rounded ${
                            yHardTrend >= 0 ? (darkMode ? 'bg-emerald-900/50 text-emerald-400' : 'text-emerald-600 bg-emerald-100')
                              : (darkMode ? 'bg-red-900/50 text-red-400' : 'text-red-600 bg-red-100')
                          }`}>{yHardTrend >= 0 ? '+' : ''}{yHardTrend}%</span>
                        </div>
                        <svg width="100%" height="50" viewBox="0 0 240 50" preserveAspectRatio="xMidYMid meet">
                          {[0, 25, 50].map(val => {
                            const y = 45 - (val / 50) * 40;
                            return <line key={val} x1="0" y1={y} x2="240" y2={y} stroke={darkMode ? '#1e293b' : '#f1f5f9'} strokeWidth="1" />;
                          })}
                          {yearEffort.monthly.filter(m => m.total > 0).length >= 2 && (
                            <>
                              <path d={`M ${yearEffort.monthly.map((m, i) => `${i * (240 / 11)} ${45 - (m.hardPct / 50) * 40}`).join(' L ')} L 240 45 L 0 45 Z`} fill="#ef4444" opacity="0.1" />
                              <path d={`M ${yearEffort.monthly.map((m, i) => `${i * (240 / 11)} ${45 - (m.hardPct / 50) * 40}`).join(' L ')}`} fill="none" stroke="#ef4444" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                              <circle cx="0" cy={45 - (yearEffort.monthly[0].hardPct / 50) * 40} r="3" fill="#ef4444" />
                              <circle cx="240" cy={45 - (yearEffort.monthly[11].hardPct / 50) * 40} r="3" fill="#ef4444" />
                            </>
                          )}
                        </svg>
                        <div className="flex gap-[3px] mt-0.5">
                          {monthNames12.map((m, i) => (
                            <div key={i} className={`flex-1 text-center text-[8px] font-medium ${theme.textMuted}`}>{m}</div>
                          ))}
                        </div>
                      </div>
                    </div>
                  </div>
                )}

                {/* Goals Ranked by Time */}
                {yearGoalTime.length > 0 && (
                  <div>
                    <p className={`text-[11px] font-bold uppercase tracking-wider mb-2 pl-1 ${theme.textMuted}`}>Time by Goal</p>
                    <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
                      <div className={`px-3.5 py-2.5 flex justify-around border-b ${theme.divider}`}>
                        <div className="text-center">
                          <div className={`text-[15px] font-bold ${theme.textPrimary}`}>{fmtT(yTotalComp)}</div>
                          <div className={`text-[9px] ${theme.textMuted}`}>completed</div>
                        </div>
                        <div className="text-center">
                          <div className={`text-[15px] font-bold ${theme.textMuted}`}>{fmtT(yTotalSched)}</div>
                          <div className={`text-[9px] ${theme.textMuted}`}>scheduled</div>
                        </div>
                        <div className="text-center">
                          <div className={`text-[15px] font-bold ${yTotalSched > 0 && Math.round((yTotalComp / yTotalSched) * 100) >= 75 ? 'text-emerald-500' : 'text-orange-500'}`}>
                            {yTotalSched > 0 ? Math.round((yTotalComp / yTotalSched) * 100) : 0}%
                          </div>
                          <div className={`text-[9px] ${theme.textMuted}`}>follow-through</div>
                        </div>
                      </div>
                      {yearGoalTime.map((goal, i) => {
                        const pctDone = Math.round((goal.completed / goal.scheduled) * 100);
                        const maxSched = Math.max(...yearGoalTime.map(g => g.scheduled));
                        const barW = (goal.scheduled / maxSched) * 100;
                        return (
                          <div key={i} className={`px-3.5 py-2.5 ${i < yearGoalTime.length - 1 ? `border-b ${theme.divider}` : ''}`}>
                            <div className="flex items-center justify-between mb-1">
                              <div className="flex items-center gap-2">
                                <div className="w-1.5 h-1.5 rounded-full flex-shrink-0" style={{ backgroundColor: goal.color }} />
                                <span className={`text-[11px] font-medium ${theme.textPrimary}`}>{goal.name}</span>
                              </div>
                              <div className="flex items-center gap-1.5">
                                <span className={`text-[10px] font-bold ${theme.textPrimary}`}>{fmtT(goal.completed)}</span>
                                <span className={`text-[9px] ${theme.textMuted}`}>/ {fmtT(goal.scheduled)}</span>
                              </div>
                            </div>
                            <div className="relative h-2 rounded-full overflow-hidden" style={{ width: `${barW}%` }}>
                              <div className="absolute inset-0 rounded-full" style={{ backgroundColor: darkMode ? '#1e293b' : '#e2e8f0' }} />
                              <div className="absolute inset-y-0 left-0 rounded-full" style={{ width: `${pctDone}%`, backgroundColor: pctDone >= 90 ? '#22c55e' : pctDone >= 60 ? goal.color : '#f97316' }} />
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                )}

                {/* Category Depth - Full Year Cards */}
                {yearCatDepth.length > 0 && (
                  <div>
                    <p className={`text-[11px] font-bold uppercase tracking-wider mb-2 pl-1 ${theme.textMuted}`}>Category Depth</p>
                    <div className="space-y-2.5">
                      {yearCatDepth.map((cat, ci) => (
                        <div key={ci} className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
                          <div className="h-1.5" style={{ backgroundColor: darkMode ? '#1e293b' : '#e2e8f0' }}>
                            <div className="h-full" style={{ width: `${cat.pct}%`, backgroundColor: cat.color }} />
                          </div>
                          <div className="p-3.5">
                            <div className="flex items-center justify-between mb-2.5">
                              <div className="flex items-center gap-2">
                                <div className="w-2.5 h-2.5 rounded-full" style={{ backgroundColor: cat.color }} />
                                <span className={`text-[13px] font-semibold ${theme.textPrimary}`}>{cat.name}</span>
                              </div>
                              <div className="flex items-center gap-1.5">
                                <span className="text-[14px] font-bold" style={{ color: cat.color }}>{cat.pct}%</span>
                                {cat.trend !== 0 && (
                                  <span className={`text-[9px] font-bold px-1 py-0.5 rounded ${
                                    cat.trend >= 0 ? (darkMode ? 'bg-emerald-900/50 text-emerald-400' : 'text-emerald-600 bg-emerald-100')
                                      : (darkMode ? 'bg-red-900/50 text-red-400' : 'text-red-600 bg-red-100')
                                  }`}>{cat.trend >= 0 ? '+' : ''}{cat.trend}%</span>
                                )}
                              </div>
                            </div>
                            <div className="grid grid-cols-3 gap-2 mb-2.5">
                              <div className={`rounded-lg px-2.5 py-2 ${theme.inputBg}`}>
                                <div className={`text-[9px] font-semibold uppercase tracking-wider mb-0.5 ${theme.textMuted}`}>Time</div>
                                <span className={`text-[13px] font-bold ${theme.textPrimary}`}>{cat.hoursCompleted}h</span>
                                <div className={`text-[9px] ${theme.textMuted}`}>/ {cat.hoursScheduled}h</div>
                              </div>
                              <div className={`rounded-lg px-2.5 py-2 ${theme.inputBg}`}>
                                <div className={`text-[9px] font-semibold uppercase tracking-wider mb-0.5 ${theme.textMuted}`}>Hard %</div>
                                <span className="text-[13px] font-bold" style={{ color: cat.hardPct > 30 ? '#ef4444' : cat.hardPct > 15 ? '#eab308' : '#22c55e' }}>{cat.hardPct}%</span>
                                <div className="flex rounded-full overflow-hidden h-1.5 mt-1">
                                  <div style={{ width: `${100 - cat.hardPct}%`, backgroundColor: darkMode ? '#334155' : '#e2e8f0' }} />
                                  <div style={{ width: `${cat.hardPct}%`, backgroundColor: '#f87171' }} />
                                </div>
                              </div>
                              <div className={`rounded-lg px-2.5 py-2 ${theme.inputBg}`}>
                                <div className={`text-[9px] font-semibold uppercase tracking-wider mb-0.5 ${theme.textMuted}`}>Follow-thru</div>
                                <span className="text-[13px] font-bold" style={{ color: cat.timePct >= 80 ? '#22c55e' : cat.timePct >= 60 ? '#eab308' : '#ef4444' }}>{cat.timePct}%</span>
                                <div className={`text-[9px] ${theme.textMuted}`}>of scheduled</div>
                              </div>
                            </div>
                            <svg width="100%" height="28" viewBox="0 0 240 28" preserveAspectRatio="xMidYMid meet">
                              <path d={`M ${cat.monthlyPcts.map((p, i) => `${i * (240 / 11)} ${26 - (p / 100) * 24}`).join(' L ')} L 240 26 L 0 26 Z`} fill={cat.color} opacity="0.08" />
                              <path d={`M ${cat.monthlyPcts.map((p, i) => `${i * (240 / 11)} ${26 - (p / 100) * 24}`).join(' L ')}`} fill="none" stroke={cat.color} strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" />
                            </svg>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            );
          })()}
        </div>
      );
    };

    return (
      <div className="space-y-3">
        {/* Date Navigator */}
        <div className="flex items-center justify-between py-2">
          <button onClick={navPrev} className={`w-8 h-8 rounded-full ${theme.btnIcon} shadow-sm flex items-center justify-center`}>
            <ChevronLeft className="w-4 h-4" />
          </button>
          <div className="text-center">
            <p className={`text-lg font-semibold ${theme.textPrimary}`}>{navLabel}</p>
            {navSub && <p className={`text-xs ${isThisWeek ? 'text-emerald-500 font-medium' : theme.textMuted}`}>{navSub}</p>}
          </div>
          <button onClick={navNext} className={`w-8 h-8 rounded-full ${theme.btnIcon} shadow-sm flex items-center justify-center`}>
            <ChevronRight className="w-4 h-4" />
          </button>
        </div>

        {/* Week / Month / Year switcher */}
        <div className={`${theme.cardBg} rounded-xl shadow-sm p-1 flex gap-1`}>
          {[
            { id: 'week', label: 'Week' },
            { id: 'month', label: 'Month' },
            { id: 'year', label: 'Year' },
          ].map(v => (
            <button
              key={v.id}
              onClick={() => setCalendarMode(v.id)}
              className={`flex-1 py-1.5 rounded-lg text-xs font-semibold transition-all ${
                calendarMode === v.id ? theme.btnPrimary : theme.textMuted
              }`}
            >
              {v.label}
            </button>
          ))}
        </div>

        {/* Calendar content */}
        {calendarMode === 'week' && <WeeklyCalendar />}
        {calendarMode === 'month' && <MonthlyCalendar />}
        {calendarMode === 'year' && <YearlyCalendar />}
      </div>
    );
  };

  // ============================================
  // DAILY VIEW - Unified Design with Points Goals
  // ============================================
  const DailyView = () => {
    const dateKey = selectedDateKey;
    const todayMedia = media[dateKey] || [];
    const changeDate = (days) => { const newDate = new Date(selectedDate); newDate.setDate(newDate.getDate() + days); setSelectedDate(newDate); };

    const toggleGoalCollapse = (goalId) => {
      const isCurrentlyCollapsed = collapsedGoals.has(goalId);
      setCollapsedGoals(prev => {
        const newSet = new Set(prev);
        if (newSet.has(goalId)) {
          newSet.delete(goalId);
        } else {
          newSet.add(goalId);
        }
        return newSet;
      });
      // If user is re-opening a collapsed group, mark it as user-opened
      // so auto-collapse won't close it again
      if (isCurrentlyCollapsed) {
        setUserOpenedGroups(prev => new Set([...prev, goalId]));
      } else {
        setUserOpenedGroups(prev => { const n = new Set(prev); n.delete(goalId); return n; });
      }
    };

    // Build unified task list sorted by category (including daily points goals)
    const buildUnifiedTaskList = () => {
      const items = [];
      
      goals.forEach(goal => {
        if (!goal.tasks || !Array.isArray(goal.tasks)) return;
        if (goal.archived) return; // Skip archived goals
        if (!isGoalActiveOnDate(goal, dateKey)) return; // Skip goals created after this date
        
        // Handle points-based goals with daily target
        if (goal.goalType === 'points') {
          if (goal.pointTargetFrequency !== 'daily' && goal.pointTargetFrequency !== undefined) return;
          
          const category = categories.find(c => c.id === goal.category);
          const categoryColor = category?.color || '#64748b';
          const categoryOrder = categories.findIndex(c => c.id === goal.category);
          
          const pointsEarned = calculatePointsEarnedForDate(dateKey, goal);
          const pointTarget = goal.pointTarget || 10;
          const percentage = Math.min(100, Math.round((pointsEarned / pointTarget) * 100));
          
          items.push({
            type: 'points',
            goal,
            tasks: goal.tasks,
            categoryColor,
            categoryOrder: categoryOrder === -1 ? 999 : categoryOrder,
            pointsEarned,
            pointTarget,
            percentage,
            isDaily: true,
            isPointsGoal: true
          });
          return;
        }
        
        // Handle checkbox goals
        const goalDailyTasks = goal.tasks.filter(t => {
          if (!t.frequency || t.frequency === 'daily') return true;
          if (t.frequency === 'scheduled') return isTaskScheduledForDate(t, selectedDate);
          return false;
        });
        if (goalDailyTasks.length === 0) return;
        
        const category = categories.find(c => c.id === goal.category);
        const categoryColor = category?.color || '#64748b';
        const categoryOrder = categories.findIndex(c => c.id === goal.category);
        
        let totalChecks = 0;
        let completedChecks = 0;
        goalDailyTasks.forEach(task => {
          const checks = task.dailyChecks || 1;
          totalChecks += checks;
          completedChecks += getTaskCompletionCount(dateKey, goal.id, task.id, checks);
        });
        const percentage = totalChecks > 0 ? Math.round((completedChecks / totalChecks) * 100) : 0;
        
        items.push({
          type: goalDailyTasks.length === 1 ? 'single' : 'group',
          goal,
          tasks: goalDailyTasks,
          categoryColor,
          categoryOrder: categoryOrder === -1 ? 999 : categoryOrder,
          percentage,
          completedChecks,
          totalChecks,
          isDaily: true,
          isPointsGoal: false
        });
      });
      
      // Sort: by category first, then singles before groups within each category
      items.sort((a, b) => {
        // Primary sort by category
        if (a.categoryOrder !== b.categoryOrder) {
          return a.categoryOrder - b.categoryOrder;
        }
        // Within same category, singles come before groups/points
        const aIsSingle = a.type === 'single';
        const bIsSingle = b.type === 'single';
        if (aIsSingle && !bIsSingle) return -1;
        if (!aIsSingle && bIsSingle) return 1;
        return 0;
      });
      return items;
    };

    // Build unified weekly task list sorted by category (including weekly points goals)
    const buildUnifiedWeeklyTaskList = () => {
      const items = [];
      const weekKey = getWeekKey(selectedDate);
      const { weekEnd } = getWeekRange(selectedDate);
      const weekEndKey = toLocalDateKey(weekEnd);
      
      goals.forEach(goal => {
        if (!goal.tasks || !Array.isArray(goal.tasks)) return;
        if (goal.archived) return; // Skip archived goals
        if (!isGoalActiveOnDate(goal, weekEndKey)) return; // Skip goals created after this week
        
        // Handle points-based goals with weekly target
        if (goal.goalType === 'points') {
          if (goal.pointTargetFrequency !== 'weekly') return;
          
          const category = categories.find(c => c.id === goal.category);
          const categoryColor = category?.color || '#64748b';
          const categoryOrder = categories.findIndex(c => c.id === goal.category);
          
          // Calculate weekly points using weekKey (data is stored by week, not by day)
          const weeklyPointsEarned = calculatePointsEarnedForWeek(weekKey, goal);
          
          const pointTarget = goal.pointTarget || 10;
          const percentage = Math.min(100, Math.round((weeklyPointsEarned / pointTarget) * 100));
          
          items.push({
            type: 'points',
            goal,
            tasks: goal.tasks,
            categoryColor,
            categoryOrder: categoryOrder === -1 ? 999 : categoryOrder,
            pointsEarned: weeklyPointsEarned,
            pointTarget,
            percentage,
            isDaily: false,
            isPointsGoal: true
          });
          return;
        }
        
        // Handle checkbox goals
        const goalWeeklyTasks = goal.tasks.filter(t => t.frequency === 'weekly');
        if (goalWeeklyTasks.length === 0) return;
        
        const category = categories.find(c => c.id === goal.category);
        const categoryColor = category?.color || '#64748b';
        const categoryOrder = categories.findIndex(c => c.id === goal.category);
        
        let totalTarget = 0;
        let totalCompleted = 0;
        goalWeeklyTasks.forEach(task => {
          const progress = calculateWeeklyProgress(task, goal.id, selectedDate);
          totalTarget += progress.target;
          totalCompleted += progress.completed;
        });
        const percentage = totalTarget > 0 ? Math.round((totalCompleted / totalTarget) * 100) : 0;
        
        items.push({
          type: goalWeeklyTasks.length === 1 ? 'single' : 'group',
          goal,
          tasks: goalWeeklyTasks,
          categoryColor,
          categoryOrder: categoryOrder === -1 ? 999 : categoryOrder,
          percentage,
          totalCompleted,
          totalTarget,
          isDaily: false,
          isPointsGoal: false
        });
      });
      
      // Sort: by category first, then singles before groups within each category
      items.sort((a, b) => {
        // Primary sort by category
        if (a.categoryOrder !== b.categoryOrder) {
          return a.categoryOrder - b.categoryOrder;
        }
        // Within same category, singles come before groups/points
        const aIsSingle = a.type === 'single';
        const bIsSingle = b.type === 'single';
        if (aIsSingle && !bIsSingle) return -1;
        if (!aIsSingle && bIsSingle) return 1;
        return 0;
      });
      return items;
    };

    const dailyItems = buildUnifiedTaskList();
    const weeklyItems = buildUnifiedWeeklyTaskList();

    // Check if task/goal is fully complete
    const isGoalComplete = (item) => {
      if (item.isPointsGoal) {
        return item.pointsEarned >= item.pointTarget;
      }
      if (item.isDaily) {
        return item.completedChecks === item.totalChecks && item.totalChecks > 0;
      } else {
        return item.totalCompleted >= item.totalTarget && item.totalTarget > 0;
      }
    };

    // Calculate streak for a task (consecutive days of completion)
    const calculateTaskStreak = (goalId, taskId, totalChecks = 1) => {
      const isCompletedOnDate = (date) => {
        const dk = toLocalDateKey(date);
        const tasks = dailyTasks[dk] || {};
        for (let i = 0; i < totalChecks; i++) {
          if (!tasks[`${goalId}-${taskId}-${i}`]) return false;
        }
        return true;
      };
      
      let checkDate = new Date(selectedDate);
      const completedToday = isCompletedOnDate(checkDate);
      
      checkDate.setDate(checkDate.getDate() - 1);
      let streakFromYesterday = 0;
      
      for (let i = 0; i < 365; i++) {
        if (isCompletedOnDate(checkDate)) {
          streakFromYesterday++;
          checkDate.setDate(checkDate.getDate() - 1);
        } else {
          break;
        }
      }
      
      return completedToday ? streakFromYesterday + 1 : streakFromYesterday;
    };

    // Render task row for unified list
    const renderTaskRow = (goal, task, isDaily, isLast, isChild = false, categoryColor, isPointsGoal = false, showBorder = true) => {
      // For weekly points goals, use week key for storage
      const isWeeklyPointsGoal = goal?.goalType === 'points' && goal?.pointTargetFrequency === 'weekly';
      const storageKey = isWeeklyPointsGoal ? getWeekKey(selectedDate) : dateKey;
      
      // Get task type for points goals
      const taskType = isPointsGoal ? (task.taskType || 'checkbox') : 'checkbox';
      
      // For points goals, tasks don't have individual daily checks - just one checkbox each
      const totalChecks = isPointsGoal ? 1 : (isDaily ? (task.dailyChecks || 1) : 1);
      const completedCount = isPointsGoal 
        ? (dailyTasks[storageKey]?.[`${goal.id}-${task.id}-0`] ? 1 : 0)
        : (isDaily 
            ? getTaskCompletionCount(dateKey, goal.id, task.id, totalChecks, goal)
            : (isTaskCompleted(dateKey, goal.id, task.id, goal) ? 1 : 0));
      const weekProgress = (!isDaily && !isPointsGoal) ? calculateWeeklyProgress(task, goal.id, selectedDate) : null;
      const isComplete = completedCount === totalChecks;
      
      // Keep category border color unfaded for completed tasks
      const borderColor = categoryColor;
      
      // A7 style: completed tasks get darker background + inset shadow
      const completedBg = isComplete ? 'rgba(100, 116, 139, 0.12)' : 'transparent';
      const completedShadow = isComplete ? 'inset 0 2px 4px rgba(0,0,0,0.04)' : 'none';
      
      // Child rows (subtasks) don't have a left border
      const rowStyle = isChild 
        ? { paddingLeft: '2rem', backgroundColor: completedBg, boxShadow: completedShadow }
        : { borderLeft: `3px solid ${borderColor}`, paddingLeft: '0.75rem', backgroundColor: completedBg, boxShadow: completedShadow };

      // Handle slider task type for points goals
      if (isPointsGoal && taskType === 'slider') {
        const maxValue = task.maxValue || 10;
        const pointsPerUnit = task.pointsPerUnit || 1;
        const currentValue = getVariableTaskValue(dateKey, goal.id, task.id, 'value', goal);
        const earnedPoints = currentValue * pointsPerUnit;
        const sliderHasValue = currentValue > 0;
        
        // A7 style for slider
        const sliderBg = sliderHasValue ? 'rgba(100, 116, 139, 0.12)' : 'transparent';
        const sliderShadow = sliderHasValue ? 'inset 0 2px 4px rgba(0,0,0,0.04)' : 'none';
        const sliderRowStyle = isChild 
          ? { paddingLeft: '2rem', backgroundColor: sliderBg, boxShadow: sliderShadow }
          : { borderLeft: `3px solid ${borderColor}`, paddingLeft: '0.75rem', backgroundColor: sliderBg, boxShadow: sliderShadow };
        
        return (
          <div 
            key={task.id}
            className="py-2.5"
            style={sliderRowStyle}
          >
            <div className="flex items-center justify-between mb-1.5">
              <span className={`text-sm ${currentValue > 0 ? 'text-slate-600' : theme.textPrimary}`}>{task.action}</span>
              <span className={`text-xs font-medium px-1.5 py-0.5 rounded ${earnedPoints > 0 ? 'bg-emerald-500/10 text-emerald-500' : 'bg-amber-500/10 text-amber-500'}`}>
                +{earnedPoints}
              </span>
            </div>
            <div className="flex items-center gap-2 mr-3">
              <input
                type="range"
                min="0"
                max={maxValue}
                value={currentValue}
                onChange={(e) => setVariableTaskValue(dateKey, goal.id, task.id, 'value', parseInt(e.target.value), goal)}
                className="flex-1 h-1.5 rounded-full appearance-none cursor-pointer"
                style={{ background: darkMode ? '#334155' : '#e2e8f0' }}
              />
              <span className={`text-xs font-medium w-10 text-right ${theme.textSecondary}`}>{currentValue}/{maxValue}</span>
            </div>
          </div>
        );
      }

      // Handle counter task type for points goals
      if (isPointsGoal && taskType === 'counter') {
        const unitsPerPoint = task.unitsPerPoint || 1;
        const pointsPerUnit = task.pointsPerUnit || 1;
        const unitLabel = task.unitLabel || '';
        const currentCount = getVariableTaskValue(dateKey, goal.id, task.id, 'count', goal);
        const earnedPoints = Math.floor(currentCount / unitsPerPoint) * pointsPerUnit;
        const counterHasValue = currentCount > 0;
        
        // A7 style for counter
        const counterBg = counterHasValue ? 'rgba(100, 116, 139, 0.12)' : 'transparent';
        const counterShadow = counterHasValue ? 'inset 0 2px 4px rgba(0,0,0,0.04)' : 'none';
        const counterRowStyle = isChild 
          ? { paddingLeft: '2rem', backgroundColor: counterBg, boxShadow: counterShadow }
          : { borderLeft: `3px solid ${borderColor}`, paddingLeft: '0.75rem', backgroundColor: counterBg, boxShadow: counterShadow };
        
        return (
          <div 
            key={task.id}
            className="py-2.5"
            style={counterRowStyle}
          >
            <div className="flex items-center justify-between">
              <span className={`text-sm flex-1 ${currentCount > 0 ? 'text-slate-600' : theme.textPrimary}`}>{task.action}</span>
              <div className="flex items-center gap-2 mr-3">
                <button
                  onClick={(e) => { e.stopPropagation(); setVariableTaskValue(dateKey, goal.id, task.id, 'count', currentCount - unitsPerPoint, goal); }}
                  className={`w-7 h-7 rounded-full flex items-center justify-center ${darkMode ? 'bg-slate-700 text-slate-300' : 'bg-slate-200 text-slate-600'}`}
                >
                  <Minus className="w-3.5 h-3.5" />
                </button>
                <span className={`text-sm font-medium min-w-[3rem] text-center ${theme.textPrimary}`}>
                  {currentCount}{unitLabel ? ` ${unitLabel}` : ''}
                </span>
                <button
                  onClick={(e) => { e.stopPropagation(); setVariableTaskValue(dateKey, goal.id, task.id, 'count', currentCount + unitsPerPoint, goal); }}
                  className={`w-7 h-7 rounded-full flex items-center justify-center ${darkMode ? 'bg-slate-700 text-slate-300' : 'bg-slate-200 text-slate-600'}`}
                >
                  <Plus className="w-3.5 h-3.5" />
                </button>
                <span className={`text-xs font-medium px-1.5 py-0.5 rounded ml-1 ${earnedPoints > 0 ? 'bg-emerald-500/10 text-emerald-500' : 'bg-amber-500/10 text-amber-500'}`}>
                  +{earnedPoints}
                </span>
              </div>
            </div>
          </div>
        );
      }

      // Single checkbox row (daily tasks with 1 check, or checkbox points goal tasks)
      if ((isDaily && totalChecks === 1) || isPointsGoal) {
        const taskKey = `${goal.id}-${task.id}-0`;
        const isChecked = dailyTasks[storageKey]?.[taskKey];
        const streak = isDaily ? calculateTaskStreak(goal.id, task.id, 1) : 0;
        const isAnim = animatingTasks[taskKey];
        const hasRipple = rippleTasks[taskKey];
        return (
          <div 
            key={task.id}
            className={`flex items-center gap-3 py-2.5 cursor-pointer ${isAnim ? 'task-slide-settle' : ''}`}
            style={{ ...rowStyle, position: 'relative', overflow: 'hidden' }}
            onClick={() => toggleTask(dateKey, goal.id, task.id, 0, task, goal)}
          >
            {isAnim && <div className="task-left-glow" />}
            {hasRipple && <div className="task-ripple-overlay" />}
            <span className={`text-sm flex-1 relative z-[1] ${isChecked ? 'text-slate-600' : theme.textPrimary}`}>{task.action}</span>
            {streak >= 5 && (
              <span className="text-xs text-orange-500 flex items-center gap-0.5 flex-shrink-0 relative z-[1]">
                <Flame className="w-3 h-3" />{streak}
              </span>
            )}
            {isPointsGoal && (
              <span className={`text-xs font-medium px-1.5 py-0.5 rounded relative z-[1] ${isChecked ? 'bg-emerald-500/10 text-emerald-500' : 'bg-amber-500/10 text-amber-500'}`}>
                +{task.pointValue || 1}
              </span>
            )}
            {taskCompletions[`${storageKey}-${goal.id}-${task.id}-0`] && (
              <button onClick={(e) => { e.stopPropagation(); setViewingCompletion({ completion: taskCompletions[`${storageKey}-${goal.id}-${task.id}-0`], taskName: task.action }); }} className="w-2 h-2 rounded-full bg-blue-400 flex-shrink-0 relative z-[1]" />
            )}
            <div className={`flex-shrink-0 mr-3 relative z-[1] ${isAnim ? 'checkbox-ripple-pop' : ''}`}>
              {isChecked ? (
                <CheckCircle2 className="w-5 h-5 text-emerald-500" />
              ) : (
                <Circle className={`w-5 h-5 ${theme.checkUndone}`} />
              )}
            </div>
          </div>
        );
      } else if (isDaily) {
        // Multiple checkbox daily task (checkbox goals only)
        const rowAnimating = Array.from({ length: totalChecks }).some((_, i) => animatingTasks[`${goal.id}-${task.id}-${i}`]);
        const rowRippling = Array.from({ length: totalChecks }).some((_, i) => rippleTasks[`${goal.id}-${task.id}-${i}`]);
        const streak = calculateTaskStreak(goal.id, task.id, totalChecks);
        return (
          <div 
            key={task.id}
            className={`flex items-center gap-3 py-2.5 ${rowAnimating ? 'task-slide-settle' : ''}`}
            style={{ ...rowStyle, position: 'relative', overflow: 'hidden' }}
          >
            {rowAnimating && <div className="task-left-glow" />}
            {rowRippling && <div className="task-ripple-overlay" />}
            <span className={`text-sm flex-1 relative z-[1] ${isComplete ? 'text-slate-600' : theme.textPrimary}`}>{task.action}</span>
            {streak >= 5 && (
              <span className="text-xs text-orange-500 flex items-center gap-0.5 flex-shrink-0 relative z-[1]">
                <Flame className="w-3 h-3" />{streak}
              </span>
            )}
            <span className={`text-xs relative z-[1] ${theme.textMuted}`}>{completedCount}/{totalChecks}</span>
            <div className="flex gap-1.5 flex-shrink-0 mr-3 relative z-[1]">
              {Array.from({ length: totalChecks }).map((_, checkIndex) => {
                const taskKey = `${goal.id}-${task.id}-${checkIndex}`;
                const isChecked = dailyTasks[dateKey]?.[taskKey];
                return (
                  <button 
                    key={checkIndex} 
                    onClick={() => toggleTask(dateKey, goal.id, task.id, checkIndex, task, goal)}
                    className={animatingTasks[taskKey] ? 'checkbox-ripple-pop' : ''}
                  >
                    {isChecked ? (
                      <CheckCircle2 className="w-5 h-5 text-emerald-500" />
                    ) : (
                      <Circle className={`w-5 h-5 ${theme.checkUndone}`} />
                    )}
                  </button>
                );
              })}
            </div>
          </div>
        );
      } else {
        // Weekly checkbox task
        const isCheckedToday = isTaskCompleted(dateKey, goal.id, task.id, goal);
        const taskKey = `${goal.id}-${task.id}-0`;
        const isAnim = animatingTasks[taskKey];
        const hasRipple = rippleTasks[taskKey];
        return (
          <div 
            key={task.id}
            className={`flex items-center gap-3 py-2.5 cursor-pointer ${isAnim ? 'task-slide-settle' : ''}`}
            style={{ ...rowStyle, position: 'relative', overflow: 'hidden' }}
            onClick={() => toggleTask(dateKey, goal.id, task.id, 0, task, goal)}
          >
            {isAnim && <div className="task-left-glow" />}
            {hasRipple && <div className="task-ripple-overlay" />}
            <span className={`text-sm flex-1 relative z-[1] ${isCheckedToday ? 'text-slate-600' : theme.textPrimary}`}>{task.action}</span>
            <span className={`text-xs relative z-[1] ${theme.textMuted}`}>{weekProgress.completed}/{weekProgress.target}</span>
            <div className={`flex-shrink-0 mr-3 relative z-[1] ${isAnim ? 'checkbox-ripple-pop' : ''}`}>
              {isCheckedToday ? (
                <CheckCircle2 className="w-5 h-5 text-emerald-500" />
              ) : (
                <Circle className={`w-5 h-5 ${theme.checkUndone}`} />
              )}
            </div>
          </div>
        );
      }
    };

    return (
      <div className="space-y-4">
        {/* Date Navigator - Option 12 Style */}
        <div className="flex items-center justify-between py-2">
          <button onClick={() => changeDate(-1)} className={`w-8 h-8 rounded-full ${theme.btnIcon} shadow-sm flex items-center justify-center`}>
            <ChevronLeft className="w-4 h-4" />
          </button>
          <div className="text-center">
            {isToday(selectedDate) && (
              <p className="text-xs font-medium text-emerald-600 uppercase tracking-wider">Today</p>
            )}
            <p className={`text-lg font-semibold ${theme.textPrimary}`}>
              {selectedDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric' })}
            </p>
            <p className={`text-xs ${theme.textMuted}`}>
              {selectedDate.toLocaleDateString('en-US', { weekday: 'long' })}
            </p>
          </div>
          <button onClick={() => changeDate(1)} className={`w-8 h-8 rounded-full ${theme.btnIcon} shadow-sm flex items-center justify-center`}>
            <ChevronRight className="w-4 h-4" />
          </button>
        </div>

        {/* Daily Tasks Section - Unified Card (including daily points goals) */}
        {dailyItems.length > 0 && (
          <div>
            <div className="flex items-center justify-between mb-2">
              <p className={`text-xs font-semibold uppercase tracking-wider ${theme.textMuted}`}>Daily Tasks</p>
              <div className="flex items-center gap-1.5">
                {showTrophyBadge && (
                  <Trophy className="w-3.5 h-3.5 text-amber-500 trophy-spin" />
                )}
                <p className={`text-xs ${dailyProgress.percentage === 100 ? 'text-emerald-500 font-semibold' : theme.textSecondary}`}>{dailyProgress.percentage}%</p>
              </div>
            </div>

            <div 
              className={`${theme.cardBg} rounded-xl overflow-hidden`}
              style={{
                boxShadow: allDoneCelebrating 
                  ? '0 0 0 2px rgba(245,158,11,0.5), 0 0 24px rgba(245,158,11,0.12), 0 1px 3px rgba(0,0,0,0.06)'
                  : '0 1px 2px 0 rgb(0 0 0 / 0.05)',
                transition: 'box-shadow 0.6s ease-out',
              }}
            >
              {allDoneCelebrating ? (
                <div style={{ height: '6px', background: darkMode ? '#334155' : '#e2e8f0', overflow: 'hidden' }}>
                  <div className="gold-shimmer-bar" style={{ height: '100%', width: '100%' }} />
                </div>
              ) : (
                <ProgressBar percentage={dailyProgress.percentage} darkMode={darkMode} />
              )}
              
              {dailyItems.map((item, itemIndex) => {
                const isCollapsed = collapsedGoals.has(`daily-${item.goal.id}`);
                const goalComplete = isGoalComplete(item);
                // Keep border color unfaded
                const borderColor = item.categoryColor;
                // A7 style for completed group headers
                const headerBg = goalComplete ? 'rgba(100, 116, 139, 0.12)' : 'transparent';
                const headerShadow = goalComplete ? 'inset 0 2px 4px rgba(0,0,0,0.04)' : 'none';
                
                // Handle points-type goals
                if (item.type === 'points') {
                  return (
                    <div key={item.goal.id} style={{ borderTop: itemIndex > 0 ? '4px solid' : 'none', borderTopColor: darkMode ? '#1e293b' : '#f1f5f9' }}>
                      <button 
                        onClick={() => toggleGoalCollapse(`daily-${item.goal.id}`)}
                        className="w-full px-3 py-2 flex items-center gap-2"
                        style={{ borderLeft: `3px solid ${borderColor}`, backgroundColor: headerBg, boxShadow: headerShadow }}
                      >
                        <ChevronDown className={`w-4 h-4 ${theme.textMuted} transition-transform ${isCollapsed ? '-rotate-90' : ''}`} />
                        <Star className="w-4 h-4 text-amber-500" />
                        <span className={`text-sm font-medium flex-1 text-left ${goalComplete ? 'text-slate-600' : theme.textPrimary}`}>{item.goal.title}</span>
                        <span className={`text-xs font-semibold ${goalComplete ? 'text-emerald-500' : theme.textSecondary}`}>
                          {item.pointsEarned}/{item.pointTarget} {goalComplete && ''}
                        </span>
                      </button>
                      
                      {!isCollapsed && (
                        <div className="relative">
                          {/* Dotted connector line */}
                          <div style={{ 
                            position: 'absolute', 
                            left: '11px', 
                            top: 0, 
                            bottom: 0, 
                            width: '1px', 
                            borderLeft: `1px dashed ${item.categoryColor}50` 
                          }} />
                          {item.tasks.map((task, idx) => (
                            <div key={task.id} style={{ borderTop: `1px solid ${darkMode ? '#334155' : '#f1f5f9'}` }}>
                              {renderTaskRow(item.goal, task, true, idx === item.tasks.length - 1, true, item.categoryColor, true)}
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  );
                }
                
                // Handle single-task checkbox goals
                if (item.type === 'single') {
                  const task = item.tasks[0];
                  return (
                    <div key={item.goal.id} style={{ borderTop: itemIndex > 0 ? '4px solid' : 'none', borderTopColor: darkMode ? '#1e293b' : '#f1f5f9' }}>
                      {renderTaskRow(item.goal, task, true, true, false, item.categoryColor)}
                    </div>
                  );
                }
                
                // Handle multi-task checkbox goals (group)
                const isCelebratingGroup = groupCompletionAnim.has(`daily-${item.goal.id}`);
                return (
                  <div key={item.goal.id} style={{ 
                    borderTop: itemIndex > 0 ? '4px solid' : 'none', 
                    borderTopColor: darkMode ? '#1e293b' : '#f1f5f9',
                    transition: 'box-shadow 0.4s',
                    boxShadow: isCelebratingGroup ? 'inset 0 0 0 2px rgba(16,185,129,0.35)' : 'none',
                  }}>
                    <button 
                      onClick={() => toggleGoalCollapse(`daily-${item.goal.id}`)}
                      className="w-full px-3 py-2 flex items-center gap-2"
                      style={{ 
                        borderLeft: `3px solid ${borderColor}`, 
                        backgroundColor: isCelebratingGroup ? 'rgba(16,185,129,0.08)' : headerBg, 
                        boxShadow: headerShadow,
                        position: 'relative',
                        overflow: 'hidden',
                        transition: 'background-color 0.4s',
                      }}
                    >
                      {isCelebratingGroup && <div className="group-success-ripple" />}
                      <ChevronDown className={`w-4 h-4 ${theme.textMuted} transition-transform relative z-[1]`} style={{ transform: isCollapsed ? 'rotate(-90deg)' : 'rotate(0deg)', transition: 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)' }} />
                      <span className={`text-sm font-medium flex-1 text-left relative z-[1] ${goalComplete ? 'text-slate-600' : theme.textPrimary}`}>{item.goal.title}</span>
                      {goalComplete ? (
                        <span className={`text-xs font-bold text-emerald-500 bg-emerald-500/10 rounded px-1.5 py-0.5 relative z-[1] ${isCelebratingGroup ? 'badge-pop' : ''}`}>
                           Done
                        </span>
                      ) : (
                        <MiniProgressBar percentage={item.percentage} darkMode={darkMode} />
                      )}
                    </button>
                    
                    <div style={{
                      maxHeight: isCollapsed ? '0px' : '600px',
                      opacity: isCollapsed ? 0 : 1,
                      overflow: 'hidden',
                      transition: isCelebratingGroup
                        ? 'max-height 0.45s 0.6s ease-in-out, opacity 0.3s 0.5s'
                        : 'max-height 0.35s ease-in-out, opacity 0.25s ease-in-out',
                    }}>
                      <div className="relative">
                        {/* Dotted connector line */}
                        <div style={{ 
                          position: 'absolute', 
                          left: '11px', 
                          top: 0, 
                          bottom: 0, 
                          width: '1px', 
                          borderLeft: `1px dashed ${item.categoryColor}50` 
                        }} />
                        {item.tasks.map((task, idx) => (
                          <div key={task.id} style={{ borderTop: `1px solid ${darkMode ? '#334155' : '#f1f5f9'}` }}>
                            {renderTaskRow(item.goal, task, true, idx === item.tasks.length - 1, true, item.categoryColor)}
                          </div>
                        ))}
                      </div>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        )}

        {/* Empty State */}
        {dailyItems.length === 0 && (
          <div className={`${theme.cardBg} rounded-xl shadow-sm p-6 text-center`}>
            <p className={`text-sm ${theme.textMuted}`}>No daily tasks yet</p>
            <button onClick={() => setShowGoalForm(true)} className={`mt-2 text-sm font-medium ${darkMode ? 'text-slate-300' : 'text-slate-700'}`}>+ Add a goal</button>
          </div>
        )}

        {/* Weekly Tasks Section (including weekly points goals) */}
        {weeklyItems.length > 0 && (
          <div>
            <div className="flex items-center justify-between mb-2">
              <p className={`text-xs font-semibold uppercase tracking-wider ${theme.textMuted}`}>Weekly Tasks</p>
              <p className={`text-xs ${theme.textSecondary}`}>{weeklyOverallProgress.percentage}%</p>
            </div>

            <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
              <ProgressBar percentage={weeklyOverallProgress.percentage} darkMode={darkMode} />
              
              {weeklyItems.map((item, itemIndex) => {
                const isCollapsed = collapsedGoals.has(`weekly-${item.goal.id}`);
                const goalComplete = isGoalComplete(item);
                // Keep border color unfaded
                const borderColor = item.categoryColor;
                // A7 style for completed group headers
                const headerBg = goalComplete ? 'rgba(100, 116, 139, 0.12)' : 'transparent';
                const headerShadow = goalComplete ? 'inset 0 2px 4px rgba(0,0,0,0.04)' : 'none';
                
                // Handle points-type weekly goals
                if (item.type === 'points') {
                  return (
                    <div key={item.goal.id} style={{ borderTop: itemIndex > 0 ? '4px solid' : 'none', borderTopColor: darkMode ? '#1e293b' : '#f1f5f9' }}>
                      <button 
                        onClick={() => toggleGoalCollapse(`weekly-${item.goal.id}`)}
                        className="w-full px-3 py-2 flex items-center gap-2"
                        style={{ borderLeft: `3px solid ${borderColor}`, backgroundColor: headerBg, boxShadow: headerShadow }}
                      >
                        <ChevronDown className={`w-4 h-4 ${theme.textMuted} transition-transform ${isCollapsed ? '-rotate-90' : ''}`} />
                        <Star className="w-4 h-4 text-amber-500" />
                        <span className={`text-sm font-medium flex-1 text-left ${goalComplete ? 'text-slate-600' : theme.textPrimary}`}>{item.goal.title}</span>
                        <span className={`text-xs font-semibold ${goalComplete ? 'text-emerald-500' : theme.textSecondary}`}>
                          {item.pointsEarned}/{item.pointTarget} {goalComplete && ''}
                        </span>
                      </button>
                      
                      {!isCollapsed && (
                        <div className="relative">
                          {/* Dotted connector line */}
                          <div style={{ 
                            position: 'absolute', 
                            left: '11px', 
                            top: 0, 
                            bottom: 0, 
                            width: '1px', 
                            borderLeft: `1px dashed ${item.categoryColor}50` 
                          }} />
                          {item.tasks.map((task, idx) => (
                            <div key={task.id} style={{ borderTop: `1px solid ${darkMode ? '#334155' : '#f1f5f9'}` }}>
                              {renderTaskRow(item.goal, task, true, idx === item.tasks.length - 1, true, item.categoryColor, true)}
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  );
                }
                
                // Handle single-task checkbox goals
                if (item.type === 'single') {
                  const task = item.tasks[0];
                  return (
                    <div key={item.goal.id} style={{ borderTop: itemIndex > 0 ? '4px solid' : 'none', borderTopColor: darkMode ? '#1e293b' : '#f1f5f9' }}>
                      {renderTaskRow(item.goal, task, false, true, false, item.categoryColor)}
                    </div>
                  );
                }
                
                // Handle multi-task checkbox goals (group)
                const isCelebratingWeeklyGroup = groupCompletionAnim.has(`weekly-${item.goal.id}`);
                return (
                  <div key={item.goal.id} style={{ 
                    borderTop: itemIndex > 0 ? '4px solid' : 'none', 
                    borderTopColor: darkMode ? '#1e293b' : '#f1f5f9',
                    transition: 'box-shadow 0.4s',
                    boxShadow: isCelebratingWeeklyGroup ? 'inset 0 0 0 2px rgba(16,185,129,0.35)' : 'none',
                  }}>
                    <button 
                      onClick={() => toggleGoalCollapse(`weekly-${item.goal.id}`)}
                      className="w-full px-3 py-2 flex items-center gap-2"
                      style={{ 
                        borderLeft: `3px solid ${borderColor}`, 
                        backgroundColor: isCelebratingWeeklyGroup ? 'rgba(16,185,129,0.08)' : headerBg, 
                        boxShadow: headerShadow,
                        position: 'relative',
                        overflow: 'hidden',
                        transition: 'background-color 0.4s',
                      }}
                    >
                      {isCelebratingWeeklyGroup && <div className="group-success-ripple" />}
                      <ChevronDown className={`w-4 h-4 ${theme.textMuted} transition-transform relative z-[1]`} style={{ transform: isCollapsed ? 'rotate(-90deg)' : 'rotate(0deg)', transition: 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)' }} />
                      <span className={`text-sm font-medium flex-1 text-left relative z-[1] ${goalComplete ? 'text-slate-600' : theme.textPrimary}`}>{item.goal.title}</span>
                      {goalComplete ? (
                        <span className={`text-xs font-bold text-emerald-500 bg-emerald-500/10 rounded px-1.5 py-0.5 relative z-[1] ${isCelebratingWeeklyGroup ? 'badge-pop' : ''}`}>
                           Done
                        </span>
                      ) : (
                        <MiniProgressBar percentage={item.percentage} darkMode={darkMode} />
                      )}
                    </button>
                    
                    <div style={{
                      maxHeight: isCollapsed ? '0px' : '600px',
                      opacity: isCollapsed ? 0 : 1,
                      overflow: 'hidden',
                      transition: isCelebratingWeeklyGroup
                        ? 'max-height 0.45s 0.6s ease-in-out, opacity 0.3s 0.5s'
                        : 'max-height 0.35s ease-in-out, opacity 0.25s ease-in-out',
                    }}>
                      <div className="relative">
                        {/* Dotted connector line */}
                        <div style={{ 
                          position: 'absolute', 
                          left: '11px', 
                          top: 0, 
                          bottom: 0, 
                          width: '1px', 
                          borderLeft: `1px dashed ${item.categoryColor}50` 
                        }} />
                        {item.tasks.map((task, idx) => (
                          <div key={task.id} style={{ borderTop: `1px solid ${darkMode ? '#334155' : '#f1f5f9'}` }}>
                            {renderTaskRow(item.goal, task, false, idx === item.tasks.length - 1, true, item.categoryColor)}
                          </div>
                        ))}
                      </div>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        )}

        {/* Journal Section - Redesigned with card-per-prompt and insights */}
        <div>
          <div className="flex items-center justify-between mb-2">
            <div className="flex items-center gap-2">
              <p className={`text-xs font-semibold uppercase tracking-wider ${theme.textMuted}`}>Journal</p>
              {(() => {
                const filledCount = journalConfig.prompts.filter(prompt => {
                  const val = journalEntries[`${dateKey}-${prompt.id}`];
                  if (prompt.type === 'text') return val && val.trim().length > 0;
                  if (prompt.type === 'slider') return val !== undefined;
                  if (prompt.type === 'yesno') return val !== undefined;
                  return false;
                }).length;
                const totalCount = journalConfig.prompts.length;
                return totalCount > 0 ? (
                  <span className={`text-xs px-1.5 py-0.5 rounded-full ${
                    filledCount === totalCount 
                      ? 'bg-emerald-500/10 text-emerald-500' 
                      : `${darkMode ? 'bg-slate-700' : 'bg-slate-200'} ${theme.textSecondary}`
                  }`}>
                    {filledCount}/{totalCount}
                  </span>
                ) : null;
              })()}
            </div>
            <button onClick={() => setShowJournalSettings(true)} className={theme.textMuted}>
              <Settings className="w-4 h-4" />
            </button>
          </div>
          
          <div className="space-y-3">
            {/* Text prompts - individual cards */}
            {journalConfig.prompts.filter(p => p.type === 'text').map((prompt) => {
              const promptKey = `${dateKey}-${prompt.id}`;
              const value = journalEntries[promptKey] || '';
              const hasContent = value.trim().length > 0;
              
              // Helper to get previous day's value
              const getPrevValue = (daysAgo = 1) => {
                const prevDate = new Date(selectedDate);
                prevDate.setDate(prevDate.getDate() - daysAgo);
                return journalEntries[`${toLocalDateKey(prevDate)}-${prompt.id}`];
              };
              
              // Calculate writing streak
              let writeStreak = 0;
              for (let i = 1; i <= 30; i++) {
                const prev = getPrevValue(i);
                if (prev && prev.trim().length > 0) writeStreak++;
                else break;
              }
              if (hasContent) writeStreak++;
              
              // Get draft value from ref, or fall back to saved state
              const draftValue = journalDraftsRef.current[promptKey] !== undefined 
                ? journalDraftsRef.current[promptKey] 
                : value;
              
              return (
                <div key={prompt.id} className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
                  <div className={`px-3 py-2.5 flex items-center justify-between border-b ${darkMode ? 'border-slate-700/50' : 'border-slate-100'}`}>
                    <span className={`text-sm font-medium ${theme.textPrimary}`}>{prompt.label}</span>
                    {writeStreak >= 3 && (
                      <span className="text-xs flex items-center gap-1 text-orange-500">
                        <Flame className="w-3 h-3" />
                        {writeStreak} days
                      </span>
                    )}
                  </div>
                  <div className="p-3">
                    <textarea
                      defaultValue={draftValue}
                      onChange={(e) => { journalDraftsRef.current[promptKey] = e.target.value; }}
                      onBlur={(e) => {
                        setJournalEntries(prev => ({ ...prev, [promptKey]: e.target.value }));
                        delete journalDraftsRef.current[promptKey];
                      }}
                      placeholder={prompt.placeholder || 'Write here...'}
                      className={`w-full rounded-lg px-3 py-2.5 text-sm min-h-[100px] resize-none border ${theme.border} ${theme.inputBg} ${theme.textPrimary} focus:outline-none focus:ring-2 focus:ring-slate-300`}
                    />
                  </div>
                </div>
              );
            })}
            
            {/* Slider prompts - individual cards */}
            {journalConfig.prompts.filter(p => p.type === 'slider').map((prompt) => {
              const promptKey = `${dateKey}-${prompt.id}`;
              const currentValue = journalEntries[promptKey];
              const value = currentValue !== undefined ? currentValue : prompt.min || 0;
              const hasValue = currentValue !== undefined;
              
              // Helper to get previous day's value
              const getPrevValue = (daysAgo = 1) => {
                const prevDate = new Date(selectedDate);
                prevDate.setDate(prevDate.getDate() - daysAgo);
                return journalEntries[`${toLocalDateKey(prevDate)}-${prompt.id}`];
              };
              
              const yesterdayValue = getPrevValue(1);
              const min = prompt.min || 0;
              const max = prompt.max || 10;
              const percentage = ((value - min) / (max - min)) * 100;
              const gradientColor = percentage < 33 ? '#f97316' : percentage < 66 ? '#eab308' : '#22c55e';
              
              // Get 7-day trend data
              const trendData = [];
              for (let i = 6; i >= 0; i--) {
                trendData.push(getPrevValue(i) !== undefined ? getPrevValue(i) : null);
              }
              trendData.push(hasValue ? value : null);
              
              // Calculate 7-day average
              const validTrend = trendData.filter(d => d !== null);
              const average = validTrend.length > 0 ? (validTrend.reduce((a, b) => a + b, 0) / validTrend.length).toFixed(1) : null;
              
              // Comparison to yesterday
              let comparison = null;
              if (yesterdayValue !== undefined && hasValue) {
                const diff = value - yesterdayValue;
                if (diff > 0) comparison = { type: 'up', diff };
                else if (diff < 0) comparison = { type: 'down', diff: Math.abs(diff) };
                else comparison = { type: 'same' };
              }
              
              return (
                <div key={prompt.id} className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
                  <div className={`px-3 py-2.5 flex items-center justify-between border-b ${darkMode ? 'border-slate-700/50' : 'border-slate-100'}`}>
                    <span className={`text-sm font-medium ${theme.textPrimary}`}>{prompt.label}</span>
                    <MiniSparkline data={trendData.slice(0, 7)} color={gradientColor} />
                  </div>
                  <div className="p-3">
                    <div className="flex items-center gap-3">
                      <span className={`text-xs ${theme.textMuted}`}>{min}</span>
                      <div className="flex-1 relative">
                        {yesterdayValue !== undefined && (
                          <div 
                            className="absolute top-1/2 -translate-y-1/2 w-0.5 h-3 rounded-full bg-slate-400 opacity-40 z-0"
                            style={{ left: `${((yesterdayValue - min) / (max - min)) * 100}%` }}
                            title={`Yesterday: ${yesterdayValue}`}
                          />
                        )}
                        <input
                          type="range"
                          min={min}
                          max={max}
                          value={value}
                          onChange={(e) => setJournalEntries(prev => ({ ...prev, [promptKey]: parseInt(e.target.value) }))}
                          className="w-full h-2 rounded-full appearance-none cursor-pointer relative z-10"
                          style={{ 
                            background: `linear-gradient(to right, ${gradientColor} 0%, ${gradientColor} ${percentage}%, ${darkMode ? '#334155' : '#e2e8f0'} ${percentage}%, ${darkMode ? '#334155' : '#e2e8f0'} 100%)` 
                          }}
                        />
                      </div>
                      <span className={`text-xs ${theme.textMuted}`}>{max}</span>
                    </div>
                    <div className="flex items-center justify-center mt-2">
                      <span className="text-xl font-bold" style={{ color: gradientColor }}>{value}</span>
                    </div>
                  </div>
                  {(comparison || average) && (
                    <div className={`px-3 py-2 flex items-center justify-between border-t ${darkMode ? 'border-slate-700/50' : 'border-slate-100'}`} style={{ backgroundColor: darkMode ? 'rgba(51,65,85,0.3)' : 'rgba(248,250,252,0.8)' }}>
                      {comparison ? (
                        <span className={`text-xs flex items-center gap-1 ${
                          comparison.type === 'up' ? 'text-emerald-500' : 
                          comparison.type === 'down' ? 'text-amber-500' : 
                          theme.textMuted
                        }`}>
                          {comparison.type === 'up' && <ChevronUp className="w-3 h-3" />}
                          {comparison.type === 'down' && <ChevronDown className="w-3 h-3" />}
                          {comparison.type === 'same' && <Minus className="w-3 h-3" />}
                          {comparison.type === 'up' ? `+${comparison.diff}` : comparison.type === 'down' ? `-${comparison.diff}` : 'Same as'} yesterday
                        </span>
                      ) : <span />}
                      {average && (
                        <span className={`text-xs ${theme.textMuted}`}>7-day avg: {average}</span>
                      )}
                    </div>
                  )}
                </div>
              );
            })}
            
            {/* Yes/No prompts - grouped together in one card */}
            {(() => {
              const yesNoPrompts = journalConfig.prompts.filter(p => p.type === 'yesno');
              if (yesNoPrompts.length === 0) return null;
              
              // Helper to get previous day's value for a prompt
              const getPrevValue = (promptId, daysAgo = 1) => {
                const prevDate = new Date(selectedDate);
                prevDate.setDate(prevDate.getDate() - daysAgo);
                return journalEntries[`${toLocalDateKey(prevDate)}-${promptId}`];
              };
              
              // Calculate streak for a prompt
              const calculateStreak = (promptId) => {
                const value = journalEntries[`${dateKey}-${promptId}`];
                let streak = 0;
                let checkDate = new Date(selectedDate);
                
                if (value === undefined) {
                  // No entry today, start checking from yesterday
                  checkDate.setDate(checkDate.getDate() - 1);
                } else if (value !== 'yes') {
                  // Today is 'no', streak is 0
                  return { current: 0, wasStreak: getPrevValue(promptId, 1) === 'yes' };
                } else {
                  // Today is 'yes' - count 1 for today, then check backwards from yesterday
                  streak = 1;
                  checkDate.setDate(checkDate.getDate() - 1);
                }
                
                for (let i = 0; i < 365; i++) {
                  const checkKey = `${toLocalDateKey(checkDate)}-${promptId}`;
                  if (journalEntries[checkKey] === 'yes') {
                    streak++;
                    checkDate.setDate(checkDate.getDate() - 1);
                  } else {
                    break;
                  }
                }
                
                return { current: streak, wasStreak: false };
              };
              
              // Calculate weekly yes count for a prompt (last 7 days including today)
              const getWeeklyYesCount = (promptId) => {
                let count = 0;
                // i=0 is today, i=6 is 6 days ago (7 days total)
                for (let i = 0; i < 7; i++) {
                  if (getPrevValue(promptId, i) === 'yes') count++;
                }
                return count;
              };
              
              return (
                <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
                  {yesNoPrompts.map((prompt, index) => {
                    const promptKey = `${dateKey}-${prompt.id}`;
                    const value = journalEntries[promptKey];
                    const streak = calculateStreak(prompt.id);
                    const weeklyYes = getWeeklyYesCount(prompt.id);
                    const isLast = index === yesNoPrompts.length - 1;
                    
                    return (
                      <div 
                        key={prompt.id} 
                        className={`px-3 py-2 flex items-center gap-2 ${!isLast ? `border-b ${darkMode ? 'border-slate-700/50' : 'border-slate-100'}` : ''}`}
                      >
                        <span className={`text-sm flex-1 truncate ${theme.textPrimary}`}>{prompt.label}</span>
                        {/* Streak indicator - compact */}
                        {streak.current >= 2 && value === 'yes' && (
                          <span className="text-xs text-orange-500 flex items-center gap-0.5 flex-shrink-0">
                            <Flame className="w-3 h-3" />
                            {streak.current}
                          </span>
                        )}
                        {streak.wasStreak && (
                          <span className="text-xs text-rose-500 flex-shrink-0">!</span>
                        )}
                        <span className={`text-xs w-6 text-right flex-shrink-0 ${theme.textMuted}`}>{weeklyYes}/7</span>
                        <div className="flex items-center gap-1 flex-shrink-0">
                          <button
                            onClick={() => setJournalEntries(prev => ({ ...prev, [promptKey]: value === 'yes' ? undefined : 'yes' }))}
                            className={`w-6 h-6 rounded flex items-center justify-center transition-all ${
                              value === 'yes'
                                ? 'bg-emerald-500 text-white'
                                : `${theme.inputBg} ${theme.textMuted} hover:text-emerald-500`
                            }`}
                          >
                            <Check className="w-3.5 h-3.5" />
                          </button>
                          <button
                            onClick={() => setJournalEntries(prev => ({ ...prev, [promptKey]: value === 'no' ? undefined : 'no' }))}
                            className={`w-6 h-6 rounded flex items-center justify-center transition-all ${
                              value === 'no'
                                ? 'bg-rose-500 text-white'
                                : `${theme.inputBg} ${theme.textMuted} hover:text-rose-500`
                            }`}
                          >
                            <X className="w-3.5 h-3.5" />
                          </button>
                        </div>
                      </div>
                    );
                  })}
                </div>
              );
            })()}
            
            {journalConfig.prompts.length === 0 && (
              <div className={`${theme.cardBg} rounded-xl shadow-sm p-6 text-center`}>
                <p className={`text-sm ${theme.textMuted} mb-2`}>No journal prompts</p>
                <button onClick={() => setShowJournalSettings(true)} className={`text-sm font-medium ${darkMode ? 'text-slate-300' : 'text-slate-700'}`}>
                  + Add prompts
                </button>
              </div>
            )}
          </div>
        </div>

        {/* Photo of the Day */}
        <div>
          <p className={`text-xs font-semibold uppercase tracking-wider mb-2 ${theme.textMuted}`}>Photo of the Day</p>
          {dailyPhotos[dateKey] ? (
            <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden relative`}>
              <img src={dailyPhotos[dateKey]} alt="Photo of the day" className="w-full h-40 object-cover" />
              <button onClick={() => removeDailyPhoto(dateKey)} className="absolute top-2 right-2 p-1.5 bg-red-500 hover:bg-red-600 rounded-lg">
                <Trash2 className="w-3.5 h-3.5 text-white" />
              </button>
            </div>
          ) : (
            <div className={`${theme.cardBg} rounded-xl shadow-sm p-4 border-2 border-dashed ${theme.border} flex items-center justify-center`}>
              <label className="text-center cursor-pointer">
                <Camera className={`w-6 h-6 mx-auto mb-1 ${theme.textMuted}`} />
                <p className={`text-xs ${theme.textMuted}`}>Add photo</p>
                <input type="file" accept="image/*" className="hidden" onChange={(e) => {
                  const file = e.target.files[0];
                  if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => updateDailyPhoto(dateKey, reader.result);
                    reader.readAsDataURL(file);
                  }
                }} />
              </label>
            </div>
          )}
        </div>

        {/* Media Section */}
        <div>
          <div className="flex items-center justify-between mb-2">
            <p className={`text-xs font-semibold uppercase tracking-wider ${theme.textMuted}`}>Media</p>
            <button onClick={() => setShowMediaForm(true)} className={`w-6 h-6 rounded-full ${theme.btnPrimary} flex items-center justify-center`}>
              <Plus className="w-3 h-3" />
            </button>
          </div>
          {todayMedia.length === 0 ? (
            <div className={`${theme.cardBg} rounded-xl shadow-sm p-4 text-center`}>
              <p className={`text-xs ${theme.textMuted}`}>No media logged today</p>
            </div>
          ) : (
            <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
              {todayMedia.map((item, index) => (
                <div key={item.id} className={`flex items-center gap-3 px-3 py-2.5 group ${index !== todayMedia.length - 1 ? `border-b ${theme.divider}` : ''}`}>
                  <div className={`w-7 h-7 rounded flex items-center justify-center ${theme.inputBg}`}>
                    {item.type === 'book' && <Book className={`w-3.5 h-3.5 ${theme.textSecondary}`} />}
                    {item.type === 'music' && <Music className={`w-3.5 h-3.5 ${theme.textSecondary}`} />}
                    {item.type === 'movie' && <Film className={`w-3.5 h-3.5 ${theme.textSecondary}`} />}
                  </div>
                  <div className="flex-1 min-w-0">
                    <p className={`text-sm truncate ${theme.textPrimary}`}>{item.title}</p>
                    {item.notes && <p className={`text-xs truncate ${theme.textMuted}`}>{item.notes}</p>}
                  </div>
                  <button onClick={() => removeMedia(dateKey, item.id)} className="opacity-0 group-hover:opacity-100 p-1 hover:bg-red-500/10 rounded">
                    <Trash2 className="w-3.5 h-3.5 text-red-500" />
                  </button>
                </div>
              ))}
            </div>
          )}

          {/* Media Form Modal */}
          {showMediaForm && (
            <div className="fixed inset-0 bg-black/30 backdrop-blur-sm flex items-center justify-center z-50 p-4">
              <div className={`${theme.cardBg} rounded-2xl p-5 w-full max-w-md shadow-xl`}>
                <h4 className={`text-base font-semibold mb-4 ${theme.textPrimary}`}>Add Media</h4>
                <div className="space-y-3">
                  <div>
                    <label className={`block text-xs font-medium mb-1 ${theme.textMuted}`}>Type</label>
                    <select value={mediaForm.type} onChange={(e) => setMediaForm({ ...mediaForm, type: e.target.value })} className={`w-full rounded-lg px-3 py-2 text-sm ${theme.inputBg} ${theme.textPrimary}`}>
                      <option value="book">Book</option>
                      <option value="music">Album</option>
                      <option value="movie">Movie</option>
                    </select>
                  </div>
                  <div>
                    <label className={`block text-xs font-medium mb-1 ${theme.textMuted}`}>Title</label>
                    <input type="text" value={mediaForm.title} onChange={(e) => setMediaForm({ ...mediaForm, title: e.target.value })} className={`w-full rounded-lg px-3 py-2 text-sm ${theme.inputBg} ${theme.textPrimary}`} placeholder="Enter title..." />
                  </div>
                  <div>
                    <label className={`block text-xs font-medium mb-1 ${theme.textMuted}`}>Notes (optional)</label>
                    <textarea value={mediaForm.notes} onChange={(e) => setMediaForm({ ...mediaForm, notes: e.target.value })} className={`w-full rounded-lg px-3 py-2 text-sm ${theme.inputBg} ${theme.textPrimary}`} rows="2" placeholder="Your thoughts..." />
                  </div>
                </div>
                <div className="flex gap-2 mt-4">
                  <button onClick={() => { if (mediaForm.title) { addMedia(dateKey, mediaForm); setMediaForm({ type: 'book', title: '', notes: '' }); setShowMediaForm(false); } }} className={`flex-1 py-2 rounded-lg text-sm font-medium ${theme.btnPrimary}`}>Add</button>
                  <button onClick={() => { setShowMediaForm(false); setMediaForm({ type: 'book', title: '', notes: '' }); }} className={`px-4 py-2 rounded-lg text-sm font-medium ${theme.btnSecondary}`}>Cancel</button>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>
    );
  };

  // ============================================
  // GOALS VIEW - Goal management & per-goal stats
  // ============================================
  const GoalsView = () => {
    const [expandedGoal, setExpandedGoal] = useState(null);
    const [collapsedCats, setCollapsedCats] = useState(new Set());

    const toggleCat = (catId) => {
      setCollapsedCats(prev => {
        const n = new Set(prev);
        n.has(catId) ? n.delete(catId) : n.add(catId);
        return n;
      });
    };

    // Calculate goal-level streak (all daily/scheduled tasks completed)
    const calculateGoalStreak = useCallback((goal) => {
      if (!goal.tasks || !Array.isArray(goal.tasks)) return { current: 0, longest: 0 };
      
      const dailyScheduledTasks = goal.tasks.filter(t => 
        !t.frequency || t.frequency === 'daily' || t.frequency === 'scheduled'
      );
      if (dailyScheduledTasks.length === 0) return { current: 0, longest: 0 };

      const isGoalCompletedOnDate = (date) => {
        const dk = toLocalDateKey(date);
        const tasks = dailyTasks[dk] || {};
        let hadAnyTask = false;
        for (const task of dailyScheduledTasks) {
          const isScheduled = task.frequency === 'scheduled';
          if (isScheduled && !isTaskScheduledForDate(task, date)) continue;
          hadAnyTask = true;
          const checks = task.dailyChecks || 1;
          for (let i = 0; i < checks; i++) {
            if (!tasks[`${goal.id}-${task.id}-${i}`]) return false;
          }
        }
        return hadAnyTask;
      };

      const today = new Date();
      today.setHours(12, 0, 0, 0);
      
      // Current streak
      let current = 0;
      let checkDate = new Date(today);
      if (isGoalCompletedOnDate(checkDate)) {
        current = 1;
        checkDate.setDate(checkDate.getDate() - 1);
        while (current < 365) {
          if (isGoalCompletedOnDate(checkDate)) {
            current++;
            checkDate.setDate(checkDate.getDate() - 1);
          } else break;
        }
      } else {
        checkDate.setDate(checkDate.getDate() - 1);
        while (current < 365) {
          if (isGoalCompletedOnDate(checkDate)) {
            current++;
            checkDate.setDate(checkDate.getDate() - 1);
          } else break;
        }
      }

      // Longest streak
      const goalStart = goal.createdAt ? new Date(goal.createdAt) : new Date(today.getFullYear(), 0, 1);
      goalStart.setHours(12, 0, 0, 0);
      let longest = 0;
      let runningStreak = 0;
      const scanDate = new Date(goalStart);
      while (scanDate <= today) {
        if (isGoalCompletedOnDate(scanDate)) {
          runningStreak++;
          if (runningStreak > longest) longest = runningStreak;
        } else {
          runningStreak = 0;
        }
        scanDate.setDate(scanDate.getDate() + 1);
      }

      return { current, longest };
    }, [dailyTasks, isTaskScheduledForDate]);

    // Calculate days active for a goal
    const calculateDaysActive = useCallback((goal) => {
      if (!goal.tasks || !Array.isArray(goal.tasks)) return 0;
      const today = new Date();
      const goalStart = goal.createdAt ? new Date(goal.createdAt) : new Date(today.getFullYear(), 0, 1);
      goalStart.setHours(0, 0, 0, 0);
      today.setHours(23, 59, 59, 999);
      
      let activeDays = 0;
      const d = new Date(goalStart);
      while (d <= today) {
        const dk = toLocalDateKey(d);
        const tasks = dailyTasks[dk] || {};
        const hasAny = Object.keys(tasks).some(key => key.startsWith(`${goal.id}-`) && tasks[key]);
        if (hasAny) activeDays++;
        d.setDate(d.getDate() + 1);
      }
      return activeDays;
    }, [dailyTasks]);

    // Completion rate from goalProgressCache (uses createdAt)
    const getCompletionRate = useCallback((goal) => {
      return goalProgressCache[goal.id]?.percentage || 0;
    }, [goalProgressCache]);

    // Separate active and archived goals
    const activeGoals = goals.filter(g => !g.archived);
    const archivedGoals = goals.filter(g => g.archived);
    const [showArchived, setShowArchived] = useState(false);

    // Group active goals by category
    const groupedGoals = (categories || []).map(cat => ({
      ...cat,
      goals: activeGoals.filter(g => g.category === cat.id)
    })).filter(c => c.goals.length > 0);

    const uncategorizedGoals = activeGoals.filter(g => !(categories || []).some(c => c.id === g.category));

    // Render a goal row + expanded detail
    const GoalItem = ({ goal, catColor, isLast }) => {
      const isExpanded = expandedGoal === goal.id;
      const completionRate = getCompletionRate(goal);
      const streaks = calculateGoalStreak(goal);
      const color = catColor || '#94a3b8';

      // Calculate all-time time invested
      const timeInvested = (() => {
        let total = 0;
        if (!goal.tasks) return 0;
        goal.tasks.forEach(task => {
          const est = task.timeEstimate || 0;
          if (!est) return;
          const checks = task.dailyChecks || 1;
          Object.keys(dailyTasks).forEach(dateKey => {
            for (let c = 0; c < checks; c++) {
              if (dailyTasks[dateKey]?.[`${goal.id}-${task.id}-${c}`]) total += est;
            }
          });
        });
        return total;
      })();
      const fmtTimeInvested = (m) => {
        if (m >= 60) { const h = Math.floor(m / 60); const mm = m % 60; return mm > 0 ? `${h}h ${mm}m` : `${h}h`; }
        return `${m}m`;
      };

      return (
        <div>
          {/* Goal row */}
          <button
            onClick={() => setExpandedGoal(isExpanded ? null : goal.id)}
            className={`w-full px-3.5 py-3 text-left flex items-center gap-3 ${
              !isLast && !isExpanded ? `border-b ${theme.divider}` : ''
            }`}
          >
            <div className="flex-1 min-w-0">
              <div className={`text-sm font-semibold ${theme.textPrimary} truncate`}>{goal.title}</div>
              <div className={`text-[11px] ${theme.textMuted} flex items-center gap-2 mt-0.5`}>
                <span>{(goal.tasks || []).length} task{(goal.tasks || []).length !== 1 ? 's' : ''}</span>
                {streaks.current >= 3 && (
                  <span className="flex items-center gap-0.5">
                    <Flame className="w-3 h-3" style={{ color: '#f97316' }} />
                    <span>{streaks.current}d</span>
                  </span>
                )}
              </div>
            </div>
            <div className="relative flex-shrink-0" style={{ width: 38, height: 38 }}>
              <svg width="38" height="38" viewBox="0 0 38 38">
                <circle cx="19" cy="19" r="15" fill="none" stroke={darkMode ? '#334155' : '#f1f5f9'} strokeWidth="3" />
                <circle cx="19" cy="19" r="15" fill="none" stroke={color} strokeWidth="3"
                  strokeDasharray={`${completionRate * 0.94} 94`}
                  strokeLinecap="round"
                  transform="rotate(-90 19 19)"
                  style={{ transition: 'stroke-dasharray 0.5s' }}
                />
              </svg>
              <div className="absolute inset-0 flex items-center justify-center">
                <span className={`text-[10px] font-bold ${theme.textPrimary}`}>{completionRate}%</span>
              </div>
            </div>
          </button>

          {/* Expanded detail */}
          {isExpanded && (
            <div className={`px-3.5 pb-3.5 ${!isLast ? `border-b ${theme.divider}` : ''}`}>
              {/* Target */}
              {goal.yearlyGoal && (
                <div className={`p-2.5 rounded-lg mb-3 ${theme.inputBg}`}>
                  <div className={`text-[9px] font-semibold uppercase tracking-wider mb-1 ${theme.textMuted}`}>Target</div>
                  <div className={`text-[13px] font-semibold ${theme.textSecondary}`}>{goal.yearlyGoal}</div>
                </div>
              )}

              {/* Stats */}
              <div className="flex gap-1.5 mb-3">
                {[
                  { value: `${streaks.current}d`, label: 'Streak', highlight: streaks.current >= 5 },
                  { value: `${streaks.longest}d`, label: 'Best' },
                  { value: `${calculateDaysActive(goal)}`, label: 'Days active' },
                  ...(timeInvested > 0 ? [{ value: fmtTimeInvested(timeInvested), label: 'Time invested' }] : []),
                ].map((s, i) => (
                  <div key={i} className="flex-1 text-center py-2 rounded-lg" style={{
                    background: s.highlight ? `${color}15` : (darkMode ? '#1e293b' : '#f8fafc'),
                    border: s.highlight ? `1px solid ${color}30` : '1px solid transparent'
                  }}>
                    <div className="text-sm font-bold" style={{ color: s.highlight ? color : (darkMode ? '#e2e8f0' : '#1e293b') }}>{s.value}</div>
                    <div className={`text-[9px] ${theme.textMuted}`}>{s.label}</div>
                  </div>
                ))}
              </div>

              {/* Tasks */}
              <div className="mb-3">
                <div className={`text-[9px] font-semibold uppercase tracking-wider mb-1.5 ${theme.textMuted}`}>Tasks</div>
                {(goal.tasks || []).map((task, ti) => (
                  <div key={task.id} className={`flex items-center gap-2 py-1.5 ${
                    ti < (goal.tasks || []).length - 1 ? `border-b ${theme.divider}` : ''
                  }`}>
                    <div className="w-1 h-1 rounded-full flex-shrink-0" style={{ backgroundColor: color, opacity: 0.5 }} />
                    <span className={`text-xs flex-1 ${theme.textSecondary}`}>{task.action}</span>
                    <span className={`text-[10px] px-1.5 py-0.5 rounded ${theme.inputBg} ${theme.textMuted}`}>
                      {task.frequency === 'daily' ? (task.dailyChecks > 1 ? `${task.dailyChecks}x/day` : 'daily')
                        : task.frequency === 'weekly' ? `${task.weeklyTarget || 4}x/wk`
                        : task.frequency === 'scheduled' ? `${(task.scheduledDays || []).length}d/wk`
                        : task.frequency}
                    </span>
                  </div>
                ))}
              </div>

              {/* Created date */}
              {goal.createdAt && (
                <p className={`text-[10px] mb-3 ${theme.textMuted}`}>
                  Created {new Date(goal.createdAt).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}
                </p>
              )}

              {/* Actions */}
              <div className="flex gap-2">
                <button onClick={(e) => { e.stopPropagation(); setEditingGoal(goal); }} className={`flex-1 py-2 rounded-lg text-xs font-semibold ${theme.btnSecondary}`}>Edit</button>
                <button onClick={(e) => { e.stopPropagation(); archiveGoal(goal.id); setExpandedGoal(null); }} className="px-4 py-2 rounded-lg text-xs font-semibold" style={{ background: darkMode ? '#1e3a5f' : '#eff6ff', color: '#3b82f6' }}>Complete</button>
                {deletingGoalId === goal.id ? (
                  <button onClick={(e) => { e.stopPropagation(); deleteGoal(goal.id); setDeletingGoalId(null); setExpandedGoal(null); }} className="px-4 py-2 rounded-lg text-xs font-semibold bg-red-500 text-white">Confirm</button>
                ) : (
                  <button onClick={(e) => { e.stopPropagation(); setDeletingGoalId(goal.id); }} className="px-4 py-2 rounded-lg text-xs font-semibold" style={{ background: darkMode ? '#451a1a' : '#fef2f2', color: '#ef4444' }}>Delete</button>
                )}
              </div>
            </div>
          )}
        </div>
      );
    };

    return (
      <div className="space-y-3">
        {/* Header */}
        <div className="flex items-center justify-between py-2">
          <div>
            <h2 className={`text-lg font-semibold ${theme.textPrimary}`}>Goals</h2>
            <p className={`text-xs ${theme.textMuted}`}>{activeGoals.length} active goal{activeGoals.length !== 1 ? 's' : ''}</p>
          </div>
          <button onClick={() => setShowCategorySettings(true)} className={`p-2 rounded-lg ${theme.btnSecondary}`}>
            <Settings className="w-4 h-4" />
          </button>
        </div>

        {activeGoals.length === 0 && archivedGoals.length === 0 ? (
          <div className={`${theme.cardBg} rounded-xl shadow-sm p-8 text-center`}>
            <Target className={`w-10 h-10 mx-auto mb-3 ${theme.textMuted}`} />
            <h3 className={`text-sm font-semibold mb-1 ${theme.textPrimary}`}>No goals yet</h3>
            <p className={`text-xs mb-4 ${theme.textMuted}`}>Create your first goal to start tracking</p>
            <button onClick={() => setShowGoalForm(true)} className={`px-4 py-2 rounded-lg text-sm font-medium ${theme.btnPrimary}`}>Create Goal</button>
          </div>
        ) : (
          <>
            {groupedGoals.map(cat => {
              const isCollapsed = collapsedCats.has(cat.id);
              return (
                <div key={cat.id}>
                  <button
                    onClick={() => toggleCat(cat.id)}
                    className="flex items-center gap-2 mb-2 w-full px-1"
                    style={{ background: 'none', border: 'none' }}
                  >
                    <div className="w-2 h-2 rounded-full flex-shrink-0" style={{ backgroundColor: cat.color }} />
                    <span className={`text-[11px] font-bold uppercase tracking-wider flex-1 text-left ${theme.textMuted}`}>{cat.name}</span>
                    <span className={`text-xs ${theme.textMuted}`}>{cat.goals.length}</span>
                    <ChevronRight className={`w-3 h-3 ${theme.textMuted} transition-transform ${isCollapsed ? '' : 'rotate-90'}`} />
                  </button>

                  {!isCollapsed && (
                    <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden mb-3`}>
                      {cat.goals.map((goal, gi) => (
                        <GoalItem key={goal.id} goal={goal} catColor={cat.color} isLast={gi === cat.goals.length - 1} />
                      ))}
                    </div>
                  )}
                </div>
              );
            })}

            {uncategorizedGoals.length > 0 && (
              <div>
                <div className="flex items-center gap-2 mb-2 px-1">
                  <span className={`text-[11px] font-bold uppercase tracking-wider ${theme.textMuted}`}>Uncategorized</span>
                </div>
                <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden mb-3`}>
                  {uncategorizedGoals.map((goal, gi) => (
                    <GoalItem key={goal.id} goal={goal} catColor="#94a3b8" isLast={gi === uncategorizedGoals.length - 1} />
                  ))}
                </div>
              </div>
            )}

            {/* Completed/Archived Goals Section */}
            {archivedGoals.length > 0 && (
              <div className="mt-6">
                <button
                  onClick={() => setShowArchived(!showArchived)}
                  className="flex items-center gap-2 mb-2 w-full px-1"
                  style={{ background: 'none', border: 'none' }}
                >
                  <Check className="w-3 h-3" style={{ color: '#22c55e' }} />
                  <span className={`text-[11px] font-bold uppercase tracking-wider flex-1 text-left ${theme.textMuted}`}>Completed</span>
                  <span className={`text-xs ${theme.textMuted}`}>{archivedGoals.length}</span>
                  <ChevronRight className={`w-3 h-3 ${theme.textMuted} transition-transform ${showArchived ? 'rotate-90' : ''}`} />
                </button>

                {showArchived && (
                  <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
                    {archivedGoals.map((goal, gi) => {
                      const catColor = (categories || []).find(c => c.id === goal.category)?.color || '#94a3b8';
                      const completionRate = getCompletionRate(goal);
                      return (
                        <div key={goal.id} className={`px-3.5 py-3 ${gi < archivedGoals.length - 1 ? `border-b ${theme.divider}` : ''}`}>
                          <div className="flex items-center gap-3">
                            <div className="flex-1 min-w-0">
                              <div className={`text-sm font-semibold ${theme.textSecondary} truncate`}>{goal.title}</div>
                              <div className={`text-[11px] ${theme.textMuted} flex items-center gap-2 mt-0.5`}>
                                <span>{completionRate}% completion</span>
                                {goal.archivedAt && (
                                  <span> Completed {new Date(goal.archivedAt).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}</span>
                                )}
                              </div>
                            </div>
                            <div className="flex gap-2">
                              <button 
                                onClick={() => unarchiveGoal(goal.id)} 
                                className={`px-3 py-1.5 rounded-lg text-[11px] font-semibold ${theme.btnSecondary}`}
                              >
                                Restore
                              </button>
                              <button 
                                onClick={() => deleteGoal(goal.id)} 
                                className="px-3 py-1.5 rounded-lg text-[11px] font-semibold"
                                style={{ background: darkMode ? '#451a1a' : '#fef2f2', color: '#ef4444' }}
                              >
                                Delete
                              </button>
                            </div>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                )}
              </div>
            )}
          </>
        )}
      </div>
    );
  };


  // ============================================
  // MAIN RENDER
  // ============================================
  if (!isLoaded) {
    return (
      <div className={`min-h-screen flex items-center justify-center ${theme.pageBg}`}>
        <p className={theme.textMuted}>Loading...</p>
      </div>
    );
  }

  return (
    <div className={`min-h-screen ${theme.pageBg} font-sans`}>
      <style>{`
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        * { font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; }
        input[type="range"]::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
          width: 14px;
          height: 14px;
          border-radius: 50%;
          background: ${darkMode ? '#e2e8f0' : '#334155'};
          cursor: pointer;
        }
        @keyframes taskLeftGlow {
          0% { opacity: 0; }
          20% { opacity: 1; }
          100% { opacity: 0; }
        }
        @keyframes taskRippleExpand {
          0% { transform: translate(50%, -50%) scale(0); opacity: 1; }
          100% { transform: translate(50%, -50%) scale(1); opacity: 0; }
        }
        @keyframes ripplePop {
          0% { transform: scale(1); }
          30% { transform: scale(0.7); }
          60% { transform: scale(1.15); }
          100% { transform: scale(1); }
        }
        @keyframes slideSettle {
          0% { transform: translateX(0); }
          15% { transform: translateX(-3px); }
          50% { transform: translateX(1.5px); }
          100% { transform: translateX(0); }
        }
        @keyframes groupRipple {
          0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
          100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }
        @keyframes badgePop {
          0% { transform: scale(0); opacity: 0; }
          60% { transform: scale(1.2); opacity: 1; }
          100% { transform: scale(1); opacity: 1; }
        }
        @keyframes goldShimmer {
          0% { background-position: 200% 0; }
          100% { background-position: -200% 0; }
        }
        @keyframes trophySpin {
          0% { transform: scale(0) rotate(-30deg); opacity: 0; }
          50% { transform: scale(1.3) rotate(10deg); opacity: 1; }
          100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        .task-left-glow {
          position: absolute; left: 0; top: 0; bottom: 0; width: 100%;
          background: linear-gradient(90deg, rgba(16,185,129,0.18) 0%, rgba(16,185,129,0.06) 35%, transparent 70%);
          animation: taskLeftGlow 0.8s ease-out forwards;
          pointer-events: none; z-index: 0;
        }
        .task-ripple-overlay {
          position: absolute; right: 24px; top: 50%;
          width: 400px; height: 400px; border-radius: 50%;
          background: radial-gradient(circle, rgba(16,185,129,0.14) 0%, transparent 65%);
          transform: translate(50%, -50%) scale(0);
          animation: taskRippleExpand 0.7s ease-out forwards;
          pointer-events: none; z-index: 0;
        }
        .task-slide-settle { animation: slideSettle 0.5s ease-out; }
        .checkbox-ripple-pop { animation: ripplePop 0.4s ease-out; }
        .group-success-ripple {
          position: absolute; left: 50%; top: 50%;
          width: 500px; height: 500px; border-radius: 50%;
          background: radial-gradient(circle, rgba(16,185,129,0.18) 0%, transparent 65%);
          transform: translate(-50%, -50%) scale(0);
          animation: groupRipple 1s ease-out forwards;
          pointer-events: none;
        }
        .badge-pop { animation: badgePop 0.4s 0.2s ease-out both; }
        .gold-shimmer-bar {
          background: linear-gradient(90deg, #f59e0b, #fbbf24, #f59e0b);
          background-size: 200% 100%;
          animation: goldShimmer 1s ease-in-out infinite;
        }
        .trophy-spin { animation: trophySpin 0.6s ease-out; }
      `}</style>
      
      {/* Sticky Header */}
      <div className={`sticky top-0 z-40 ${theme.headerBg} backdrop-blur-sm border-b ${theme.border}`}>
        <div className="max-w-lg mx-auto px-4 py-3">
          <div className="flex items-center justify-between">
            <h1 className={`text-lg font-semibold tracking-tight ${theme.textPrimary}`}>Life Tracker</h1>
            <div className="flex gap-2">
              <button onClick={() => setDarkMode(!darkMode)} className={`w-8 h-8 rounded-full ${theme.btnIcon} shadow-sm flex items-center justify-center`}>
                {darkMode ? <Sun className="w-4 h-4" /> : <Moon className="w-4 h-4" />}
              </button>
              <button onClick={() => setShowGoalForm(true)} className={`w-8 h-8 rounded-full ${theme.btnPrimary} shadow-sm flex items-center justify-center`}>
                <Plus className="w-4 h-4" />
              </button>
            </div>
          </div>

          {/* Navigation Pills */}
          <div className="mt-3">
            <div className={`flex gap-1 ${theme.cardBg} rounded-full p-1 shadow-sm w-fit`}>
              <button onClick={() => setCurrentView('daily')} className={`px-4 py-1.5 text-xs font-medium rounded-full transition-all ${currentView === 'daily' ? theme.btnPrimary : theme.textSecondary}`}>Daily</button>
              <button onClick={() => setCurrentView('calendar')} className={`px-4 py-1.5 text-xs font-medium rounded-full transition-all ${currentView === 'calendar' ? theme.btnPrimary : theme.textSecondary}`}>Calendar</button>
              <button onClick={() => setCurrentView('goals')} className={`px-4 py-1.5 text-xs font-medium rounded-full transition-all ${currentView === 'goals' ? theme.btnPrimary : theme.textSecondary}`}>Goals</button>
            </div>
          </div>
        </div>
      </div>

      {/* Main Content */}
      <div className="max-w-lg mx-auto px-4 py-4 pb-8">
        {currentView === 'daily' && DailyView()}
        {currentView === 'calendar' && <CalendarView />}
        {currentView === 'goals' && <GoalsView />}
      </div>

      {/* Modals */}
      {showGoalForm && <GoalForm onSave={addGoal} onCancel={() => setShowGoalForm(false)} />}
      {editingGoal && <GoalForm goal={editingGoal} onSave={(updates) => updateGoal(editingGoal.id, updates)} onCancel={() => setEditingGoal(null)} />}
      {showCompletionModal && <TaskCompletionModal onSave={(note, photo) => saveTaskCompletion(showCompletionModal.dateKey, showCompletionModal.goalId, showCompletionModal.taskId, showCompletionModal.checkIndex, note, photo)} onCancel={() => setShowCompletionModal(null)} taskName={showCompletionModal.task?.action || 'Task'} />}
      {viewingCompletion && <ViewCompletionModal completion={viewingCompletion.completion} taskName={viewingCompletion.taskName} onClose={() => setViewingCompletion(null)} />}
      {showJournalSettings && <JournalSettingsModal config={journalConfig} onSave={(newConfig) => { setJournalConfig(newConfig); setShowJournalSettings(false); }} onCancel={() => setShowJournalSettings(false)} />}
      {showCategorySettings && <CategorySettingsModal categories={categories} onSave={(newCategories) => { setCategories(newCategories); setShowCategorySettings(false); }} onCancel={() => setShowCategorySettings(false)} />}
    </div>
  );
};



    try {
      if (ReactDOM.createRoot) {
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(GoalTrackerApp));
      } else {
        ReactDOM.render(React.createElement(GoalTrackerApp), document.getElementById('root'));
      }
    } catch(e) {
      console.error('Render error:', e);
      document.getElementById('root').innerHTML = '<div style="padding:20px;color:red;font-family:monospace"><h2>Error loading app</h2><pre>' + e.message + '\n' + e.stack + '</pre></div>';
    }
  </script>
</body>
</html>
