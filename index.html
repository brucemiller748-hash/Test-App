<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="mobile-web-app-capable" content="yes">
  <title>Life Tracker</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/lucide-react@0.263.1/dist/umd/lucide-react.min.js"></script>
  <style>
    * { -webkit-tap-highlight-color: transparent; }
    body { margin: 0; overscroll-behavior: none; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Inter', sans-serif; }
    @supports (padding-top: env(safe-area-inset-top)) {
      .safe-top { padding-top: env(safe-area-inset-top); }
      .safe-bottom { padding-bottom: env(safe-area-inset-bottom); }
    }
    input[type="range"] { -webkit-appearance: none; appearance: none; background: transparent; cursor: pointer; touch-action: pan-x; }
    input[type="range"]::-webkit-slider-runnable-track { height: 6px; border-radius: 3px; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; margin-top: -7px; }
    .touch-pan-y { touch-action: pan-y; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel" data-presets="react">
import React, { useState, useEffect, useMemo, useCallback, useRef } from 'react';
import { Camera, Book, Music, Film, Target, CheckCircle2, Check, Circle, Plus, Minus, X, ChevronLeft, ChevronRight, ChevronUp, Trash2, Settings, Sun, Moon, ChevronDown, Star, Flame, Zap, Clock, Heart, Trophy, Sliders, Hash } from 'lucide-react';

// Format date to YYYY-MM-DD using LOCAL time (not UTC)
// This prevents the bug where late-night entries get saved to the wrong day
const toLocalDateKey = (date) => {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
};

// Haptic feedback helper
const triggerHaptic = () => {
  if (navigator.vibrate) {
    navigator.vibrate([15, 40, 50]); // Success pattern
  }
};

// Get progress bar color based on percentage
const getProgressColor = (percentage) => {
  if (percentage < 50) return '#f97316'; // orange
  if (percentage < 75) return '#eab308'; // yellow
  const greenProgress = (percentage - 75) / 25;
  const r = Math.round(134 - (134 - 34) * greenProgress);
  const g = Math.round(239 - (239 - 197) * greenProgress);
  const b = Math.round(172 - (172 - 94) * greenProgress);
  return `rgb(${r}, ${g}, ${b})`;
};

// Progress bar component - MUST be outside main component for stable React reference
const ProgressBar = React.memo(({ percentage, darkMode }) => {
  const color = getProgressColor(percentage);
  const bgColor = darkMode ? '#334155' : '#e2e8f0';
  
  return (
    <div style={{ height: '6px', width: '100%', backgroundColor: bgColor, overflow: 'hidden' }}>
      <div 
        style={{ 
          height: '6px',
          width: `${percentage}%`,
          backgroundColor: color,
          transition: 'width 0.6s ease-out, background-color 0.4s ease-out'
        }} 
      />
    </div>
  );
});

// Mini progress bar for group headers
const MiniProgressBar = React.memo(({ percentage, darkMode }) => {
  const color = getProgressColor(percentage);
  const bgColor = darkMode ? '#334155' : '#e2e8f0';
  
  return (
    <div style={{ height: '4px', width: '48px', backgroundColor: bgColor, borderRadius: '2px', overflow: 'hidden' }}>
      <div 
        style={{ 
          height: '4px',
          width: `${percentage}%`,
          backgroundColor: color,
          borderRadius: '2px',
          transition: 'width 0.6s ease-out, background-color 0.4s ease-out'
        }} 
      />
    </div>
  );
});

// Mini sparkline for journal slider trends
const MiniSparkline = React.memo(({ data, color = '#6366f1', height = 20, width = 40 }) => {
  const validData = data.filter(d => d !== null);
  if (validData.length < 2) return null;
  
  const max = Math.max(...validData);
  const min = Math.min(...validData);
  const range = max - min || 1;
  
  const points = data.map((val, i) => {
    if (val === null) return null;
    const x = (i / (data.length - 1)) * width;
    const y = height - ((val - min) / range) * (height - 4) - 2;
    return { x, y };
  }).filter(p => p !== null);
  
  if (points.length < 2) return null;
  
  const pathD = points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
  
  return (
    <svg width={width} height={height} style={{ opacity: 0.5 }}>
      <path d={pathD} fill="none" stroke={color} strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" />
      <circle cx={points[points.length - 1].x} cy={points[points.length - 1].y} r="2" fill={color} />
    </svg>
  );
});

const GoalTrackerApp = () => {
  // ============================================
  // UNIFIED STATE
  // ============================================
  const [appState, setAppState] = useState({
    goals: [],
    dailyTasks: {},
    taskCompletions: {},
    journalEntries: {},
    journalConfig: {
      prompts: [
        { id: 1, type: 'text', label: 'How was your day?', placeholder: 'Write about your day...' },
        { id: 2, type: 'slider', label: 'Energy level', min: 0, max: 10 }
      ]
    },
    dailyPhotos: {},
    media: {},
    darkMode: false,
    monthlyIntentions: {},
    categories: [
      { id: 'personal', name: 'Personal Growth', color: '#6366f1' },
      { id: 'health', name: 'Health & Fitness', color: '#10b981' },
      { id: 'career', name: 'Career', color: '#f59e0b' },
      { id: 'creative', name: 'Creative', color: '#ec4899' },
      { id: 'social', name: 'Social', color: '#8b5cf6' },
      { id: 'financial', name: 'Financial', color: '#06b6d4' }
    ]
  });

  const [currentView, setCurrentView] = useState('daily');
  const [calendarMode, setCalendarMode] = useState('week'); // 'week', 'month', 'year'
  const [calendarDate, setCalendarDate] = useState(new Date());
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [showCompletionModal, setShowCompletionModal] = useState(null);
  const [viewingCompletion, setViewingCompletion] = useState(null);
  const [showJournalSettings, setShowJournalSettings] = useState(false);
  const [showGoalForm, setShowGoalForm] = useState(false);
  const [deletingGoalId, setDeletingGoalId] = useState(null);
  const [editingGoal, setEditingGoal] = useState(null);
  const [isLoaded, setIsLoaded] = useState(false);
  const [animatingTasks, setAnimatingTasks] = useState({});
  const [showCategorySettings, setShowCategorySettings] = useState(false);

  const { goals, dailyTasks, taskCompletions, journalEntries, journalConfig, dailyPhotos, media, darkMode, monthlyIntentions, categories } = appState;

  // ============================================
  // PERSISTENCE
  // ============================================
  const saveTimeoutRef = useRef(null);
  const isFirstRender = useRef(true);

  useEffect(() => {
    try {
      const saved = localStorage.getItem('goalTrackerData');
      if (saved) {
        const parsed = JSON.parse(saved);
        setAppState(prev => ({ ...prev, ...parsed }));
      }
    } catch (e) {
      console.error('Failed to load data:', e);
    }
    setIsLoaded(true);
  }, []);

  useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    if (!isLoaded) return;

    if (saveTimeoutRef.current) clearTimeout(saveTimeoutRef.current);

    saveTimeoutRef.current = setTimeout(() => {
      try {
        localStorage.setItem('goalTrackerData', JSON.stringify(appState));
      } catch (e) {
        console.error('Failed to save:', e);
        if (e.name === 'QuotaExceededError') {
          alert('Storage is full! Consider removing some photos.');
        }
      }
    }, 500);

    return () => {
      if (saveTimeoutRef.current) clearTimeout(saveTimeoutRef.current);
    };
  }, [appState, isLoaded]);

  // Save immediately when app goes to background (prevents data loss on iOS)
  useEffect(() => {
    if (!isLoaded) return;
    
    const saveImmediately = () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
        saveTimeoutRef.current = null;
      }
      try {
        localStorage.setItem('goalTrackerData', JSON.stringify(appState));
      } catch (e) {
        console.error('Failed to save on visibility change:', e);
      }
    };
    
    const handleVisibilityChange = () => {
      if (document.visibilityState === 'hidden') {
        saveImmediately();
      }
    };
    
    // Also save on page unload (backup for iOS)
    const handleBeforeUnload = () => {
      saveImmediately();
    };
    
    document.addEventListener('visibilitychange', handleVisibilityChange);
    window.addEventListener('beforeunload', handleBeforeUnload);
    window.addEventListener('pagehide', saveImmediately);
    
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      window.removeEventListener('beforeunload', handleBeforeUnload);
      window.removeEventListener('pagehide', saveImmediately);
    };
  }, [appState, isLoaded]);

  // ============================================
  // STATE HELPERS
  // ============================================
  const updateState = useCallback((key, value) => {
    setAppState(prev => ({
      ...prev,
      [key]: typeof value === 'function' ? value(prev[key]) : value
    }));
  }, []);

  const setGoals = useCallback((value) => updateState('goals', value), [updateState]);
  const setDailyTasks = useCallback((value) => updateState('dailyTasks', value), [updateState]);
  const setTaskCompletions = useCallback((value) => updateState('taskCompletions', value), [updateState]);
  const setJournalEntries = useCallback((value) => updateState('journalEntries', value), [updateState]);
  const setJournalConfig = useCallback((value) => updateState('journalConfig', value), [updateState]);
  const setDailyPhotos = useCallback((value) => updateState('dailyPhotos', value), [updateState]);
  const setMedia = useCallback((value) => updateState('media', value), [updateState]);
  const setDarkMode = useCallback((value) => updateState('darkMode', value), [updateState]);
  const setMonthlyIntentions = useCallback((value) => updateState('monthlyIntentions', value), [updateState]);
  const setCategories = useCallback((value) => updateState('categories', value), [updateState]);

  // Use local time for date keys (not UTC) to prevent timezone bugs
  const formatDate = useCallback((date) => toLocalDateKey(date), []);
  const getDateKey = useCallback((date) => formatDate(date), [formatDate]);

  // Check if a date is today
  const isToday = useCallback((date) => {
    const today = new Date();
    return date.getDate() === today.getDate() &&
           date.getMonth() === today.getMonth() &&
           date.getFullYear() === today.getFullYear();
  }, []);

  // Animation helper
  const triggerTaskAnimation = useCallback((taskKey) => {
    setAnimatingTasks(prev => ({ ...prev, [taskKey]: true }));
    triggerHaptic();
    setTimeout(() => {
      setAnimatingTasks(prev => ({ ...prev, [taskKey]: false }));
    }, 1200);
  }, []);

  // ============================================
  // GOAL MANAGEMENT
  // ============================================
  const addGoal = useCallback((goal) => {
    const newGoal = { id: Date.now(), ...goal, createdAt: new Date().toISOString() };
    setGoals(prev => [...prev, newGoal]);
    setShowGoalForm(false);
  }, [setGoals]);

  const updateGoal = useCallback((id, updates) => {
    setGoals(prev => prev.map(g => g.id === id ? { ...g, ...updates } : g));
    setEditingGoal(null);
  }, [setGoals]);

  const deleteGoal = useCallback((id) => {
    setGoals(prev => prev.filter(g => g.id !== id));
    setDailyTasks(prev => {
      const newTasks = { ...prev };
      Object.keys(newTasks).forEach(dateKey => {
        const dateTasks = { ...newTasks[dateKey] };
        Object.keys(dateTasks).forEach(taskKey => {
          if (taskKey === id || taskKey.startsWith(`${id}-`)) delete dateTasks[taskKey];
        });
        newTasks[dateKey] = dateTasks;
      });
      return newTasks;
    });
  }, [setGoals, setDailyTasks]);

  // ============================================
  // WEEK HELPERS (must be before task management)
  // ============================================
  const getWeekRange = useCallback((date) => {
    const day = date.getDay(); // 0 = Sunday
    const weekStart = new Date(date);
    weekStart.setDate(date.getDate() - day); // Go back to Sunday
    weekStart.setHours(0, 0, 0, 0);
    const weekEnd = new Date(weekStart);
    weekEnd.setDate(weekStart.getDate() + 6); // Saturday
    weekEnd.setHours(23, 59, 59, 999);
    return { weekStart, weekEnd };
  }, []);

  // Get a week key for weekly points goal tracking
  const getWeekKey = useCallback((date) => {
    const { weekStart } = getWeekRange(date);
    return `week-${toLocalDateKey(weekStart)}`;
  }, [getWeekRange]);

  // ============================================
  // TASK MANAGEMENT
  // ============================================
  const toggleTask = useCallback((dateKey, goalId, taskId, checkIndex = 0, task = null, goal = null) => {
    // For weekly points goals, use week key instead of date key
    const isWeeklyPointsGoal = goal?.goalType === 'points' && goal?.pointTargetFrequency === 'weekly';
    const storageKey = isWeeklyPointsGoal ? getWeekKey(new Date(dateKey)) : dateKey;
    
    const taskKey = `${goalId}-${taskId}-${checkIndex}`;
    const currentValue = dailyTasks[storageKey]?.[taskKey];

    if (currentValue) {
      setDailyTasks(prev => ({ ...prev, [storageKey]: { ...prev[storageKey], [taskKey]: false } }));
      return;
    }

    // Trigger animation when completing (not uncompleting)
    triggerTaskAnimation(taskKey);

    if (task && task.promptForNote) {
      setShowCompletionModal({ dateKey: storageKey, goalId, taskId, checkIndex, task });
      return;
    }

    setDailyTasks(prev => ({ ...prev, [storageKey]: { ...prev[storageKey], [taskKey]: true } }));
  }, [dailyTasks, setDailyTasks, triggerTaskAnimation, getWeekKey]);

  const saveTaskCompletion = useCallback((dateKey, goalId, taskId, checkIndex, note, photo) => {
    const taskKey = `${goalId}-${taskId}-${checkIndex}`;
    setDailyTasks(prev => ({ ...prev, [dateKey]: { ...prev[dateKey], [taskKey]: true } }));
    
    if (note || photo) {
      const completionKey = `${dateKey}-${taskKey}`;
      setTaskCompletions(prev => ({
        ...prev,
        [completionKey]: { note, photo, timestamp: new Date().toISOString() }
      }));
    }
    setShowCompletionModal(null);
  }, [setDailyTasks, setTaskCompletions]);

  // Set variable task value (for slider and counter task types)
  const setVariableTaskValue = useCallback((dateKey, goalId, taskId, valueType, newValue, goal = null) => {
    // For weekly points goals, use week key
    const isWeeklyPointsGoal = goal?.goalType === 'points' && goal?.pointTargetFrequency === 'weekly';
    const storageKey = isWeeklyPointsGoal ? getWeekKey(new Date(dateKey)) : dateKey;
    
    const taskKey = `${goalId}-${taskId}-${valueType}`; // e.g., "123-456-value" or "123-456-count"
    
    setDailyTasks(prev => ({ 
      ...prev, 
      [storageKey]: { 
        ...prev[storageKey], 
        [taskKey]: Math.max(0, newValue) 
      } 
    }));
  }, [setDailyTasks, getWeekKey]);

  // Get variable task value
  const getVariableTaskValue = useCallback((dateKey, goalId, taskId, valueType, goal = null) => {
    const isWeeklyPointsGoal = goal?.goalType === 'points' && goal?.pointTargetFrequency === 'weekly';
    const storageKey = isWeeklyPointsGoal ? getWeekKey(new Date(dateKey)) : dateKey;
    
    const taskKey = `${goalId}-${taskId}-${valueType}`;
    return dailyTasks[storageKey]?.[taskKey] || 0;
  }, [dailyTasks, getWeekKey]);

  const getTaskCompletionCount = useCallback((dateKey, goalId, taskId, totalChecks, goal = null) => {
    // For weekly points goals, use week key
    const isWeeklyPointsGoal = goal?.goalType === 'points' && goal?.pointTargetFrequency === 'weekly';
    const storageKey = isWeeklyPointsGoal ? getWeekKey(new Date(dateKey)) : dateKey;
    
    const tasks = dailyTasks[storageKey] || {};
    let count = 0;
    for (let i = 0; i < totalChecks; i++) {
      if (tasks[`${goalId}-${taskId}-${i}`]) count++;
    }
    return count;
  }, [dailyTasks, getWeekKey]);

  const isTaskCompleted = useCallback((dateKey, goalId, taskId, goal = null) => {
    // For weekly points goals, use week key
    const isWeeklyPointsGoal = goal?.goalType === 'points' && goal?.pointTargetFrequency === 'weekly';
    const storageKey = isWeeklyPointsGoal ? getWeekKey(new Date(dateKey)) : dateKey;
    
    const tasks = dailyTasks[storageKey] || {};
    const newKey = `${goalId}-${taskId}-0`;
    if (tasks[newKey] !== undefined) return tasks[newKey];
    return tasks[goalId] || false;
  }, [dailyTasks, getWeekKey]);

  // Check if a scheduled task should appear on a given date
  const isTaskScheduledForDate = useCallback((task, date) => {
    if (!task.frequency || task.frequency === 'daily') return true;
    if (task.frequency === 'scheduled') {
      const dayOfWeek = (typeof date === 'string' ? new Date(date + 'T12:00:00') : date).getDay();
      return (task.scheduledDays || []).includes(dayOfWeek);
    }
    return false; // weekly tasks handled separately
  }, []);

  // ============================================
  // POINTS CALCULATION
  // ============================================
  // Calculate points earned for a goal - dateKey for daily, weekKey for weekly
  const calculatePointsEarnedForDate = useCallback((dateKey, goal) => {
    if (goal.goalType !== 'points' || !goal.tasks) return 0;
    
    // For weekly points goals, we don't calculate by date - use calculatePointsEarnedForWeek
    if (goal.pointTargetFrequency === 'weekly') return 0;
    
    let totalPoints = 0;
    goal.tasks.forEach(task => {
      const taskType = task.taskType || 'checkbox';
      
      if (taskType === 'checkbox') {
        // Simple checkbox - checked = pointValue points
        const pointValue = task.pointValue || 1;
        if (dailyTasks[dateKey]?.[`${goal.id}-${task.id}-0`]) {
          totalPoints += pointValue;
        }
      } else if (taskType === 'slider') {
        // Slider - value * pointsPerUnit
        const value = dailyTasks[dateKey]?.[`${goal.id}-${task.id}-value`] || 0;
        const pointsPerUnit = task.pointsPerUnit || 1;
        totalPoints += value * pointsPerUnit;
      } else if (taskType === 'counter') {
        // Counter - floor(count / unitsPerPoint) * pointsPerUnit
        const count = dailyTasks[dateKey]?.[`${goal.id}-${task.id}-count`] || 0;
        const unitsPerPoint = task.unitsPerPoint || 1;
        const pointsPerUnit = task.pointsPerUnit || 1;
        totalPoints += Math.floor(count / unitsPerPoint) * pointsPerUnit;
      }
    });
    return totalPoints;
  }, [dailyTasks]);

  // Calculate points earned for weekly points goals using week key
  const calculatePointsEarnedForWeek = useCallback((weekKey, goal) => {
    if (goal.goalType !== 'points' || !goal.tasks) return 0;
    if (goal.pointTargetFrequency !== 'weekly') return 0;
    
    let totalPoints = 0;
    goal.tasks.forEach(task => {
      const taskType = task.taskType || 'checkbox';
      
      if (taskType === 'checkbox') {
        const pointValue = task.pointValue || 1;
        if (dailyTasks[weekKey]?.[`${goal.id}-${task.id}-0`]) {
          totalPoints += pointValue;
        }
      } else if (taskType === 'slider') {
        const value = dailyTasks[weekKey]?.[`${goal.id}-${task.id}-value`] || 0;
        const pointsPerUnit = task.pointsPerUnit || 1;
        totalPoints += value * pointsPerUnit;
      } else if (taskType === 'counter') {
        const count = dailyTasks[weekKey]?.[`${goal.id}-${task.id}-count`] || 0;
        const unitsPerPoint = task.unitsPerPoint || 1;
        const pointsPerUnit = task.pointsPerUnit || 1;
        totalPoints += Math.floor(count / unitsPerPoint) * pointsPerUnit;
      }
    });
    return totalPoints;
  }, [dailyTasks]);

  // Generic points calculation that handles both daily and weekly
  const calculatePointsEarned = useCallback((dateKey, goal, weekKeyOverride = null) => {
    if (goal.goalType !== 'points' || !goal.tasks) return 0;
    
    if (goal.pointTargetFrequency === 'weekly') {
      const weekKey = weekKeyOverride || getWeekKey(new Date(dateKey));
      return calculatePointsEarnedForWeek(weekKey, goal);
    }
    
    return calculatePointsEarnedForDate(dateKey, goal);
  }, [calculatePointsEarnedForDate, calculatePointsEarnedForWeek, getWeekKey]);

  // ============================================
  // PHOTO & MEDIA
  // ============================================
  const updateDailyPhoto = useCallback((dateKey, photoData) => {
    setDailyPhotos(prev => ({ ...prev, [dateKey]: photoData }));
  }, [setDailyPhotos]);

  const removeDailyPhoto = useCallback((dateKey) => {
    setDailyPhotos(prev => {
      const newPhotos = { ...prev };
      delete newPhotos[dateKey];
      return newPhotos;
    });
  }, [setDailyPhotos]);

  const addMedia = useCallback((dateKey, mediaItem) => {
    setMedia(prev => ({
      ...prev,
      [dateKey]: [...(prev[dateKey] || []), { ...mediaItem, id: Date.now() }]
    }));
  }, [setMedia]);

  const removeMedia = useCallback((dateKey, mediaId) => {
    setMedia(prev => ({
      ...prev,
      [dateKey]: (prev[dateKey] || []).filter(m => m.id !== mediaId)
    }));
  }, [setMedia]);

  // ============================================
  // MEMOIZED CALCULATIONS
  // ============================================
  const goalProgressCache = useMemo(() => {
    const cache = {};
    const today = new Date();
    today.setHours(23, 59, 59, 999);

    goals.forEach(goal => {
      // Use goal creation date, fallback to Jan 1st for legacy goals
      const goalStart = goal.createdAt ? new Date(goal.createdAt) : new Date(today.getFullYear(), 0, 1);
      goalStart.setHours(0, 0, 0, 0);
      const daysPassed = Math.floor((today - goalStart) / (1000 * 60 * 60 * 24)) + 1;

      let completedDays = 0;
      for (let i = 0; i < daysPassed; i++) {
        const date = new Date(goalStart);
        date.setDate(date.getDate() + i);
        const dateKey = toLocalDateKey(date);
        const tasks = dailyTasks[dateKey] || {};
        const hasCompletion = Object.keys(tasks).some(key => 
          key === goal.id || key.startsWith(`${goal.id}-`)
        );
        if (hasCompletion) completedDays++;
      }
      cache[goal.id] = {
        completedDays,
        totalDays: daysPassed,
        percentage: daysPassed > 0 ? Math.round((completedDays / daysPassed) * 100) : 0
      };
    });
    return cache;
  }, [goals, dailyTasks]);

  const calculateProgress = useCallback((goal) => {
    return goalProgressCache[goal.id] || { completedDays: 0, totalDays: 0, percentage: 0 };
  }, [goalProgressCache]);

  const calculateWeeklyProgress = useCallback((task, goalId, date) => {
    const { weekStart, weekEnd } = getWeekRange(date);
    let completedCount = 0;
    for (let d = new Date(weekStart); d <= weekEnd; d.setDate(d.getDate() + 1)) {
      const dateKey = toLocalDateKey(d);
      if (isTaskCompleted(dateKey, goalId, task.id)) completedCount++;
    }
    const target = task.weeklyTarget || 4;
    return { completed: completedCount, target, percentage: Math.round((completedCount / target) * 100) };
  }, [getWeekRange, isTaskCompleted]);

  const selectedDateKey = useMemo(() => getDateKey(selectedDate), [selectedDate, getDateKey]);

  const dailyProgress = useMemo(() => {
    let totalTasks = 0;
    let completedTasks = 0;
    let totalPoints = 0;
    let earnedPoints = 0;
    
    goals.forEach(goal => {
      if (!goal.tasks || !Array.isArray(goal.tasks)) return;
      
      // Handle daily points goals
      if (goal.goalType === 'points' && (!goal.pointTargetFrequency || goal.pointTargetFrequency === 'daily')) {
        totalPoints += goal.pointTarget || 10;
        earnedPoints += calculatePointsEarnedForDate(selectedDateKey, goal);
        return;
      }
      
      // Skip weekly points goals and other points goals
      if (goal.goalType === 'points') return;
      
      // Handle checkbox goals
      goal.tasks.forEach(task => {
        if ((!task.frequency || task.frequency === 'daily') || 
            (task.frequency === 'scheduled' && isTaskScheduledForDate(task, selectedDate))) {
          const checksPerDay = task.dailyChecks || 1;
          totalTasks += checksPerDay;
          for (let i = 0; i < checksPerDay; i++) {
            if (dailyTasks[selectedDateKey]?.[`${goal.id}-${task.id}-${i}`]) completedTasks++;
          }
        }
      });
    });
    
    // Combine checkbox progress and points progress
    const checkboxPercentage = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;
    const pointsPercentage = totalPoints > 0 ? Math.min(100, (earnedPoints / totalPoints) * 100) : 0;
    
    // Weighted average based on whether we have both types
    let percentage = 0;
    if (totalTasks > 0 && totalPoints > 0) {
      percentage = Math.round((checkboxPercentage + pointsPercentage) / 2);
    } else if (totalTasks > 0) {
      percentage = Math.round(checkboxPercentage);
    } else if (totalPoints > 0) {
      percentage = Math.round(pointsPercentage);
    }
    
    return {
      completed: completedTasks,
      total: totalTasks,
      earnedPoints,
      totalPoints,
      percentage
    };
  }, [goals, dailyTasks, selectedDateKey, calculatePointsEarnedForDate]);

  const calculateDailyProgress = useCallback((dateKey) => {
    let totalTasks = 0;
    let completedTasks = 0;
    goals.forEach(goal => {
      if (goal.goalType === 'points') return;
      if (!goal.tasks || !Array.isArray(goal.tasks)) return;
      goal.tasks.forEach(task => {
        if ((!task.frequency || task.frequency === 'daily') ||
            (task.frequency === 'scheduled' && isTaskScheduledForDate(task, dateKey))) {
          const checksPerDay = task.dailyChecks || 1;
          totalTasks += checksPerDay;
          for (let i = 0; i < checksPerDay; i++) {
            if (dailyTasks[dateKey]?.[`${goal.id}-${task.id}-${i}`]) completedTasks++;
          }
        }
      });
    });
    return {
      completed: completedTasks,
      total: totalTasks,
      percentage: totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0
    };
  }, [goals, dailyTasks, isTaskScheduledForDate]);

  const weeklyOverallProgress = useMemo(() => {
    const { weekStart, weekEnd } = getWeekRange(selectedDate);
    const weekKey = getWeekKey(selectedDate);
    let totalExpected = 0;
    let totalCompleted = 0;
    let totalPoints = 0;
    let earnedPoints = 0;

    goals.forEach(goal => {
      if (!goal.tasks || !Array.isArray(goal.tasks)) return;
      
      // Handle weekly points goals
      if (goal.goalType === 'points' && goal.pointTargetFrequency === 'weekly') {
        totalPoints += goal.pointTarget || 10;
        earnedPoints += calculatePointsEarnedForWeek(weekKey, goal);
        return;
      }
      
      // Skip daily points goals
      if (goal.goalType === 'points') return;
      
      // Handle checkbox goals
      goal.tasks.forEach(task => {
        if (!task.frequency || task.frequency === 'daily') {
          const checksPerDay = task.dailyChecks || 1;
          for (let d = new Date(weekStart); d <= weekEnd; d.setDate(d.getDate() + 1)) {
            const dateKey = toLocalDateKey(d);
            totalExpected += checksPerDay;
            for (let i = 0; i < checksPerDay; i++) {
              if (dailyTasks[dateKey]?.[`${goal.id}-${task.id}-${i}`]) totalCompleted++;
            }
          }
        } else if (task.frequency === 'scheduled') {
          const checksPerDay = task.dailyChecks || 1;
          for (let d = new Date(weekStart); d <= weekEnd; d.setDate(d.getDate() + 1)) {
            if (isTaskScheduledForDate(task, d)) {
              const dateKey = toLocalDateKey(d);
              totalExpected += checksPerDay;
              for (let i = 0; i < checksPerDay; i++) {
                if (dailyTasks[dateKey]?.[`${goal.id}-${task.id}-${i}`]) totalCompleted++;
              }
            }
          }
        } else if (task.frequency === 'weekly') {
          const target = task.weeklyTarget || 4;
          totalExpected += target;
          for (let d = new Date(weekStart); d <= weekEnd; d.setDate(d.getDate() + 1)) {
            const dateKey = toLocalDateKey(d);
            if (isTaskCompleted(dateKey, goal.id, task.id)) totalCompleted++;
          }
        }
      });
    });
    
    // Combine checkbox progress and points progress
    const checkboxPercentage = totalExpected > 0 ? (totalCompleted / totalExpected) * 100 : 0;
    const pointsPercentage = totalPoints > 0 ? Math.min(100, (earnedPoints / totalPoints) * 100) : 0;
    
    let percentage = 0;
    if (totalExpected > 0 && totalPoints > 0) {
      percentage = Math.round((checkboxPercentage + pointsPercentage) / 2);
    } else if (totalExpected > 0) {
      percentage = Math.round(checkboxPercentage);
    } else if (totalPoints > 0) {
      percentage = Math.round(pointsPercentage);
    }
    
    return {
      completed: totalCompleted,
      total: totalExpected,
      earnedPoints,
      totalPoints,
      percentage
    };
  }, [goals, dailyTasks, selectedDate, getWeekRange, getWeekKey, isTaskCompleted, calculatePointsEarnedForWeek]);

  // ============================================
  // THEME CLASSES - Clean Navy Design
  // ============================================
  const theme = {
    // Backgrounds
    pageBg: darkMode ? 'bg-slate-900' : 'bg-gradient-to-b from-slate-50 to-slate-100',
    headerBg: darkMode ? 'bg-slate-900/90' : 'bg-slate-50/90',
    cardBg: darkMode ? 'bg-slate-800' : 'bg-white',
    inputBg: darkMode ? 'bg-slate-700' : 'bg-slate-50',
    
    // Text
    textPrimary: darkMode ? 'text-slate-100' : 'text-slate-800',
    textSecondary: darkMode ? 'text-slate-400' : 'text-slate-500',
    textMuted: darkMode ? 'text-slate-500' : 'text-slate-400',
    
    // Borders
    border: darkMode ? 'border-slate-700' : 'border-slate-200',
    divider: darkMode ? 'border-slate-700' : 'border-slate-100',
    
    // Accents
    accent: darkMode ? 'bg-slate-200 text-slate-900' : 'bg-slate-700 text-white',
    accentMuted: darkMode ? 'bg-slate-700' : 'bg-slate-200',
    checkDone: darkMode ? 'text-slate-500' : 'text-slate-400',
    checkUndone: darkMode ? 'text-slate-600' : 'text-slate-300',
    
    // Progress
    progressBg: darkMode ? 'bg-slate-700' : 'bg-slate-200',
    progressFill: darkMode ? 'bg-slate-300' : 'bg-slate-700',
    progressSuccess: 'bg-emerald-500',
    
    // Buttons
    btnPrimary: darkMode ? 'bg-slate-200 text-slate-900' : 'bg-slate-700 text-white',
    btnSecondary: darkMode ? 'bg-slate-700 text-slate-300' : 'bg-slate-100 text-slate-700',
    btnIcon: darkMode ? 'bg-slate-800 text-slate-400' : 'bg-white text-slate-400',
  };

  // ============================================
  // MODAL COMPONENTS
  // ============================================
  const JournalSettingsModal = ({ config, onSave, onCancel }) => {
    const [prompts, setPrompts] = useState(config.prompts || []);
    const addPrompt = (type) => {
      setPrompts([...prompts, {
        id: Date.now(),
        type,
        label: type === 'text' ? 'New text prompt' : type === 'yesno' ? 'New yes/no question' : 'New rating',
        placeholder: type === 'text' ? 'Write here...' : '',
        min: type === 'slider' ? 0 : undefined,
        max: type === 'slider' ? 10 : undefined
      }]);
    };
    const updatePrompt = (id, field, value) => setPrompts(prompts.map(p => p.id === id ? { ...p, [field]: value } : p));
    const deletePrompt = (id) => setPrompts(prompts.filter(p => p.id !== id));
    const movePrompt = (index, direction) => {
      const newPrompts = [...prompts];
      const newIndex = index + direction;
      if (newIndex >= 0 && newIndex < prompts.length) {
        [newPrompts[index], newPrompts[newIndex]] = [newPrompts[newIndex], newPrompts[index]];
        setPrompts(newPrompts);
      }
    };

    return (
      <div className="fixed inset-0 bg-black/30 backdrop-blur-sm flex items-center justify-center z-50 p-4">
        <div className={`${theme.cardBg} rounded-2xl w-full max-w-md max-h-[90vh] overflow-hidden shadow-xl flex flex-col`}>
          {/* Header */}
          <div className={`px-5 py-4 border-b ${theme.border} flex items-center justify-between flex-shrink-0`}>
            <h3 className={`text-base font-semibold ${theme.textPrimary}`}>Journal Prompts</h3>
            <button onClick={onCancel} className="p-1 rounded-lg">
              <X className={`w-5 h-5 ${theme.textMuted}`} />
            </button>
          </div>
          
          {/* Add Buttons */}
          <div className={`px-5 py-3 border-b ${theme.border} flex-shrink-0`}>
            <p className={`text-xs font-medium mb-2 ${theme.textMuted}`}>Add prompt</p>
            <div className="flex gap-2">
              <button onClick={() => addPrompt('text')} className={`flex-1 py-2 px-3 rounded-lg text-xs font-medium ${theme.btnSecondary}`}>+ Text</button>
              <button onClick={() => addPrompt('slider')} className={`flex-1 py-2 px-3 rounded-lg text-xs font-medium ${theme.btnSecondary}`}>+ Slider</button>
              <button onClick={() => addPrompt('yesno')} className={`flex-1 py-2 px-3 rounded-lg text-xs font-medium ${theme.btnSecondary}`}>+ Yes/No</button>
            </div>
          </div>
          
          {/* Prompts List */}
          <div className="flex-1 overflow-y-auto px-5 py-3">
            {prompts.length === 0 ? (
              <p className={`text-center py-8 text-sm ${theme.textMuted}`}>No prompts yet</p>
            ) : (
              <div className="space-y-2">
                {prompts.map((prompt, index) => (
                  <div key={prompt.id} className={`rounded-xl border ${theme.border} overflow-hidden`}>
                    <div className={`flex items-center gap-2 p-3 ${theme.inputBg}`}>
                      {/* Reorder */}
                      <div className="flex flex-col gap-0.5">
                        <button onClick={() => movePrompt(index, -1)} disabled={index === 0} className={index === 0 ? 'opacity-30' : ''}>
                          <ChevronUp className={`w-3 h-3 ${theme.textMuted}`} />
                        </button>
                        <button onClick={() => movePrompt(index, 1)} disabled={index === prompts.length - 1} className={index === prompts.length - 1 ? 'opacity-30' : ''}>
                          <ChevronDown className={`w-3 h-3 ${theme.textMuted}`} />
                        </button>
                      </div>
                      
                      {/* Type badge */}
                      <span className={`text-xs px-2 py-0.5 rounded-full flex-shrink-0 ${theme.btnSecondary}`}>
                        {prompt.type}
                      </span>
                      
                      {/* Label input */}
                      <input
                        type="text"
                        value={prompt.label}
                        onChange={(e) => updatePrompt(prompt.id, 'label', e.target.value)}
                        className={`flex-1 px-2 py-1 rounded text-sm ${theme.cardBg} ${theme.textPrimary} border ${theme.border}`}
                      />
                      
                      {/* Delete */}
                      <button onClick={() => deletePrompt(prompt.id)} className="p-1 text-red-500">
                        <Trash2 className="w-4 h-4" />
                      </button>
                    </div>
                    
                    {/* Type-specific settings */}
                    {prompt.type === 'text' && (
                      <div className={`px-3 pb-3 pt-1`}>
                        <label className={`text-xs ${theme.textMuted}`}>Placeholder</label>
                        <input
                          type="text"
                          value={prompt.placeholder || ''}
                          onChange={(e) => updatePrompt(prompt.id, 'placeholder', e.target.value)}
                          className={`w-full mt-1 px-2 py-1.5 rounded text-sm ${theme.cardBg} ${theme.textPrimary} border ${theme.border}`}
                        />
                      </div>
                    )}
                    
                    {prompt.type === 'slider' && (
                      <div className={`px-3 pb-3 pt-1 flex gap-3`}>
                        <div className="flex-1">
                          <label className={`text-xs ${theme.textMuted}`}>Min</label>
                          <input
                            type="number"
                            value={prompt.min || 0}
                            onChange={(e) => updatePrompt(prompt.id, 'min', parseInt(e.target.value))}
                            className={`w-full mt-1 px-2 py-1.5 rounded text-sm ${theme.cardBg} ${theme.textPrimary} border ${theme.border}`}
                          />
                        </div>
                        <div className="flex-1">
                          <label className={`text-xs ${theme.textMuted}`}>Max</label>
                          <input
                            type="number"
                            value={prompt.max || 10}
                            onChange={(e) => updatePrompt(prompt.id, 'max', parseInt(e.target.value))}
                            className={`w-full mt-1 px-2 py-1.5 rounded text-sm ${theme.cardBg} ${theme.textPrimary} border ${theme.border}`}
                          />
                        </div>
                      </div>
                    )}
                  </div>
                ))}
              </div>
            )}
          </div>
          
          {/* Footer */}
          <div className={`px-5 py-4 border-t ${theme.border} flex gap-2 flex-shrink-0`}>
            <button onClick={() => onSave({ prompts })} className={`flex-1 py-2.5 rounded-lg text-sm font-medium ${theme.btnPrimary}`}>Save</button>
            <button onClick={onCancel} className={`px-4 py-2.5 rounded-lg text-sm font-medium ${theme.btnSecondary}`}>Cancel</button>
          </div>
        </div>
      </div>
    );
  };

  // ============================================
  // CATEGORY SETTINGS MODAL
  // ============================================
  const CategorySettingsModal = ({ categories: cats, onSave, onCancel }) => {
    const [localCategories, setLocalCategories] = useState(cats || []);
    const colorOptions = ['#6366f1', '#10b981', '#f59e0b', '#ec4899', '#8b5cf6', '#06b6d4', '#ef4444', '#84cc16', '#f97316', '#14b8a6'];
    
    const addCategory = () => {
      setLocalCategories([...localCategories, {
        id: `cat-${Date.now()}`,
        name: 'New Category',
        color: colorOptions[localCategories.length % colorOptions.length]
      }]);
    };
    
    const updateCategory = (id, field, value) => {
      setLocalCategories(localCategories.map(c => c.id === id ? { ...c, [field]: value } : c));
    };
    
    const deleteCategory = (id) => {
      if (localCategories.length <= 1) return;
      setLocalCategories(localCategories.filter(c => c.id !== id));
    };

    return (
      <div className="fixed inset-0 bg-black/30 backdrop-blur-sm flex items-center justify-center z-50 p-4">
        <div className={`${theme.cardBg} rounded-2xl p-5 w-full max-w-md max-h-[90vh] overflow-y-auto shadow-xl`}>
          <div className="flex items-center justify-between mb-4">
            <h3 className={`text-base font-semibold ${theme.textPrimary}`}>Edit Categories</h3>
            <button onClick={onCancel} className={`p-1 rounded-lg`}>
              <X className={`w-5 h-5 ${theme.textMuted}`} />
            </button>
          </div>
          
          <div className="space-y-2 mb-4">
            {localCategories.map((cat) => (
              <div key={cat.id} className={`p-3 rounded-lg ${theme.inputBg}`}>
                <div className="flex items-center gap-3">
                  <div className="flex gap-1">
                    {colorOptions.map(color => (
                      <button
                        key={color}
                        onClick={() => updateCategory(cat.id, 'color', color)}
                        className={`w-5 h-5 rounded-full ${cat.color === color ? 'ring-2 ring-offset-1 ring-slate-400' : ''}`}
                        style={{ backgroundColor: color }}
                      />
                    ))}
                  </div>
                </div>
                <div className="flex items-center gap-2 mt-2">
                  <div className="w-3 h-3 rounded-full flex-shrink-0" style={{ backgroundColor: cat.color }} />
                  <input
                    type="text"
                    value={cat.name}
                    onChange={(e) => updateCategory(cat.id, 'name', e.target.value)}
                    className={`flex-1 rounded-lg px-2 py-1.5 text-sm ${theme.cardBg} ${theme.textPrimary}`}
                  />
                  <button 
                    onClick={() => deleteCategory(cat.id)} 
                    disabled={localCategories.length <= 1}
                    className={`p-1 rounded-lg ${localCategories.length <= 1 ? 'opacity-30' : 'text-red-500 hover:bg-red-500/10'}`}
                  >
                    <Trash2 className="w-3.5 h-3.5" />
                  </button>
                </div>
              </div>
            ))}
          </div>
          
          <button onClick={addCategory} className={`w-full py-2 rounded-lg text-sm font-medium mb-4 ${theme.btnSecondary}`}>+ Add Category</button>
          
          <div className="flex gap-2">
            <button onClick={() => onSave(localCategories)} className={`flex-1 py-2 rounded-lg text-sm font-medium ${theme.btnPrimary}`}>Save</button>
            <button onClick={onCancel} className={`px-4 py-2 rounded-lg text-sm font-medium ${theme.btnSecondary}`}>Cancel</button>
          </div>
        </div>
      </div>
    );
  };

  const ViewCompletionModal = ({ completion, taskName, onClose }) => (
    <div className="fixed inset-0 bg-black/30 backdrop-blur-sm flex items-center justify-center z-50 p-4">
      <div className={`${theme.cardBg} rounded-2xl p-5 w-full max-w-md shadow-xl`}>
        <div className="flex items-start justify-between mb-4">
          <h3 className={`text-base font-semibold ${theme.textPrimary}`}>{taskName}</h3>
          <button onClick={onClose} className={`p-1 rounded-lg`}><X className={`w-5 h-5 ${theme.textMuted}`} /></button>
        </div>
        <div className="space-y-3">
          {completion.note && <div><p className={`text-xs font-medium mb-1 ${theme.textMuted}`}>Note</p><p className={`p-2 rounded-lg text-sm ${theme.inputBg} ${theme.textSecondary}`}>{completion.note}</p></div>}
          {completion.photo && <div><p className={`text-xs font-medium mb-1 ${theme.textMuted}`}>Photo</p><img src={completion.photo} alt="Completion" className="w-full h-48 object-cover rounded-lg" /></div>}
          {completion.timestamp && <p className={`text-xs ${theme.textMuted}`}>Completed {new Date(completion.timestamp).toLocaleString()}</p>}
        </div>
        <button onClick={onClose} className={`w-full mt-4 py-2 rounded-lg text-sm font-medium ${theme.btnSecondary}`}>Close</button>
      </div>
    </div>
  );

  const TaskCompletionModal = ({ onSave, onCancel, taskName }) => {
    const [note, setNote] = useState('');
    const [photo, setPhoto] = useState(null);
    const [photoPreview, setPhotoPreview] = useState(null);
    const handlePhotoChange = (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onloadend = () => { setPhoto(reader.result); setPhotoPreview(reader.result); };
        reader.readAsDataURL(file);
      }
    };
    return (
      <div className="fixed inset-0 bg-black/30 backdrop-blur-sm flex items-center justify-center z-50 p-4">
        <div className={`${theme.cardBg} rounded-2xl p-5 w-full max-w-md shadow-xl`}>
          <h3 className={`text-base font-semibold mb-4 ${theme.textPrimary}`}>{taskName} completed! ðŸŽ‰</h3>
          <div className="space-y-3">
            <div>
              <label className={`block text-xs font-medium mb-1 ${theme.textMuted}`}>Note (optional)</label>
              <textarea value={note} onChange={(e) => setNote(e.target.value)} placeholder="How did it go?" className={`w-full rounded-lg px-3 py-2 text-sm ${theme.inputBg} ${theme.textPrimary}`} rows="2" />
            </div>
            <div>
              <label className={`block text-xs font-medium mb-1 ${theme.textMuted}`}>Photo (optional)</label>
              <input type="file" accept="image/*" onChange={handlePhotoChange} className={`w-full text-xs ${theme.textMuted}`} />
              {photoPreview && (
                <div className="mt-2 relative">
                  <img src={photoPreview} alt="Preview" className="w-full h-32 object-cover rounded-lg" />
                  <button onClick={() => { setPhoto(null); setPhotoPreview(null); }} className="absolute top-1 right-1 p-1 bg-red-500 rounded-full"><X className="w-3 h-3 text-white" /></button>
                </div>
              )}
            </div>
          </div>
          <div className="flex gap-2 mt-4">
            <button onClick={() => onSave(note, photo)} className={`flex-1 py-2 rounded-lg text-sm font-medium ${theme.btnPrimary}`}>{note || photo ? 'Save' : 'Done'}</button>
            <button onClick={onCancel} className={`px-4 py-2 rounded-lg text-sm font-medium ${theme.btnSecondary}`}>Cancel</button>
          </div>
        </div>
      </div>
    );
  };

  // ============================================
  // GOAL FORM - OPTION E CARD-BASED DESIGN
  // ============================================
  const GoalForm = ({ goal, onSave, onCancel }) => {
    const isEditing = !!goal;
    
    const migrateOldGoal = (oldGoal) => {
      if (!oldGoal) return null;
      if (oldGoal.tasks && Array.isArray(oldGoal.tasks)) {
        // Ensure all tasks have the new fields
        const migratedTasks = oldGoal.tasks.map(task => ({
          ...task,
          importance: task.importance || 'medium',
          difficulty: task.difficulty || 'medium',
          timeEstimate: task.timeEstimate || 15
        }));
        return { ...oldGoal, tasks: migratedTasks, motivation: oldGoal.motivation || '' };
      }
      return { ...oldGoal, motivation: '', tasks: [{ 
        id: Date.now(), 
        action: oldGoal.dailyAction || '', 
        frequency: oldGoal.frequency || 'daily', 
        weeklyTarget: oldGoal.weeklyTarget || 4, 
        dailyChecks: 1, 
        pointValue: 1,
        importance: 'medium',
        difficulty: 'medium',
        timeEstimate: 15
      }] };
    };
    
    const migratedGoal = goal ? migrateOldGoal(goal) : null;
    const [formData, setFormData] = useState(migratedGoal || {
      title: '', 
      yearlyGoal: '', 
      motivation: '',
      checkpoint: 'weekly', 
      checkpointValue: '', 
      category: 'personal',
      goalType: 'checkbox',
      pointTarget: 10,
      pointTargetFrequency: 'daily',
      tasks: [{ 
        id: Date.now(), 
        action: '', 
        frequency: 'daily', 
        weeklyTarget: 4, 
        dailyChecks: 1, 
        pointValue: 1,
        importance: 'medium',
        difficulty: 'medium',
        timeEstimate: 15
      }]
    });

    // Helper function to update a task field
    const updateTask = (index, field, value) => {
      const newTasks = [...formData.tasks];
      newTasks[index] = { ...newTasks[index], [field]: value };
      setFormData({ ...formData, tasks: newTasks });
    };

    // Card wrapper style (inline to avoid re-render issues)
    const cardClass = `p-3 rounded-xl ${theme.cardBg} border ${darkMode ? 'border-slate-700' : 'border-slate-200'}`;
    const cardHeaderClass = "flex items-center gap-2 mb-2";

    // Metrics Row - defined as a function that returns JSX
    const renderMetricsRow = (task, index, showTime = true) => (
      <div className={`grid ${showTime ? 'grid-cols-3' : 'grid-cols-2'} gap-2`}>
        {/* Importance */}
        <div className={`p-2 rounded-lg ${darkMode ? 'bg-slate-700' : 'bg-white'} border ${darkMode ? 'border-slate-600' : 'border-slate-200'}`}>
          <div className="flex items-center gap-1 mb-1">
            <Flame className="w-3 h-3 text-orange-500" />
            <span className={`text-[10px] ${theme.textMuted} uppercase tracking-wider`}>Priority</span>
          </div>
          <select 
            value={task.importance || 'medium'} 
            onChange={(e) => updateTask(index, 'importance', e.target.value)}
            className={`w-full text-xs font-medium ${theme.textPrimary} bg-transparent border-none outline-none -ml-0.5`}
          >
            <option value="low">Low</option>
            <option value="medium">Medium</option>
            <option value="high">High</option>
            <option value="critical">Critical</option>
          </select>
        </div>
        
        {/* Difficulty */}
        <div className={`p-2 rounded-lg ${darkMode ? 'bg-slate-700' : 'bg-white'} border ${darkMode ? 'border-slate-600' : 'border-slate-200'}`}>
          <div className="flex items-center gap-1 mb-1">
            <Zap className="w-3 h-3 text-purple-500" />
            <span className={`text-[10px] ${theme.textMuted} uppercase tracking-wider`}>Effort</span>
          </div>
          <select 
            value={task.difficulty || 'medium'} 
            onChange={(e) => updateTask(index, 'difficulty', e.target.value)}
            className={`w-full text-xs font-medium ${theme.textPrimary} bg-transparent border-none outline-none -ml-0.5`}
          >
            <option value="easy">Easy</option>
            <option value="medium">Medium</option>
            <option value="hard">Hard</option>
          </select>
        </div>
        
        {/* Time Estimate */}
        {showTime && (
          <div className={`p-2 rounded-lg ${darkMode ? 'bg-slate-700' : 'bg-white'} border ${darkMode ? 'border-slate-600' : 'border-slate-200'}`}>
            <div className="flex items-center gap-1 mb-1">
              <Clock className="w-3 h-3 text-blue-500" />
              <span className={`text-[10px] ${theme.textMuted} uppercase tracking-wider`}>Time</span>
            </div>
            <div className="flex items-baseline">
              <input 
                type="text"
                inputMode="numeric"
                value={task.timeEstimate || ''} 
                onChange={(e) => {
                  const val = e.target.value;
                  if (val === '' || /^\d+$/.test(val)) {
                    updateTask(index, 'timeEstimate', val === '' ? '' : parseInt(val));
                  }
                }}
                className={`w-8 text-xs font-medium ${theme.textPrimary} bg-transparent border-none outline-none`}
              />
              <span className={`text-[10px] ${theme.textMuted}`}>min</span>
            </div>
          </div>
        )}
      </div>
    );

    // Compact Metrics Row - for edit mode
    const renderCompactMetricsRow = (task, index) => (
      <div className="flex items-center gap-2 flex-wrap mt-2">
        <div className={`flex items-center gap-1 px-2 py-1 rounded text-xs ${darkMode ? 'bg-orange-900/30' : 'bg-orange-50'}`}>
          <Flame className="w-3 h-3 text-orange-500" />
          <select 
            value={task.importance || 'medium'} 
            onChange={(e) => updateTask(index, 'importance', e.target.value)}
            className={`bg-transparent border-none outline-none font-medium ${darkMode ? 'text-orange-400' : 'text-orange-700'}`}
          >
            <option value="low">Low</option>
            <option value="medium">Med</option>
            <option value="high">High</option>
            <option value="critical">Crit</option>
          </select>
        </div>
        <div className={`flex items-center gap-1 px-2 py-1 rounded text-xs ${darkMode ? 'bg-purple-900/30' : 'bg-purple-50'}`}>
          <Zap className="w-3 h-3 text-purple-500" />
          <select 
            value={task.difficulty || 'medium'} 
            onChange={(e) => updateTask(index, 'difficulty', e.target.value)}
            className={`bg-transparent border-none outline-none font-medium ${darkMode ? 'text-purple-400' : 'text-purple-700'}`}
          >
            <option value="easy">Easy</option>
            <option value="medium">Med</option>
            <option value="hard">Hard</option>
          </select>
        </div>
        <div className={`flex items-center gap-1 px-2 py-1 rounded text-xs ${darkMode ? 'bg-blue-900/30' : 'bg-blue-50'}`}>
          <Clock className="w-3 h-3 text-blue-500" />
          <input 
            type="text"
            inputMode="numeric"
            value={task.timeEstimate || ''} 
            onChange={(e) => {
              const val = e.target.value;
              if (val === '' || /^\d+$/.test(val)) {
                updateTask(index, 'timeEstimate', val === '' ? '' : parseInt(val));
              }
            }}
            className={`w-6 bg-transparent border-none outline-none font-medium ${darkMode ? 'text-blue-400' : 'text-blue-700'}`}
          />
          <span className={darkMode ? 'text-blue-400' : 'text-blue-600'}>m</span>
        </div>
      </div>
    );

    // Task Type Badge - as function
    const renderTaskTypeBadge = (type) => {
      const config = {
        checkbox: { Icon: CheckCircle2, bg: 'bg-green-100', color: 'text-green-600', label: 'Checkbox' },
        slider: { Icon: Sliders, bg: 'bg-blue-100', color: 'text-blue-600', label: 'Slider' },
        counter: { Icon: Hash, bg: 'bg-purple-100', color: 'text-purple-600', label: 'Counter' }
      };
      const c = config[type] || config.checkbox;
      return (
        <div className={`flex items-center gap-1 px-2 py-0.5 rounded ${darkMode ? 'bg-slate-700' : c.bg}`}>
          <c.Icon className={`w-3 h-3 ${c.color}`} />
          <span className={`text-[10px] font-medium uppercase ${c.color}`}>{c.label}</span>
        </div>
      );
    };

    return (
      <div className="fixed inset-0 bg-black/30 backdrop-blur-sm flex items-center justify-center z-50 p-4">
        <div 
          className={`${theme.cardBg} rounded-2xl w-full max-w-md shadow-xl`}
          style={{ maxHeight: '90vh', display: 'flex', flexDirection: 'column', overflow: 'hidden' }}
        >
          {/* Fixed Header */}
          <div className="px-5 pt-5 pb-3" style={{ flexShrink: 0 }}>
            <h3 className={`text-base font-semibold ${theme.textPrimary}`}>{isEditing ? 'Edit Goal' : 'New Goal'}</h3>
          </div>
          
          {/* Scrollable Content */}
          <div className="px-5 pb-4" style={{ flex: 1, overflowY: 'auto', minHeight: 0 }}>
            <div className="space-y-3">
              
              {/* Goal Title Card - INLINE */}
              <div className={cardClass}>
                <div className={cardHeaderClass}>
                  <div className={`w-7 h-7 rounded-lg ${darkMode ? 'bg-indigo-900/50' : 'bg-indigo-100'} flex items-center justify-center`}>
                    <Target className="w-4 h-4 text-indigo-500" />
                  </div>
                  <span className={`text-xs font-medium ${theme.textSecondary}`}>Goal</span>
                </div>
                <input 
                  type="text" 
                  value={formData.title} 
                  onChange={(e) => setFormData({ ...formData, title: e.target.value })}
                  className={`w-full text-sm font-medium ${theme.textPrimary} bg-transparent border-none outline-none`}
                  placeholder="What do you want to achieve?"
                />
              </div>

              {/* Yearly Target Card - INLINE */}
              <div className={cardClass}>
                <div className={cardHeaderClass}>
                  <div className={`w-7 h-7 rounded-lg ${darkMode ? 'bg-amber-900/50' : 'bg-amber-100'} flex items-center justify-center`}>
                    <Trophy className="w-4 h-4 text-amber-500" />
                  </div>
                  <span className={`text-xs font-medium ${theme.textSecondary}`}>Yearly Target</span>
                  <span className={`text-xs ${theme.textMuted} ml-auto`}>(optional)</span>
                </div>
                <input 
                  type="text" 
                  value={formData.yearlyGoal} 
                  onChange={(e) => setFormData({ ...formData, yearlyGoal: e.target.value })}
                  className={`w-full text-sm ${theme.textSecondary} bg-transparent border-none outline-none`}
                  placeholder="What's the big picture outcome?"
                />
              </div>

              {/* Category Card - INLINE */}
              <div className={cardClass}>
                <div className={cardHeaderClass}>
                  <div className={`w-7 h-7 rounded-lg ${darkMode ? 'bg-emerald-900/50' : 'bg-emerald-100'} flex items-center justify-center`}>
                    <Book className="w-4 h-4 text-emerald-500" />
                  </div>
                  <span className={`text-xs font-medium ${theme.textSecondary}`}>Category</span>
                </div>
                <select 
                  value={formData.category} 
                  onChange={(e) => setFormData({ ...formData, category: e.target.value })}
                  className={`w-full text-sm font-medium ${theme.textPrimary} bg-transparent border-none outline-none -ml-1`}
                >
                  {(categories || []).map(cat => (
                    <option key={cat.id} value={cat.id}>{cat.name}</option>
                  ))}
                </select>
              </div>

              {/* Goal Type Selector */}
              <div className={`p-3 rounded-xl ${theme.cardBg} border ${darkMode ? 'border-slate-700' : 'border-slate-200'}`}>
                <div className="flex items-center gap-2 mb-2">
                  <span className={`text-xs font-medium ${theme.textSecondary}`}>Goal Type</span>
                </div>
                <div className="flex gap-2">
                  <button
                    type="button"
                    onClick={() => setFormData({ ...formData, goalType: 'checkbox' })}
                    className={`flex-1 py-2 px-3 rounded-lg text-sm font-medium flex items-center justify-center gap-2 transition-all ${
                      formData.goalType === 'checkbox' ? theme.btnPrimary : theme.btnSecondary
                    }`}
                  >
                    <CheckCircle2 className="w-4 h-4" />
                    Checkbox
                  </button>
                  <button
                    type="button"
                    onClick={() => setFormData({ ...formData, goalType: 'points' })}
                    className={`flex-1 py-2 px-3 rounded-lg text-sm font-medium flex items-center justify-center gap-2 transition-all ${
                      formData.goalType === 'points' ? theme.btnPrimary : theme.btnSecondary
                    }`}
                  >
                    <Star className="w-4 h-4" />
                    Points
                  </button>
                </div>
              </div>

              {/* Points Target (only for points goals) - INLINE */}
              {formData.goalType === 'points' && (
                <div className={cardClass}>
                  <div className={cardHeaderClass}>
                    <div className={`w-7 h-7 rounded-lg ${darkMode ? 'bg-amber-900/50' : 'bg-amber-100'} flex items-center justify-center`}>
                      <Star className="w-4 h-4 text-amber-500" />
                    </div>
                    <span className={`text-xs font-medium ${theme.textSecondary}`}>Points Target</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <Star className="w-4 h-4 text-amber-500" />
                    <input 
                      type="text" 
                      inputMode="numeric"
                      pattern="[0-9]*"
                      value={formData.pointTarget || ''} 
                      onChange={(e) => {
                        const val = e.target.value;
                        if (val === '' || /^\d+$/.test(val)) {
                          setFormData({ ...formData, pointTarget: val === '' ? '' : parseInt(val) });
                        }
                      }}
                      onBlur={(e) => {
                        if (!e.target.value || parseInt(e.target.value) < 1) {
                          setFormData({ ...formData, pointTarget: 1 });
                        }
                      }}
                      className={`w-16 text-lg font-bold ${theme.textPrimary} bg-transparent border-none outline-none`}
                    />
                    <span className={`text-sm ${theme.textMuted}`}>points per</span>
                    <select 
                      value={formData.pointTargetFrequency} 
                      onChange={(e) => setFormData({ ...formData, pointTargetFrequency: e.target.value })}
                      className={`text-sm font-medium ${theme.textPrimary} ${theme.inputBg} rounded-lg px-2 py-1 border-none`}
                    >
                      <option value="daily">day</option>
                      <option value="weekly">week</option>
                    </select>
                  </div>
                </div>
              )}

              {/* Why / Motivation Card - INLINE */}
              <div className={cardClass}>
                <div className={cardHeaderClass}>
                  <div className={`w-7 h-7 rounded-lg ${darkMode ? 'bg-rose-900/50' : 'bg-rose-100'} flex items-center justify-center`}>
                    <Heart className="w-4 h-4 text-rose-500" />
                  </div>
                  <span className={`text-xs font-medium ${theme.textSecondary}`}>Why This Matters</span>
                  <span className={`text-xs ${theme.textMuted} ml-auto`}>(optional)</span>
                </div>
                <textarea 
                  value={formData.motivation || ''}
                  onChange={(e) => setFormData({ ...formData, motivation: e.target.value })}
                  className={`w-full text-sm ${theme.textSecondary} bg-transparent border-none outline-none resize-none`}
                  rows={2}
                  placeholder="Connect this goal to your deeper purpose..."
                />
              </div>

              {/* Tasks Divider */}
              <div className="flex items-center gap-2 py-2">
                <div className={`flex-1 h-px ${darkMode ? 'bg-slate-700' : 'bg-slate-200'}`} />
                <span className={`text-xs font-medium ${theme.textMuted}`}>
                  {formData.goalType === 'points' ? 'POINT-EARNING TASKS' : 'TASKS'}
                </span>
                <div className={`flex-1 h-px ${darkMode ? 'bg-slate-700' : 'bg-slate-200'}`} />
              </div>

              {/* Tasks List */}
              <div className="space-y-3">
                {formData.tasks.map((task, index) => (
                  <div key={task.id} className={`p-3 rounded-xl ${theme.inputBg} border ${darkMode ? 'border-slate-700' : 'border-slate-200'}`}>
                    
                    {/* Task Type Badge (for points goals) */}
                    {formData.goalType === 'points' && (
                      <div className="flex items-center justify-between mb-2">
                        {renderTaskTypeBadge(task.taskType || 'checkbox')}
                        {formData.tasks.length > 1 && (
                          <button 
                            type="button" 
                            onClick={() => setFormData({ ...formData, tasks: formData.tasks.filter((_, i) => i !== index) })}
                            className="p-1 text-red-400 hover:text-red-500 hover:bg-red-500/10 rounded"
                          >
                            <X className="w-4 h-4" />
                          </button>
                        )}
                      </div>
                    )}

                    {/* Task Name */}
                    <div className="flex items-start gap-2 mb-3">
                      <input 
                        type="text" 
                        value={task.action} 
                        onChange={(e) => updateTask(index, 'action', e.target.value)}
                        className={`flex-1 rounded-lg px-3 py-2 text-sm font-medium ${theme.cardBg} ${theme.textPrimary} border ${darkMode ? 'border-slate-600' : 'border-slate-200'}`}
                        placeholder="What's the action?"
                      />
                      {formData.goalType !== 'points' && formData.tasks.length > 1 && (
                        <button 
                          type="button" 
                          onClick={() => setFormData({ ...formData, tasks: formData.tasks.filter((_, i) => i !== index) })}
                          className="p-2 text-red-400 hover:text-red-500"
                        >
                          <X className="w-4 h-4" />
                        </button>
                      )}
                    </div>

                    {/* Metrics Row - use compact for edit mode, full for create */}
                    {isEditing ? (
                      renderCompactMetricsRow(task, index)
                    ) : (
                      renderMetricsRow(task, index, formData.goalType !== 'points' || task.taskType === 'checkbox' || !task.taskType)
                    )}

                    {/* Points Goal Specific Fields */}
                    {formData.goalType === 'points' && (
                      <div className="mt-3 space-y-2">
                        {/* Task Type Selector */}
                        <div className="flex items-center gap-2">
                          <span className={`text-xs ${theme.textMuted}`}>Type:</span>
                          <select 
                            value={task.taskType || 'checkbox'} 
                            onChange={(e) => { 
                              const newTasks = [...formData.tasks]; 
                              newTasks[index].taskType = e.target.value; 
                              if (e.target.value === 'slider') {
                                newTasks[index].maxValue = newTasks[index].maxValue || 10;
                                newTasks[index].pointsPerUnit = newTasks[index].pointsPerUnit || 1;
                              } else if (e.target.value === 'counter') {
                                newTasks[index].unitsPerPoint = newTasks[index].unitsPerPoint || 1;
                                newTasks[index].pointsPerUnit = newTasks[index].pointsPerUnit || 1;
                              }
                              setFormData({ ...formData, tasks: newTasks }); 
                            }} 
                            className={`flex-1 rounded-lg px-2 py-1.5 text-xs ${theme.cardBg} ${theme.textPrimary} border ${darkMode ? 'border-slate-600' : 'border-slate-200'}`}
                          >
                            <option value="checkbox">Checkbox (+X pts)</option>
                            <option value="slider">Slider (0 to max)</option>
                            <option value="counter">Counter (+/âˆ’)</option>
                          </select>
                        </div>

                        {/* Checkbox type - point value */}
                        {(!task.taskType || task.taskType === 'checkbox') && (
                          <div className={`flex items-center gap-2 p-2 rounded-lg ${darkMode ? 'bg-amber-900/20' : 'bg-amber-50'}`}>
                            <Star className="w-4 h-4 text-amber-500" />
                            <span className={`text-xs ${darkMode ? 'text-amber-400' : 'text-amber-700'}`}>Earns</span>
                            <input 
                              type="text" 
                              inputMode="numeric"
                              value={task.pointValue || ''} 
                              onChange={(e) => {
                                const val = e.target.value;
                                if (val === '' || /^\d+$/.test(val)) {
                                  updateTask(index, 'pointValue', val === '' ? '' : parseInt(val));
                                }
                              }}
                              onBlur={(e) => {
                                if (!e.target.value || parseInt(e.target.value) < 1) {
                                  updateTask(index, 'pointValue', 1);
                                }
                              }}
                              className={`w-12 text-sm font-bold ${darkMode ? 'text-amber-400 bg-slate-800' : 'text-amber-700 bg-white'} rounded px-2 py-0.5 border ${darkMode ? 'border-amber-800' : 'border-amber-200'}`}
                            />
                            <span className={`text-xs ${darkMode ? 'text-amber-400' : 'text-amber-700'}`}>points when done</span>
                          </div>
                        )}

                        {/* Slider type config */}
                        {task.taskType === 'slider' && (
                          <div className="space-y-2">
                            <div className={`p-2 rounded-lg ${darkMode ? 'bg-blue-900/20' : 'bg-blue-50'}`}>
                              <div className={`flex items-center gap-2 text-xs ${darkMode ? 'text-blue-400' : 'text-blue-700'}`}>
                                <span>Track 0 to</span>
                                <input 
                                  type="text" 
                                  inputMode="numeric"
                                  value={task.maxValue || ''} 
                                  onChange={(e) => {
                                    const val = e.target.value;
                                    if (val === '' || /^\d+$/.test(val)) {
                                      updateTask(index, 'maxValue', val === '' ? '' : parseInt(val));
                                    }
                                  }}
                                  className={`w-12 text-sm font-bold ${darkMode ? 'bg-slate-800 text-blue-400' : 'bg-white text-blue-700'} rounded px-2 py-0.5 border ${darkMode ? 'border-blue-800' : 'border-blue-200'}`}
                                />
                              </div>
                            </div>
                            <div className={`flex items-center gap-2 p-2 rounded-lg ${darkMode ? 'bg-amber-900/20' : 'bg-amber-50'}`}>
                              <Star className="w-4 h-4 text-amber-500" />
                              <span className={`text-xs ${darkMode ? 'text-amber-400' : 'text-amber-700'}`}>Each unit earns</span>
                              <input 
                                type="text" 
                                inputMode="numeric"
                                value={task.pointsPerUnit || ''} 
                                onChange={(e) => {
                                  const val = e.target.value;
                                  if (val === '' || /^\d+$/.test(val)) {
                                    updateTask(index, 'pointsPerUnit', val === '' ? '' : parseInt(val));
                                  }
                                }}
                                className={`w-10 text-sm font-bold ${darkMode ? 'text-amber-400 bg-slate-800' : 'text-amber-700 bg-white'} rounded px-2 py-0.5 border ${darkMode ? 'border-amber-800' : 'border-amber-200'}`}
                              />
                              <span className={`text-xs ${darkMode ? 'text-amber-400' : 'text-amber-700'}`}>point(s)</span>
                            </div>
                          </div>
                        )}

                        {/* Counter type config */}
                        {task.taskType === 'counter' && (
                          <div className="space-y-2">
                            <div className={`p-2 rounded-lg ${darkMode ? 'bg-purple-900/20' : 'bg-purple-50'}`}>
                              <div className={`flex items-center gap-1 text-xs ${darkMode ? 'text-purple-400' : 'text-purple-700'} flex-wrap`}>
                                <span>Every</span>
                                <input 
                                  type="text" 
                                  inputMode="numeric"
                                  value={task.unitsPerPoint || ''} 
                                  onChange={(e) => {
                                    const val = e.target.value;
                                    if (val === '' || /^\d+$/.test(val)) {
                                      updateTask(index, 'unitsPerPoint', val === '' ? '' : parseInt(val));
                                    }
                                  }}
                                  className={`w-10 text-sm font-bold ${darkMode ? 'bg-slate-800 text-purple-400' : 'bg-white text-purple-700'} rounded px-2 py-0.5 border ${darkMode ? 'border-purple-800' : 'border-purple-200'}`}
                                />
                                <input 
                                  type="text" 
                                  value={task.unitLabel || ''} 
                                  onChange={(e) => updateTask(index, 'unitLabel', e.target.value)}
                                  placeholder="min"
                                  className={`w-12 text-sm ${darkMode ? 'bg-slate-800 text-purple-400' : 'bg-white text-purple-700'} rounded px-2 py-0.5 border ${darkMode ? 'border-purple-800' : 'border-purple-200'}`}
                                />
                                <span>=</span>
                                <Star className="w-3.5 h-3.5 text-amber-500" />
                                <input 
                                  type="text" 
                                  inputMode="numeric"
                                  value={task.pointsPerUnit || ''} 
                                  onChange={(e) => {
                                    const val = e.target.value;
                                    if (val === '' || /^\d+$/.test(val)) {
                                      updateTask(index, 'pointsPerUnit', val === '' ? '' : parseInt(val));
                                    }
                                  }}
                                  className={`w-10 text-sm font-bold ${darkMode ? 'bg-slate-800 text-amber-400' : 'bg-white text-amber-700'} rounded px-2 py-0.5 border ${darkMode ? 'border-amber-800' : 'border-amber-200'}`}
                                />
                                <span>pts</span>
                              </div>
                            </div>
                          </div>
                        )}
                      </div>
                    )}

                    {/* Frequency (checkbox goals only) */}
                    {formData.goalType !== 'points' && (
                      <div className="grid grid-cols-2 gap-2 mt-3">
                        <div>
                          <label className={`block text-[10px] ${theme.textMuted} uppercase tracking-wider mb-1`}>Frequency</label>
                          <select 
                            value={task.frequency} 
                            onChange={(e) => updateTask(index, 'frequency', e.target.value)}
                            className={`w-full rounded-lg px-2 py-1.5 text-xs ${theme.cardBg} ${theme.textPrimary} border ${darkMode ? 'border-slate-600' : 'border-slate-200'}`}
                          >
                            <option value="daily">Daily</option>
                            <option value="weekly">Weekly</option>
                            <option value="scheduled">Scheduled</option>
                          </select>
                        </div>
                        {task.frequency === 'scheduled' ? (
                          <div className="col-span-1">
                            <label className={`block text-[10px] ${theme.textMuted} uppercase tracking-wider mb-1`}>Days</label>
                            <div className="flex gap-1">
                              {['S','M','T','W','T','F','S'].map((dayLabel, dayIndex) => {
                                const isSelected = (task.scheduledDays || []).includes(dayIndex);
                                return (
                                  <button
                                    key={dayIndex}
                                    type="button"
                                    onClick={() => {
                                      const current = task.scheduledDays || [];
                                      const updated = isSelected 
                                        ? current.filter(d => d !== dayIndex)
                                        : [...current, dayIndex].sort();
                                      updateTask(index, 'scheduledDays', updated);
                                    }}
                                    className={`w-7 h-7 rounded-full text-[10px] font-medium transition-all ${
                                      isSelected 
                                        ? (darkMode ? 'bg-slate-200 text-slate-900' : 'bg-slate-700 text-white')
                                        : (darkMode ? 'bg-slate-700 text-slate-400' : 'bg-slate-100 text-slate-400')
                                    }`}
                                  >
                                    {dayLabel}
                                  </button>
                                );
                              })}
                            </div>
                          </div>
                        ) : (
                        <div>
                          <label className={`block text-[10px] ${theme.textMuted} uppercase tracking-wider mb-1`}>
                            {task.frequency === 'weekly' ? 'Target/week' : 'Times/day'}
                          </label>
                          <input 
                            type="text" 
                            inputMode="numeric"
                            value={task.frequency === 'weekly' ? (task.weeklyTarget || '') : (task.dailyChecks || '')} 
                            onChange={(e) => {
                              const val = e.target.value;
                              if (val === '' || /^\d+$/.test(val)) {
                                const field = task.frequency === 'weekly' ? 'weeklyTarget' : 'dailyChecks';
                                const max = task.frequency === 'weekly' ? 7 : 10;
                                updateTask(index, field, val === '' ? '' : Math.min(max, parseInt(val)));
                              }
                            }}
                            onBlur={(e) => {
                              if (!e.target.value || parseInt(e.target.value) < 1) {
                                const field = task.frequency === 'weekly' ? 'weeklyTarget' : 'dailyChecks';
                                updateTask(index, field, 1);
                              }
                            }}
                            className={`w-full rounded-lg px-2 py-1.5 text-xs ${theme.cardBg} ${theme.textPrimary} border ${darkMode ? 'border-slate-600' : 'border-slate-200'}`}
                          />
                        </div>
                        )}
                      </div>
                    )}

                    {/* Prompt for note/photo */}
                    <div className="flex items-center gap-2 mt-3">
                      <input 
                        type="checkbox" 
                        id={`prompt-${task.id}`} 
                        checked={task.promptForNote || false} 
                        onChange={(e) => updateTask(index, 'promptForNote', e.target.checked)}
                        className="w-3.5 h-3.5 rounded" 
                      />
                      <label htmlFor={`prompt-${task.id}`} className={`text-xs ${theme.textMuted}`}>Prompt for note/photo</label>
                    </div>
                  </div>
                ))}
              </div>

              {/* Add Task Button */}
              <button 
                type="button"
                onClick={() => setFormData({ 
                  ...formData, 
                  tasks: [...formData.tasks, { 
                    id: Date.now(), 
                    action: '', 
                    frequency: 'daily', 
                    weeklyTarget: 4, 
                    dailyChecks: 1, 
                    pointValue: 1,
                    importance: 'medium',
                    difficulty: 'medium',
                    timeEstimate: 15
                  }] 
                })}
                className={`w-full py-2.5 rounded-xl border-2 border-dashed ${darkMode ? 'border-slate-600 text-slate-400 hover:border-slate-500' : 'border-slate-300 text-slate-500 hover:border-slate-400'} text-sm font-medium flex items-center justify-center gap-2`}
              >
                <Plus className="w-4 h-4" />
                Add Task
              </button>

            </div>
          </div>
          
          {/* Fixed Footer */}
          <div className={`px-5 pb-5 pt-4 border-t ${theme.divider}`} style={{ flexShrink: 0 }}>
            <div className="flex gap-2">
              <button onClick={() => onSave(formData)} className={`flex-1 py-2.5 rounded-lg text-sm font-medium ${theme.btnPrimary}`}>
                {isEditing ? 'Save Changes' : 'Create Goal'}
              </button>
              <button onClick={onCancel} className={`px-4 py-2.5 rounded-lg text-sm font-medium ${theme.btnSecondary}`}>Cancel</button>
            </div>
          </div>
        </div>
      </div>
    );
  };

  // ============================================
  // CALENDAR VIEW (Week / Month / Year)
  // ============================================
  const getHeatColor = useCallback((pct) => {
    if (pct === 0) return darkMode ? '#1e293b' : '#f1f5f9';
    if (pct < 50) return '#fb923c';
    if (pct < 75) return '#facc15';
    const t = (pct - 75) / 25;
    const r = Math.round(134 - (134 - 34) * t);
    const g = Math.round(239 - (239 - 197) * t);
    const b = Math.round(172 - (172 - 94) * t);
    return `rgb(${r}, ${g}, ${b})`;
  }, [darkMode]);

  const getHeatTextColor = useCallback((pct, isFuture) => {
    if (isFuture) return darkMode ? '#475569' : '#cbd5e1';
    if (pct >= 75) return '#166534';
    if (pct >= 50) return '#854d0e';
    if (pct > 0) return '#9a3412';
    return darkMode ? '#94a3b8' : '#64748b';
  }, [darkMode]);

  const getHeatSubColor = useCallback((pct) => {
    if (pct >= 75) return '#15803d';
    return darkMode ? '#64748b' : '#94a3b8';
  }, [darkMode]);

  const CalendarView = () => {
    const goToDay = (date) => { setSelectedDate(date); setCurrentView('daily'); };
    const todayKey = toLocalDateKey(new Date());

    // ---- Date navigation helpers ----
    const changeWeek = (offset) => {
      const newDate = new Date(calendarDate);
      newDate.setDate(newDate.getDate() + offset * 7);
      setCalendarDate(newDate);
    };
    const changeMonth = (offset) => {
      const newDate = new Date(calendarDate);
      newDate.setMonth(newDate.getMonth() + offset);
      setCalendarDate(newDate);
    };
    const changeYear = (offset) => {
      const newDate = new Date(calendarDate);
      newDate.setFullYear(newDate.getFullYear() + offset);
      setCalendarDate(newDate);
    };

    // ---- Week data ----
    const getWeekDays = () => {
      const { weekStart } = getWeekRange(calendarDate);
      const days = [];
      for (let i = 0; i < 7; i++) {
        const d = new Date(weekStart);
        d.setDate(weekStart.getDate() + i);
        const dateKey = toLocalDateKey(d);
        const progress = calculateDailyProgress(dateKey);
        const isFuture = dateKey > todayKey;
        const isToday = dateKey === todayKey;
        const hasJournal = journalConfig.prompts.some(p => { const v = journalEntries[`${dateKey}-${p.id}`]; return v && (typeof v === 'string' ? v.trim().length > 0 : true); });
        const hasPhoto = !!dailyPhotos[dateKey];
        // Scheduled tasks for this day
        const scheduledTasks = [];
        goals.forEach(g => {
          if (!g.tasks) return;
          g.tasks.forEach(t => {
            if (t.frequency === 'scheduled' && isTaskScheduledForDate(t, d)) {
              scheduledTasks.push(t.action);
            }
          });
        });
        days.push({ date: d, dateKey, label: d.toLocaleDateString('en-US', { weekday: 'short' }), dayNum: d.getDate(), progress, isFuture, isToday, hasJournal, hasPhoto, scheduledTasks });
      }
      return days;
    };

    const weekDays = calendarMode === 'week' ? getWeekDays() : [];

    // ---- Week header label ----
    const getWeekLabel = () => {
      if (weekDays.length === 0) return '';
      const s = weekDays[0].date;
      const e = weekDays[6].date;
      if (s.getMonth() === e.getMonth()) {
        return `${s.toLocaleDateString('en-US', { month: 'long' })} ${s.getDate()} â€“ ${e.getDate()}`;
      }
      return `${s.toLocaleDateString('en-US', { month: 'long' })} ${s.getDate()} â€“ ${e.toLocaleDateString('en-US', { month: 'long' })} ${e.getDate()}`;
    };

    // Check if showing current week/month/year
    const isCurrentWeek = () => {
      const today = new Date();
      const { weekStart: currentWeekStart } = getWeekRange(today);
      const { weekStart: viewingWeekStart } = getWeekRange(calendarDate);
      return toLocalDateKey(currentWeekStart) === toLocalDateKey(viewingWeekStart);
    };

    // ---- Navigation label ----
    const navLabel = calendarMode === 'week' ? getWeekLabel()
      : calendarMode === 'month' ? calendarDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })
      : `${calendarDate.getFullYear()}`;
    
    const isThisWeek = calendarMode === 'week' && isCurrentWeek();
    const navSub = calendarMode === 'week' 
      ? (isThisWeek ? 'This week' : calendarDate.getFullYear().toString())
      : calendarMode === 'month' ? '' : '';

    const navPrev = () => { calendarMode === 'week' ? changeWeek(-1) : calendarMode === 'month' ? changeMonth(-1) : changeYear(-1); };
    const navNext = () => { calendarMode === 'week' ? changeWeek(1) : calendarMode === 'month' ? changeMonth(1) : changeYear(1); };

    // ==== WEEKLY VIEW ====
    const WeeklyCalendar = () => {
      const weekTotal = weekDays.reduce((s, d) => s + d.progress.total, 0);
      const weekDone = weekDays.reduce((s, d) => s + d.progress.completed, 0);
      const weekPct = weekTotal > 0 ? Math.round(weekDone / weekTotal * 100) : 0;
      const journalDays = weekDays.filter(d => d.hasJournal).length;
      const photoDays = weekDays.filter(d => d.hasPhoto).length;
      const scheduledDays = weekDays.filter(d => d.scheduledTasks.length > 0);

      // Journal slider prompts
      const sliderPrompts = journalConfig.prompts.filter(p => p.type === 'slider');

      // Category progress for this week
      const categoryProgress = (categories || []).map(cat => {
        const catGoals = goals.filter(g => g.category === cat.id && g.goalType !== 'points');
        if (catGoals.length === 0) return null;
        let totalAll = 0, totalDone = 0;
        const dailyBars = weekDays.map(day => {
          let dayTotal = 0, dayDone = 0;
          catGoals.forEach(goal => {
            if (!goal.tasks) return;
            goal.tasks.forEach(task => {
              if ((!task.frequency || task.frequency === 'daily') || (task.frequency === 'scheduled' && isTaskScheduledForDate(task, day.date))) {
                const checks = task.dailyChecks || 1;
                dayTotal += checks;
                for (let c = 0; c < checks; c++) {
                  if (dailyTasks[day.dateKey]?.[`${goal.id}-${task.id}-${c}`]) dayDone++;
                }
              }
            });
          });
          totalAll += dayTotal;
          totalDone += dayDone;
          return dayTotal > 0 ? dayDone / dayTotal : 0;
        });
        const pct = totalAll > 0 ? Math.round(totalDone / totalAll * 100) : 0;
        return { ...cat, pct, dailyBars };
      }).filter(Boolean);

      return (
        <>
          {/* Heat map calendar card */}
          <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
            <div className="p-3 pb-2.5">
              <div className="grid grid-cols-7 gap-1.5">
                {weekDays.map((day, i) => {
                  const pct = day.progress.percentage;
                  const bgColor = day.isFuture ? (darkMode ? '#0f172a' : '#f8fafc') : getHeatColor(pct);
                  const textColor = getHeatTextColor(pct, day.isFuture);
                  const subColor = getHeatSubColor(pct);
                  return (
                    <div key={i} onClick={() => goToDay(day.date)} className="text-center cursor-pointer">
                      <div style={{ fontSize: 10, fontWeight: 600, marginBottom: 3, color: day.isToday ? '#6366f1' : (darkMode ? '#64748b' : '#94a3b8') }}>
                        {day.label}
                      </div>
                      <div style={{
                        borderRadius: 10, background: bgColor, padding: '10px 2px 8px',
                        border: day.isToday ? '2px solid #6366f1' : '2px solid transparent',
                        transition: 'all 0.3s'
                      }}>
                        <div style={{ fontSize: 14, fontWeight: 700, lineHeight: 1, color: textColor }}>
                          {day.dayNum}
                        </div>
                        {!day.isFuture && day.progress.total > 0 && (
                          <div style={{ fontSize: 9, color: subColor, fontWeight: 600, marginTop: 3 }}>
                            {day.progress.completed}/{day.progress.total}
                          </div>
                        )}
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
            {/* Summary strip */}
            <div className={`px-3.5 py-2.5 border-t ${theme.divider} flex justify-around`}>
              {[
                { value: `${weekPct}%`, label: 'complete' },
                { value: `${journalDays}/7`, label: 'journaled' },
                { value: `${photoDays}/7`, label: 'photos' },
              ].map((s, i) => (
                <div key={i} className="text-center">
                  <div className={`text-base font-bold ${theme.textPrimary}`}>{s.value}</div>
                  <div className={`text-[9px] ${theme.textMuted}`}>{s.label}</div>
                </div>
              ))}
            </div>
          </div>

          {/* Scheduled tasks */}
          {scheduledDays.length > 0 && (
            <div>
              <p className={`text-[11px] font-semibold uppercase tracking-wider mb-2 ml-1 ${theme.textMuted}`}>Scheduled</p>
              <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
                {scheduledDays.map((day, i) => (
                  <div key={i} className={`flex items-center gap-2.5 px-3.5 py-2.5 ${i < scheduledDays.length - 1 ? `border-b ${theme.divider}` : ''}`}
                    style={{ opacity: day.isFuture ? 0.6 : 1 }}>
                    <div className={`w-8 h-8 rounded-lg flex flex-col items-center justify-center flex-shrink-0 ${day.isToday ? 'bg-indigo-50' : theme.inputBg}`}
                      style={day.isToday ? { background: darkMode ? '#312e81' : '#eef2ff' } : {}}>
                      <div style={{ fontSize: 8, fontWeight: 600, color: day.isToday ? '#6366f1' : (darkMode ? '#64748b' : '#94a3b8'), lineHeight: 1 }}>{day.label}</div>
                      <div style={{ fontSize: 12, fontWeight: 700, color: day.isToday ? '#6366f1' : (darkMode ? '#cbd5e1' : '#475569'), lineHeight: 1.2 }}>{day.dayNum}</div>
                    </div>
                    <div className="flex-1 flex flex-wrap gap-1">
                      {day.scheduledTasks.map((s, j) => (
                        <span key={j} className={`text-xs px-2.5 py-0.5 rounded-lg font-medium ${theme.inputBg} ${theme.textSecondary}`}>{s}</span>
                      ))}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Journal slider trends (bar charts) */}
          {sliderPrompts.length > 0 && (
            <div>
              <p className={`text-[11px] font-semibold uppercase tracking-wider mb-2 ml-1 ${theme.textMuted}`}>Journal Trends</p>
              <div className={`${theme.cardBg} rounded-xl shadow-sm p-3.5`}>
                {sliderPrompts.map((slider, sliderIdx) => {
                  const values = weekDays.map(d => {
                    const v = journalEntries[`${d.dateKey}-${slider.id}`];
                    return v !== undefined && v !== '' ? Number(v) : null;
                  });
                  const validValues = values.filter(v => v !== null);
                  const avg = validValues.length > 0 ? (validValues.reduce((a, b) => a + b, 0) / validValues.length).toFixed(1) : null;
                  const maxVal = slider.max || 10;

                  return (
                    <div key={slider.id} className={sliderIdx < sliderPrompts.length - 1 ? 'mb-4' : ''}>
                      <div className="flex justify-between items-center mb-1.5">
                        <span className={`text-xs font-semibold ${theme.textSecondary}`}>{slider.label}</span>
                        {avg && <span className={`text-xs font-bold ${theme.textPrimary}`}>avg {avg}</span>}
                      </div>
                      <div className="flex items-end gap-1.5" style={{ height: 44 }}>
                        {weekDays.map((day, i) => {
                          const val = values[i];
                          const h = val !== null ? (val / maxVal) * 40 : 0;
                          const pctOfMax = val !== null ? val / maxVal : 0;
                          const barColor = pctOfMax >= 0.7 ? '#86efac' : pctOfMax >= 0.5 ? '#fde68a' : pctOfMax > 0 ? '#fdba74' : (darkMode ? '#1e293b' : '#f1f5f9');
                          return (
                            <div key={i} className="flex-1 flex flex-col items-center">
                              {val !== null && <div className={`text-[9px] font-semibold mb-0.5 ${theme.textMuted}`}>{val}</div>}
                              <div style={{
                                width: '100%', height: Math.max(h, 3), borderRadius: 4,
                                background: barColor, transition: 'height 0.5s'
                              }} />
                            </div>
                          );
                        })}
                      </div>
                      <div className="flex gap-1.5 mt-1">
                        {weekDays.map((d, i) => (
                          <div key={i} className={`flex-1 text-center text-[9px] font-medium ${theme.textMuted}`}>{d.label.charAt(0)}</div>
                        ))}
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          )}

          {/* Categories with rhythm bars */}
          {categoryProgress.length > 0 && (
            <div>
              <p className={`text-[11px] font-semibold uppercase tracking-wider mb-2 ml-1 ${theme.textMuted}`}>Categories</p>
              <div className={`${theme.cardBg} rounded-xl shadow-sm py-1`}>
                {categoryProgress.map((cat) => (
                  <div key={cat.id} className="flex items-center gap-2 px-3.5 py-2">
                    <div className="w-1.5 h-1.5 rounded-full flex-shrink-0" style={{ backgroundColor: cat.color }} />
                    <span className={`text-xs font-medium flex-1 truncate ${theme.textSecondary}`}>{cat.name}</span>
                    <div className="flex gap-0.5 flex-shrink-0">
                      {cat.dailyBars.map((pct, i) => (
                        <div key={i} style={{
                          width: 8, height: 18, borderRadius: 3,
                          background: pct === 0 ? (darkMode ? '#1e293b' : '#f1f5f9') : cat.color,
                          opacity: pct === 0 ? 1 : 0.3 + pct * 0.7
                        }} />
                      ))}
                    </div>
                    <span className={`text-[11px] font-bold w-8 text-right flex-shrink-0 ${theme.textPrimary}`}>{cat.pct}%</span>
                  </div>
                ))}
              </div>
            </div>
          )}
        </>
      );
    };

    // ==== MONTHLY VIEW ====
    const MonthlyCalendar = () => {
      const year = calendarDate.getFullYear();
      const month = calendarDate.getMonth();
      const monthKey = `${year}-${String(month + 1).padStart(2, '0')}`;
      const firstDay = new Date(year, month, 1);
      const lastDay = new Date(year, month + 1, 0);
      const daysInMonth = lastDay.getDate();
      const startingDayOfWeek = firstDay.getDay();
      
      // Previous month for comparison
      const prevMonthDate = new Date(year, month - 1, 1);
      const prevMonthKey = `${prevMonthDate.getFullYear()}-${String(prevMonthDate.getMonth() + 1).padStart(2, '0')}`;
      const prevMonthName = prevMonthDate.toLocaleDateString('en-US', { month: 'long' });
      
      // Local state for intention editing
      const [isEditingIntention, setIsEditingIntention] = useState(false);
      const [intentionDraft, setIntentionDraft] = useState(monthlyIntentions[monthKey] || '');
      
      // Build calendar cells
      const cells = [];
      for (let i = 0; i < startingDayOfWeek; i++) cells.push(null);
      for (let day = 1; day <= daysInMonth; day++) cells.push(day);
      
      // Calculate days passed (for current month, it's today; for past months, it's all days)
      const today = new Date();
      const isCurrentMonth = year === today.getFullYear() && month === today.getMonth();
      const daysPassed = isCurrentMonth ? today.getDate() : daysInMonth;
      
      // Build day data with stats
      const dayData = [];
      let totalCompleted = 0, totalExpected = 0, daysWithActivity = 0, daysJournaled = 0;
      let bestDay = { day: 1, pct: 0 }, perfectDays = 0, currentStreak = 0, longestStreak = 0, tempStreak = 0;
      const distribution = { high: 0, medium: 0, low: 0, zero: 0 };
      
      for (let day = 1; day <= daysInMonth; day++) {
        const date = new Date(year, month, day);
        const dateKey = toLocalDateKey(date);
        const isFuture = dateKey > todayKey;
        const progress = calculateDailyProgress(dateKey);
        const hasJournal = journalConfig.prompts.some(p => { 
          const v = journalEntries[`${dateKey}-${p.id}`]; 
          return v && (typeof v === 'string' ? v.trim().length > 0 : true); 
        });
        
        dayData.push({ day, dateKey, progress, isFuture, isToday: dateKey === todayKey, hasJournal });
        
        if (!isFuture) {
          totalCompleted += progress.completed;
          totalExpected += progress.total;
          if (progress.completed > 0) daysWithActivity++;
          if (hasJournal) daysJournaled++;
          
          const pct = progress.percentage;
          if (pct > bestDay.pct) bestDay = { day, pct };
          if (pct === 100) perfectDays++;
          
          // Distribution
          if (pct >= 80) distribution.high++;
          else if (pct >= 50) distribution.medium++;
          else if (pct > 0) distribution.low++;
          else distribution.zero++;
          
          // Streak calculation
          if (pct > 0) {
            tempStreak++;
            if (tempStreak > longestStreak) longestStreak = tempStreak;
          } else {
            tempStreak = 0;
          }
        }
      }
      
      // Current streak (counting back from today/end of month)
      for (let day = daysPassed; day >= 1; day--) {
        const dateKey = toLocalDateKey(new Date(year, month, day));
        const progress = calculateDailyProgress(dateKey);
        if (progress.percentage > 0) currentStreak++;
        else break;
      }
      
      const overallPct = totalExpected > 0 ? Math.round((totalCompleted / totalExpected) * 100) : 0;
      const consistencyScore = daysPassed > 0 ? Math.round((daysWithActivity / daysPassed) * 100) : 0;
      
      // Previous month stats for comparison
      const prevMonthLastDay = new Date(prevMonthDate.getFullYear(), prevMonthDate.getMonth() + 1, 0).getDate();
      let prevCompleted = 0, prevExpected = 0, prevDaysWithActivity = 0;
      for (let day = 1; day <= prevMonthLastDay; day++) {
        const dateKey = toLocalDateKey(new Date(prevMonthDate.getFullYear(), prevMonthDate.getMonth(), day));
        const progress = calculateDailyProgress(dateKey);
        prevCompleted += progress.completed;
        prevExpected += progress.total;
        if (progress.completed > 0) prevDaysWithActivity++;
      }
      const prevOverallPct = prevExpected > 0 ? Math.round((prevCompleted / prevExpected) * 100) : 0;
      const prevConsistency = prevMonthLastDay > 0 ? Math.round((prevDaysWithActivity / prevMonthLastDay) * 100) : 0;
      const pctChange = overallPct - prevOverallPct;
      const consistencyChange = consistencyScore - prevConsistency;
      
      // Build weeks data
      const weeksData = [];
      let weekStart = new Date(year, month, 1);
      // Adjust to Sunday start
      weekStart.setDate(weekStart.getDate() - weekStart.getDay());
      
      while (weekStart.getMonth() <= month || (weekStart.getMonth() === 0 && month === 11)) {
        const weekEnd = new Date(weekStart);
        weekEnd.setDate(weekStart.getDate() + 6);
        
        // Only include weeks that have days in this month
        if (weekEnd.getMonth() < month && weekEnd.getFullYear() === year) {
          weekStart.setDate(weekStart.getDate() + 7);
          continue;
        }
        if (weekStart.getMonth() > month && weekStart.getFullYear() === year) break;
        if (weekStart.getFullYear() > year) break;
        
        let weekCompleted = 0, weekExpected = 0;
        const weekIsFuture = toLocalDateKey(weekStart) > todayKey;
        
        for (let d = new Date(weekStart); d <= weekEnd; d.setDate(d.getDate() + 1)) {
          if (d.getMonth() !== month) continue;
          const dateKey = toLocalDateKey(d);
          if (dateKey > todayKey) continue;
          const progress = calculateDailyProgress(dateKey);
          weekCompleted += progress.completed;
          weekExpected += progress.total;
        }
        
        const weekPct = weekExpected > 0 ? Math.round((weekCompleted / weekExpected) * 100) : 0;
        const startLabel = `${weekStart.toLocaleDateString('en-US', { month: 'short' })} ${weekStart.getDate()}`;
        const endLabel = `${weekEnd.toLocaleDateString('en-US', { month: 'short' })} ${weekEnd.getDate()}`;
        
        weeksData.push({ startLabel, endLabel, percentage: weekPct, completed: weekCompleted, total: weekExpected, isFuture: weekIsFuture });
        weekStart.setDate(weekStart.getDate() + 7);
        
        if (weeksData.length > 6) break; // Safety limit
      }
      
      const bestWeekPct = Math.max(...weeksData.filter(w => !w.isFuture).map(w => w.percentage), 0);
      
      // Journal slider trends (weekly averages)
      const sliderPrompts = journalConfig.prompts.filter(p => p.type === 'slider');
      const journalTrends = sliderPrompts.map(prompt => {
        const weeklyAvgs = weeksData.map((week, wi) => {
          if (week.isFuture) return null;
          let sum = 0, count = 0;
          const ws = new Date(year, month, 1);
          ws.setDate(ws.getDate() - ws.getDay() + wi * 7);
          for (let i = 0; i < 7; i++) {
            const d = new Date(ws);
            d.setDate(ws.getDate() + i);
            if (d.getMonth() !== month) continue;
            const dateKey = toLocalDateKey(d);
            if (dateKey > todayKey) continue;
            const val = journalEntries[`${dateKey}-${prompt.id}`];
            if (val !== undefined && val !== null && val !== '') {
              sum += Number(val);
              count++;
            }
          }
          return count > 0 ? Math.round((sum / count) * 10) / 10 : null;
        });
        return { label: prompt.label, weeklyAvgs, max: prompt.max || 10 };
      });
      
      // Category progress (weekly)
      const categoryProgress = categories.map(cat => {
        const catGoals = goals.filter(g => g.category === cat.id);
        if (catGoals.length === 0) return null;
        
        const weeklyPcts = weeksData.map((week, wi) => {
          if (week.isFuture) return 0;
          let completed = 0, expected = 0;
          const ws = new Date(year, month, 1);
          ws.setDate(ws.getDate() - ws.getDay() + wi * 7);
          
          catGoals.forEach(goal => {
            if (!goal.tasks) return;
            goal.tasks.forEach(task => {
              for (let i = 0; i < 7; i++) {
                const d = new Date(ws);
                d.setDate(ws.getDate() + i);
                if (d.getMonth() !== month) continue;
                const dateKey = toLocalDateKey(d);
                if (dateKey > todayKey) continue;
                
                if (!task.frequency || task.frequency === 'daily') {
                  const checks = task.dailyChecks || 1;
                  expected += checks;
                  for (let c = 0; c < checks; c++) {
                    if (dailyTasks[dateKey]?.[`${goal.id}-${task.id}-${c}`]) completed++;
                  }
                } else if (task.frequency === 'scheduled' && isTaskScheduledForDate(task, d)) {
                  expected++;
                  if (dailyTasks[dateKey]?.[`${goal.id}-${task.id}-0`]) completed++;
                }
              }
            });
          });
          
          return expected > 0 ? Math.round((completed / expected) * 100) : 0;
        });
        
        const avgPct = weeklyPcts.filter(p => p > 0).length > 0
          ? Math.round(weeklyPcts.filter(p => p > 0).reduce((a, b) => a + b, 0) / weeklyPcts.filter(p => p > 0).length)
          : 0;
        
        return { ...cat, weeklyPcts, avgPct };
      }).filter(Boolean);
      
      // Find worst performing goal (needs attention)
      const goalPerformance = goals.map(goal => {
        if (!goal.tasks || goal.tasks.length === 0) return null;
        let completed = 0, expected = 0;
        
        for (let day = 1; day <= daysPassed; day++) {
          const dateKey = toLocalDateKey(new Date(year, month, day));
          goal.tasks.forEach(task => {
            if (!task.frequency || task.frequency === 'daily') {
              const checks = task.dailyChecks || 1;
              expected += checks;
              for (let c = 0; c < checks; c++) {
                if (dailyTasks[dateKey]?.[`${goal.id}-${task.id}-${c}`]) completed++;
              }
            } else if (task.frequency === 'scheduled') {
              const d = new Date(year, month, day);
              if (isTaskScheduledForDate(task, d)) {
                expected++;
                if (dailyTasks[dateKey]?.[`${goal.id}-${task.id}-0`]) completed++;
              }
            }
          });
        }
        
        const pct = expected > 0 ? Math.round((completed / expected) * 100) : 100;
        const cat = categories.find(c => c.id === goal.category);
        return { ...goal, pct, categoryName: cat?.name || 'Uncategorized', categoryColor: cat?.color || '#64748b' };
      }).filter(Boolean);
      
      const worstGoal = goalPerformance.length > 0 
        ? goalPerformance.reduce((min, g) => g.pct < min.pct ? g : min, goalPerformance[0])
        : null;
      
      // Save intention
      const saveIntention = () => {
        setMonthlyIntentions(prev => ({ ...prev, [monthKey]: intentionDraft }));
        setIsEditingIntention(false);
      };

      return (
        <div className="space-y-3">
          {/* Monthly Intention */}
          <div className={`${theme.cardBg} rounded-xl shadow-sm p-3.5`}>
            <div className="flex items-center justify-between mb-2">
              <div className="flex items-center gap-1.5">
                <span className="text-sm">ðŸŽ¯</span>
                <span className={`text-[11px] font-bold uppercase tracking-wider ${theme.textMuted}`}>Monthly Intention</span>
              </div>
              <button 
                onClick={() => {
                  if (isEditingIntention) saveIntention();
                  else {
                    setIntentionDraft(monthlyIntentions[monthKey] || '');
                    setIsEditingIntention(true);
                  }
                }}
                className="text-[10px] font-semibold text-indigo-500"
              >
                {isEditingIntention ? 'Save' : 'Edit'}
              </button>
            </div>
            {isEditingIntention ? (
              <textarea
                value={intentionDraft}
                onChange={(e) => setIntentionDraft(e.target.value)}
                placeholder="What's your focus this month?"
                className={`w-full rounded-lg px-3 py-2 text-sm resize-none ${theme.inputBg} ${theme.textPrimary}`}
                rows={2}
                autoFocus
              />
            ) : (
              <p className={`text-[13px] leading-relaxed ${monthlyIntentions[monthKey] ? theme.textSecondary : theme.textMuted}`}>
                {monthlyIntentions[monthKey] || <span className="italic">Tap edit to set your monthly intention...</span>}
              </p>
            )}
          </div>

          {/* Calendar + Summary */}
          <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
            {/* Calendar Grid */}
            <div className="p-3">
              <div className="grid grid-cols-7 gap-1 mb-2">
                {['S', 'M', 'T', 'W', 'T', 'F', 'S'].map((d, i) => (
                  <div key={i} className={`text-center text-[10px] font-semibold py-1 ${theme.textMuted}`}>{d}</div>
                ))}
              </div>
              <div className="grid grid-cols-7 gap-1">
                {cells.map((day, index) => {
                  if (!day) return <div key={`empty-${index}`} className="aspect-square" />;
                  const dd = dayData[day - 1];
                  const pct = dd.progress.percentage;
                  const bgColor = dd.isFuture ? (darkMode ? '#0f172a' : '#f8fafc') : getHeatColor(pct);
                  const textColor = getHeatTextColor(pct, dd.isFuture);
                  return (
                    <button key={day} onClick={() => goToDay(new Date(year, month, day))}
                      className="aspect-square flex items-center justify-center transition-all"
                      style={{ borderRadius: 8, background: bgColor, border: dd.isToday ? '2px solid #6366f1' : '2px solid transparent' }}>
                      <span style={{ fontSize: 12, fontWeight: 600, color: textColor }}>{day}</span>
                    </button>
                  );
                })}
              </div>
            </div>
            
            {/* Summary Strip */}
            <div className={`px-3.5 py-2.5 border-t ${theme.divider}`}>
              <div className={`text-[11px] font-bold uppercase tracking-wider text-center mb-2.5 ${theme.textSecondary}`}>
                vs {prevMonthName}
              </div>
              <div className="flex justify-around">
                {[
                  { value: `${overallPct}%`, label: 'complete', change: pctChange },
                  { value: `${consistencyScore}%`, label: 'consistency', change: consistencyChange },
                  { value: `${daysJournaled}/${daysPassed}`, label: 'journaled' },
                  { value: `${currentStreak}d`, label: 'streak' },
                ].map((s, i) => (
                  <div key={i} className="text-center">
                    <div className="flex items-center justify-center gap-1">
                      <span className={`text-[15px] font-bold ${theme.textPrimary}`}>{s.value}</span>
                      {s.change !== undefined && (
                        <span className={`text-[9px] font-bold px-1 py-0.5 rounded ${
                          s.change >= 0 ? 'text-emerald-600 bg-emerald-100' : 'text-red-600 bg-red-100'
                        } ${darkMode && (s.change >= 0 ? 'bg-emerald-900/50 text-emerald-400' : 'bg-red-900/50 text-red-400')}`}>
                          {s.change >= 0 ? '+' : ''}{s.change}%
                        </span>
                      )}
                    </div>
                    <div className={`text-[9px] ${theme.textMuted}`}>{s.label}</div>
                  </div>
                ))}
              </div>
            </div>
          </div>

          {/* Day Distribution */}
          <div>
            <p className={`text-[11px] font-bold uppercase tracking-wider mb-2 pl-1 ${theme.textMuted}`}>Day Distribution</p>
            <div className={`${theme.cardBg} rounded-xl shadow-sm p-3.5`}>
              <div className="flex items-end gap-2 h-20 mb-2">
                {[
                  { label: '80-100%', count: distribution.high, color: '#22c55e' },
                  { label: '50-79%', count: distribution.medium, color: '#facc15' },
                  { label: '1-49%', count: distribution.low, color: '#fb923c' },
                  { label: '0%', count: distribution.zero, color: darkMode ? '#334155' : '#e2e8f0' },
                ].map((bucket, i) => {
                  const maxCount = Math.max(distribution.high, distribution.medium, distribution.low, distribution.zero, 1);
                  const height = (bucket.count / maxCount) * 60;
                  return (
                    <div key={i} className="flex-1 flex flex-col items-center">
                      <span className={`text-[11px] font-bold mb-1 ${theme.textPrimary}`}>{bucket.count}</span>
                      <div className="w-full rounded-md" style={{ height: Math.max(height, 4), background: bucket.color }} />
                    </div>
                  );
                })}
              </div>
              <div className="flex gap-2">
                {['80-100%', '50-79%', '1-49%', '0%'].map((label, i) => (
                  <div key={i} className={`flex-1 text-center text-[9px] font-medium ${theme.textMuted}`}>{label}</div>
                ))}
              </div>
              <div className={`text-center mt-2.5 text-[10px] ${theme.textSecondary}`}>
                <span className="font-semibold">{distribution.high}</span> great days, <span className="font-semibold">{distribution.medium}</span> good days
              </div>
            </div>
          </div>

          {/* Weeks */}
          <div>
            <p className={`text-[11px] font-bold uppercase tracking-wider mb-2 pl-1 ${theme.textMuted}`}>Weeks</p>
            <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
              {weeksData.map((week, i) => {
                const barColor = week.isFuture ? (darkMode ? '#334155' : '#e2e8f0') : getHeatColor(week.percentage);
                const isBest = !week.isFuture && week.percentage === bestWeekPct && week.percentage > 0;
                return (
                  <div key={i} className={`px-3.5 py-3 ${i < weeksData.length - 1 ? `border-b ${theme.divider}` : ''} ${week.isFuture ? 'opacity-50' : ''}`}>
                    <div className="flex items-center justify-between mb-1.5">
                      <div className="flex items-center gap-2">
                        <span className={`text-[13px] font-semibold ${theme.textPrimary}`}>{week.startLabel} â€“ {week.endLabel}</span>
                        {isBest && <span className="text-[9px] font-semibold text-emerald-600 bg-emerald-100 px-1.5 py-0.5 rounded">BEST</span>}
                      </div>
                      <span className={`text-[13px] font-bold ${week.isFuture ? theme.textMuted : theme.textPrimary}`}>{week.percentage}%</span>
                    </div>
                    <div className={`h-1.5 rounded-full ${theme.progressBg}`}>
                      <div className="h-full rounded-full transition-all" style={{ width: `${week.percentage}%`, background: barColor }} />
                    </div>
                    {!week.isFuture && week.total > 0 && (
                      <p className={`text-[10px] mt-1 ${theme.textMuted}`}>{week.completed} of {week.total} tasks</p>
                    )}
                  </div>
                );
              })}
            </div>
          </div>

          {/* Highlights */}
          <div>
            <p className={`text-[11px] font-bold uppercase tracking-wider mb-2 pl-1 ${theme.textMuted}`}>Highlights</p>
            <div className={`${theme.cardBg} rounded-xl shadow-sm p-3.5`}>
              <div className="grid grid-cols-2 gap-2.5">
                {[
                  { icon: 'ðŸ†', value: bestDay.pct > 0 ? `${calendarDate.toLocaleDateString('en-US', { month: 'short' })} ${bestDay.day}` : '-', label: `Best day (${bestDay.pct}%)` },
                  { icon: 'âœ¨', value: perfectDays, label: 'Perfect days' },
                  { icon: 'ðŸ”¥', value: `${longestStreak}d`, label: 'Longest streak' },
                  { icon: 'âœ“', value: totalCompleted, label: 'Tasks done' },
                ].map((h, i) => (
                  <div key={i} className={`flex items-center gap-2.5 p-2.5 rounded-lg ${theme.inputBg}`}>
                    <span className="text-base">{h.icon}</span>
                    <div>
                      <div className={`text-sm font-bold ${theme.textPrimary}`}>{h.value}</div>
                      <div className={`text-[9px] ${theme.textMuted}`}>{h.label}</div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </div>

          {/* Journal Trends */}
          {journalTrends.length > 0 && (
            <div>
              <p className={`text-[11px] font-bold uppercase tracking-wider mb-2 pl-1 ${theme.textMuted}`}>Journal Trends</p>
              <div className={`${theme.cardBg} rounded-xl shadow-sm p-3.5`}>
                {journalTrends.map((trend, ti) => {
                  const validAvgs = trend.weeklyAvgs.filter(v => v !== null);
                  const overallAvg = validAvgs.length > 0 ? (validAvgs.reduce((a, b) => a + b, 0) / validAvgs.length).toFixed(1) : null;
                  return (
                    <div key={ti} className={ti < journalTrends.length - 1 ? 'mb-4' : ''}>
                      <div className="flex justify-between items-center mb-1.5">
                        <span className={`text-xs font-semibold ${theme.textSecondary}`}>{trend.label}</span>
                        {overallAvg && <span className={`text-[11px] font-bold ${theme.textPrimary}`}>avg {overallAvg}</span>}
                      </div>
                      <div className="flex items-end gap-2 h-12">
                        {trend.weeklyAvgs.map((avg, i) => {
                          const h = avg !== null ? (avg / trend.max) * 44 : 0;
                          const pctOfMax = avg !== null ? avg / trend.max : 0;
                          const barColor = pctOfMax >= 0.7 ? '#86efac' : pctOfMax >= 0.5 ? '#fde68a' : pctOfMax > 0 ? '#fdba74' : (darkMode ? '#1e293b' : '#f1f5f9');
                          return (
                            <div key={i} className="flex-1 flex flex-col items-center">
                              {avg !== null && <span className={`text-[9px] font-semibold mb-0.5 ${theme.textMuted}`}>{avg}</span>}
                              <div className="w-full rounded" style={{ height: Math.max(h, 4), background: barColor }} />
                            </div>
                          );
                        })}
                      </div>
                      <div className="flex gap-2 mt-1">
                        {weeksData.map((_, i) => (
                          <div key={i} className={`flex-1 text-center text-[9px] font-medium ${theme.textMuted}`}>Wk {i + 1}</div>
                        ))}
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          )}

          {/* Categories */}
          {categoryProgress.length > 0 && (
            <div>
              <p className={`text-[11px] font-bold uppercase tracking-wider mb-2 pl-1 ${theme.textMuted}`}>Categories</p>
              <div className={`${theme.cardBg} rounded-xl shadow-sm py-1.5`}>
                {categoryProgress.map((cat) => (
                  <div key={cat.id} className="flex items-center gap-2.5 px-3.5 py-2.5">
                    <div className="w-1.5 h-1.5 rounded-full flex-shrink-0" style={{ background: cat.color }} />
                    <span className={`text-xs font-medium flex-1 ${theme.textSecondary}`}>{cat.name}</span>
                    <div className="flex gap-1 flex-shrink-0">
                      {cat.weeklyPcts.map((pct, i) => (
                        <div key={i} className="w-3.5 h-6 rounded" style={{
                          background: pct === 0 ? (darkMode ? '#0f172a' : '#f1f5f9') : cat.color,
                          opacity: pct === 0 ? 1 : 0.3 + (pct / 100) * 0.7
                        }} />
                      ))}
                    </div>
                    <span className={`text-[11px] font-bold w-8 text-right ${theme.textPrimary}`}>{cat.avgPct}%</span>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Goal Needing Attention */}
          {worstGoal && worstGoal.pct < 60 && (
            <div className="rounded-xl p-3.5" style={{ 
              background: `linear-gradient(135deg, ${worstGoal.categoryColor}15, ${worstGoal.categoryColor}05)`,
              border: `1px solid ${worstGoal.categoryColor}30`
            }}>
              <div className="flex items-center gap-2 mb-2">
                <span className="text-sm">âš ï¸</span>
                <span className={`text-[11px] font-bold uppercase tracking-wider ${theme.textMuted}`}>Needs Attention</span>
              </div>
              <div className="flex items-center justify-between">
                <div>
                  <div className={`text-sm font-semibold ${theme.textPrimary}`}>{worstGoal.title}</div>
                  <div className={`text-[11px] ${theme.textMuted}`}>{worstGoal.categoryName}</div>
                </div>
                <div className="text-right">
                  <div className="text-xl font-extrabold" style={{ color: worstGoal.categoryColor }}>{worstGoal.pct}%</div>
                  <div className={`text-[9px] ${theme.textMuted}`}>this month</div>
                </div>
              </div>
              <div className="mt-2.5 h-1.5 rounded-full" style={{ background: `${worstGoal.categoryColor}20` }}>
                <div className="h-full rounded-full" style={{ width: `${worstGoal.pct}%`, background: worstGoal.categoryColor }} />
              </div>
            </div>
          )}
        </div>
      );
    };

    // ==== YEARLY VIEW ====
    const YearlyCalendar = () => {
      const year = calendarDate.getFullYear();
      const jan1 = new Date(year, 0, 1);
      const startOffset = jan1.getDay(); // 0=Sun
      const isLeap = (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
      const totalDays = isLeap ? 366 : 365;

      // Build weeks (columns) of 7 days
      const weeks = [];
      let currentWeek = [];
      // Pad first week
      for (let i = 0; i < startOffset; i++) currentWeek.push(null);
      for (let d = 0; d < totalDays; d++) {
        const date = new Date(year, 0, d + 1);
        const dateKey = toLocalDateKey(date);
        const progress = calculateDailyProgress(dateKey);
        const isFuture = dateKey > todayKey;
        currentWeek.push({ date, dateKey, pct: progress.percentage, isFuture });
        if (currentWeek.length === 7) {
          weeks.push(currentWeek);
          currentWeek = [];
        }
      }
      if (currentWeek.length > 0) {
        while (currentWeek.length < 7) currentWeek.push(null);
        weeks.push(currentWeek);
      }

      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

      return (
        <div className={`${theme.cardBg} rounded-xl shadow-sm p-3 overflow-x-auto`}>
          {/* Month labels */}
          <div className="flex mb-1.5" style={{ paddingLeft: 18 }}>
            {months.map((m, i) => (
              <div key={i} style={{ width: `${100 / 12}%`, fontSize: 9, fontWeight: 600 }} className={theme.textMuted}>{m}</div>
            ))}
          </div>
          <div className="flex gap-0.5">
            {/* Day labels */}
            <div className="flex flex-col gap-0.5 mr-1 pt-0">
              {['', 'M', '', 'W', '', 'F', ''].map((d, i) => (
                <div key={i} style={{ width: 14, height: 8, fontSize: 8 }} className={`flex items-center ${theme.textMuted}`}>{d}</div>
              ))}
            </div>
            {/* Grid */}
            <div className="flex-1 flex gap-0.5">
              {weeks.map((week, wi) => (
                <div key={wi} className="flex flex-col gap-0.5">
                  {week.map((cell, di) => {
                    if (!cell) return <div key={di} style={{ width: 8, height: 8 }} />;
                    const bgColor = cell.isFuture ? (darkMode ? '#0f172a' : '#f8fafc') : getHeatColor(cell.pct);
                    return (
                      <div key={di}
                        onClick={() => !cell.isFuture && goToDay(cell.date)}
                        style={{ width: 8, height: 8, borderRadius: 2, background: bgColor, cursor: cell.isFuture ? 'default' : 'pointer' }}
                      />
                    );
                  })}
                </div>
              ))}
            </div>
          </div>
          {/* Legend */}
          <div className="flex justify-end items-center gap-1 mt-2.5">
            <span className={`text-[9px] ${theme.textMuted}`}>Less</span>
            {[0, 30, 50, 75, 100].map(pct => (
              <div key={pct} style={{ width: 8, height: 8, borderRadius: 2, background: getHeatColor(pct) }} />
            ))}
            <span className={`text-[9px] ${theme.textMuted}`}>More</span>
          </div>
        </div>
      );
    };

    return (
      <div className="space-y-3">
        {/* Date Navigator */}
        <div className="flex items-center justify-between py-2">
          <button onClick={navPrev} className={`w-8 h-8 rounded-full ${theme.btnIcon} shadow-sm flex items-center justify-center`}>
            <ChevronLeft className="w-4 h-4" />
          </button>
          <div className="text-center">
            <p className={`text-lg font-semibold ${theme.textPrimary}`}>{navLabel}</p>
            {navSub && <p className={`text-xs ${isThisWeek ? 'text-emerald-500 font-medium' : theme.textMuted}`}>{navSub}</p>}
          </div>
          <button onClick={navNext} className={`w-8 h-8 rounded-full ${theme.btnIcon} shadow-sm flex items-center justify-center`}>
            <ChevronRight className="w-4 h-4" />
          </button>
        </div>

        {/* Week / Month / Year switcher */}
        <div className={`${theme.cardBg} rounded-xl shadow-sm p-1 flex gap-1`}>
          {[
            { id: 'week', label: 'Week' },
            { id: 'month', label: 'Month' },
            { id: 'year', label: 'Year' },
          ].map(v => (
            <button
              key={v.id}
              onClick={() => setCalendarMode(v.id)}
              className={`flex-1 py-1.5 rounded-lg text-xs font-semibold transition-all ${
                calendarMode === v.id ? theme.btnPrimary : theme.textMuted
              }`}
            >
              {v.label}
            </button>
          ))}
        </div>

        {/* Calendar content */}
        {calendarMode === 'week' && <WeeklyCalendar />}
        {calendarMode === 'month' && <MonthlyCalendar />}
        {calendarMode === 'year' && <YearlyCalendar />}
      </div>
    );
  };

  // ============================================
  // DAILY VIEW - Unified Design with Points Goals
  // ============================================
  const DailyView = () => {
    const dateKey = selectedDateKey;
    const todayMedia = media[dateKey] || [];
    const [showMediaForm, setShowMediaForm] = useState(false);
    const [mediaForm, setMediaForm] = useState({ type: 'book', title: '', notes: '' });
    const [collapsedGoals, setCollapsedGoals] = useState(new Set());
    const changeDate = (days) => { const newDate = new Date(selectedDate); newDate.setDate(newDate.getDate() + days); setSelectedDate(newDate); };

    const toggleGoalCollapse = (goalId) => {
      setCollapsedGoals(prev => {
        const newSet = new Set(prev);
        if (newSet.has(goalId)) {
          newSet.delete(goalId);
        } else {
          newSet.add(goalId);
        }
        return newSet;
      });
    };

    // Build unified task list sorted by category (including daily points goals)
    const buildUnifiedTaskList = () => {
      const items = [];
      
      goals.forEach(goal => {
        if (!goal.tasks || !Array.isArray(goal.tasks)) return;
        
        // Handle points-based goals with daily target
        if (goal.goalType === 'points') {
          if (goal.pointTargetFrequency !== 'daily' && goal.pointTargetFrequency !== undefined) return;
          
          const category = categories.find(c => c.id === goal.category);
          const categoryColor = category?.color || '#64748b';
          const categoryOrder = categories.findIndex(c => c.id === goal.category);
          
          const pointsEarned = calculatePointsEarnedForDate(dateKey, goal);
          const pointTarget = goal.pointTarget || 10;
          const percentage = Math.min(100, Math.round((pointsEarned / pointTarget) * 100));
          
          items.push({
            type: 'points',
            goal,
            tasks: goal.tasks,
            categoryColor,
            categoryOrder: categoryOrder === -1 ? 999 : categoryOrder,
            pointsEarned,
            pointTarget,
            percentage,
            isDaily: true,
            isPointsGoal: true
          });
          return;
        }
        
        // Handle checkbox goals
        const goalDailyTasks = goal.tasks.filter(t => {
          if (!t.frequency || t.frequency === 'daily') return true;
          if (t.frequency === 'scheduled') return isTaskScheduledForDate(t, selectedDate);
          return false;
        });
        if (goalDailyTasks.length === 0) return;
        
        const category = categories.find(c => c.id === goal.category);
        const categoryColor = category?.color || '#64748b';
        const categoryOrder = categories.findIndex(c => c.id === goal.category);
        
        let totalChecks = 0;
        let completedChecks = 0;
        goalDailyTasks.forEach(task => {
          const checks = task.dailyChecks || 1;
          totalChecks += checks;
          completedChecks += getTaskCompletionCount(dateKey, goal.id, task.id, checks);
        });
        const percentage = totalChecks > 0 ? Math.round((completedChecks / totalChecks) * 100) : 0;
        
        items.push({
          type: goalDailyTasks.length === 1 ? 'single' : 'group',
          goal,
          tasks: goalDailyTasks,
          categoryColor,
          categoryOrder: categoryOrder === -1 ? 999 : categoryOrder,
          percentage,
          completedChecks,
          totalChecks,
          isDaily: true,
          isPointsGoal: false
        });
      });
      
      // Sort: by category first, then singles before groups within each category
      items.sort((a, b) => {
        // Primary sort by category
        if (a.categoryOrder !== b.categoryOrder) {
          return a.categoryOrder - b.categoryOrder;
        }
        // Within same category, singles come before groups/points
        const aIsSingle = a.type === 'single';
        const bIsSingle = b.type === 'single';
        if (aIsSingle && !bIsSingle) return -1;
        if (!aIsSingle && bIsSingle) return 1;
        return 0;
      });
      return items;
    };

    // Build unified weekly task list sorted by category (including weekly points goals)
    const buildUnifiedWeeklyTaskList = () => {
      const items = [];
      const weekKey = getWeekKey(selectedDate);
      
      goals.forEach(goal => {
        if (!goal.tasks || !Array.isArray(goal.tasks)) return;
        
        // Handle points-based goals with weekly target
        if (goal.goalType === 'points') {
          if (goal.pointTargetFrequency !== 'weekly') return;
          
          const category = categories.find(c => c.id === goal.category);
          const categoryColor = category?.color || '#64748b';
          const categoryOrder = categories.findIndex(c => c.id === goal.category);
          
          // Calculate weekly points using weekKey (data is stored by week, not by day)
          const weeklyPointsEarned = calculatePointsEarnedForWeek(weekKey, goal);
          
          const pointTarget = goal.pointTarget || 10;
          const percentage = Math.min(100, Math.round((weeklyPointsEarned / pointTarget) * 100));
          
          items.push({
            type: 'points',
            goal,
            tasks: goal.tasks,
            categoryColor,
            categoryOrder: categoryOrder === -1 ? 999 : categoryOrder,
            pointsEarned: weeklyPointsEarned,
            pointTarget,
            percentage,
            isDaily: false,
            isPointsGoal: true
          });
          return;
        }
        
        // Handle checkbox goals
        const goalWeeklyTasks = goal.tasks.filter(t => t.frequency === 'weekly');
        if (goalWeeklyTasks.length === 0) return;
        
        const category = categories.find(c => c.id === goal.category);
        const categoryColor = category?.color || '#64748b';
        const categoryOrder = categories.findIndex(c => c.id === goal.category);
        
        let totalTarget = 0;
        let totalCompleted = 0;
        goalWeeklyTasks.forEach(task => {
          const progress = calculateWeeklyProgress(task, goal.id, selectedDate);
          totalTarget += progress.target;
          totalCompleted += progress.completed;
        });
        const percentage = totalTarget > 0 ? Math.round((totalCompleted / totalTarget) * 100) : 0;
        
        items.push({
          type: goalWeeklyTasks.length === 1 ? 'single' : 'group',
          goal,
          tasks: goalWeeklyTasks,
          categoryColor,
          categoryOrder: categoryOrder === -1 ? 999 : categoryOrder,
          percentage,
          totalCompleted,
          totalTarget,
          isDaily: false,
          isPointsGoal: false
        });
      });
      
      // Sort: by category first, then singles before groups within each category
      items.sort((a, b) => {
        // Primary sort by category
        if (a.categoryOrder !== b.categoryOrder) {
          return a.categoryOrder - b.categoryOrder;
        }
        // Within same category, singles come before groups/points
        const aIsSingle = a.type === 'single';
        const bIsSingle = b.type === 'single';
        if (aIsSingle && !bIsSingle) return -1;
        if (!aIsSingle && bIsSingle) return 1;
        return 0;
      });
      return items;
    };

    const dailyItems = buildUnifiedTaskList();
    const weeklyItems = buildUnifiedWeeklyTaskList();

    // Check if task/goal is fully complete
    const isGoalComplete = (item) => {
      if (item.isPointsGoal) {
        return item.pointsEarned >= item.pointTarget;
      }
      if (item.isDaily) {
        return item.completedChecks === item.totalChecks && item.totalChecks > 0;
      } else {
        return item.totalCompleted >= item.totalTarget && item.totalTarget > 0;
      }
    };

    // Calculate streak for a task (consecutive days of completion)
    const calculateTaskStreak = (goalId, taskId, totalChecks = 1) => {
      const isCompletedOnDate = (date) => {
        const dk = toLocalDateKey(date);
        const tasks = dailyTasks[dk] || {};
        for (let i = 0; i < totalChecks; i++) {
          if (!tasks[`${goalId}-${taskId}-${i}`]) return false;
        }
        return true;
      };
      
      let checkDate = new Date(selectedDate);
      const completedToday = isCompletedOnDate(checkDate);
      
      checkDate.setDate(checkDate.getDate() - 1);
      let streakFromYesterday = 0;
      
      for (let i = 0; i < 365; i++) {
        if (isCompletedOnDate(checkDate)) {
          streakFromYesterday++;
          checkDate.setDate(checkDate.getDate() - 1);
        } else {
          break;
        }
      }
      
      return completedToday ? streakFromYesterday + 1 : streakFromYesterday;
    };

    // Render task row for unified list
    const renderTaskRow = (goal, task, isDaily, isLast, isChild = false, categoryColor, isPointsGoal = false, showBorder = true) => {
      // For weekly points goals, use week key for storage
      const isWeeklyPointsGoal = goal?.goalType === 'points' && goal?.pointTargetFrequency === 'weekly';
      const storageKey = isWeeklyPointsGoal ? getWeekKey(selectedDate) : dateKey;
      
      // Get task type for points goals
      const taskType = isPointsGoal ? (task.taskType || 'checkbox') : 'checkbox';
      
      // For points goals, tasks don't have individual daily checks - just one checkbox each
      const totalChecks = isPointsGoal ? 1 : (isDaily ? (task.dailyChecks || 1) : 1);
      const completedCount = isPointsGoal 
        ? (dailyTasks[storageKey]?.[`${goal.id}-${task.id}-0`] ? 1 : 0)
        : (isDaily 
            ? getTaskCompletionCount(dateKey, goal.id, task.id, totalChecks, goal)
            : (isTaskCompleted(dateKey, goal.id, task.id, goal) ? 1 : 0));
      const weekProgress = (!isDaily && !isPointsGoal) ? calculateWeeklyProgress(task, goal.id, selectedDate) : null;
      const isComplete = completedCount === totalChecks;
      
      // Keep category border color unfaded for completed tasks
      const borderColor = categoryColor;
      
      // A7 style: completed tasks get darker background + inset shadow
      const completedBg = isComplete ? 'rgba(100, 116, 139, 0.12)' : 'transparent';
      const completedShadow = isComplete ? 'inset 0 2px 4px rgba(0,0,0,0.04)' : 'none';
      
      // Child rows (subtasks) don't have a left border
      const rowStyle = isChild 
        ? { paddingLeft: '2rem', backgroundColor: completedBg, boxShadow: completedShadow }
        : { borderLeft: `3px solid ${borderColor}`, paddingLeft: '0.75rem', backgroundColor: completedBg, boxShadow: completedShadow };

      // Handle slider task type for points goals
      if (isPointsGoal && taskType === 'slider') {
        const maxValue = task.maxValue || 10;
        const pointsPerUnit = task.pointsPerUnit || 1;
        const currentValue = getVariableTaskValue(dateKey, goal.id, task.id, 'value', goal);
        const earnedPoints = currentValue * pointsPerUnit;
        const sliderHasValue = currentValue > 0;
        
        // A7 style for slider
        const sliderBg = sliderHasValue ? 'rgba(100, 116, 139, 0.12)' : 'transparent';
        const sliderShadow = sliderHasValue ? 'inset 0 2px 4px rgba(0,0,0,0.04)' : 'none';
        const sliderRowStyle = isChild 
          ? { paddingLeft: '2rem', backgroundColor: sliderBg, boxShadow: sliderShadow }
          : { borderLeft: `3px solid ${borderColor}`, paddingLeft: '0.75rem', backgroundColor: sliderBg, boxShadow: sliderShadow };
        
        return (
          <div 
            key={task.id}
            className="py-2.5"
            style={sliderRowStyle}
          >
            <div className="flex items-center justify-between mb-1.5">
              <span className={`text-sm ${currentValue > 0 ? 'text-slate-600' : theme.textPrimary}`}>{task.action}</span>
              <span className={`text-xs font-medium px-1.5 py-0.5 rounded ${earnedPoints > 0 ? 'bg-emerald-500/10 text-emerald-500' : 'bg-amber-500/10 text-amber-500'}`}>
                +{earnedPoints}
              </span>
            </div>
            <div className="flex items-center gap-2 mr-3">
              <input
                type="range"
                min="0"
                max={maxValue}
                value={currentValue}
                onChange={(e) => setVariableTaskValue(dateKey, goal.id, task.id, 'value', parseInt(e.target.value), goal)}
                className="flex-1 h-1.5 rounded-full appearance-none cursor-pointer"
                style={{ background: darkMode ? '#334155' : '#e2e8f0' }}
              />
              <span className={`text-xs font-medium w-10 text-right ${theme.textSecondary}`}>{currentValue}/{maxValue}</span>
            </div>
          </div>
        );
      }

      // Handle counter task type for points goals
      if (isPointsGoal && taskType === 'counter') {
        const unitsPerPoint = task.unitsPerPoint || 1;
        const pointsPerUnit = task.pointsPerUnit || 1;
        const unitLabel = task.unitLabel || '';
        const currentCount = getVariableTaskValue(dateKey, goal.id, task.id, 'count', goal);
        const earnedPoints = Math.floor(currentCount / unitsPerPoint) * pointsPerUnit;
        const counterHasValue = currentCount > 0;
        
        // A7 style for counter
        const counterBg = counterHasValue ? 'rgba(100, 116, 139, 0.12)' : 'transparent';
        const counterShadow = counterHasValue ? 'inset 0 2px 4px rgba(0,0,0,0.04)' : 'none';
        const counterRowStyle = isChild 
          ? { paddingLeft: '2rem', backgroundColor: counterBg, boxShadow: counterShadow }
          : { borderLeft: `3px solid ${borderColor}`, paddingLeft: '0.75rem', backgroundColor: counterBg, boxShadow: counterShadow };
        
        return (
          <div 
            key={task.id}
            className="py-2.5"
            style={counterRowStyle}
          >
            <div className="flex items-center justify-between">
              <span className={`text-sm flex-1 ${currentCount > 0 ? 'text-slate-600' : theme.textPrimary}`}>{task.action}</span>
              <div className="flex items-center gap-2 mr-3">
                <button
                  onClick={(e) => { e.stopPropagation(); setVariableTaskValue(dateKey, goal.id, task.id, 'count', currentCount - unitsPerPoint, goal); }}
                  className={`w-7 h-7 rounded-full flex items-center justify-center ${darkMode ? 'bg-slate-700 text-slate-300' : 'bg-slate-200 text-slate-600'}`}
                >
                  <Minus className="w-3.5 h-3.5" />
                </button>
                <span className={`text-sm font-medium min-w-[3rem] text-center ${theme.textPrimary}`}>
                  {currentCount}{unitLabel ? ` ${unitLabel}` : ''}
                </span>
                <button
                  onClick={(e) => { e.stopPropagation(); setVariableTaskValue(dateKey, goal.id, task.id, 'count', currentCount + unitsPerPoint, goal); }}
                  className={`w-7 h-7 rounded-full flex items-center justify-center ${darkMode ? 'bg-slate-700 text-slate-300' : 'bg-slate-200 text-slate-600'}`}
                >
                  <Plus className="w-3.5 h-3.5" />
                </button>
                <span className={`text-xs font-medium px-1.5 py-0.5 rounded ml-1 ${earnedPoints > 0 ? 'bg-emerald-500/10 text-emerald-500' : 'bg-amber-500/10 text-amber-500'}`}>
                  +{earnedPoints}
                </span>
              </div>
            </div>
          </div>
        );
      }

      // Single checkbox row (daily tasks with 1 check, or checkbox points goal tasks)
      if ((isDaily && totalChecks === 1) || isPointsGoal) {
        const taskKey = `${goal.id}-${task.id}-0`;
        const isChecked = dailyTasks[storageKey]?.[taskKey];
        const streak = isDaily ? calculateTaskStreak(goal.id, task.id, 1) : 0;
        return (
          <div 
            key={task.id}
            className={`flex items-center gap-3 py-2.5 cursor-pointer ${animatingTasks[taskKey] ? 'task-row-animate' : ''}`}
            style={rowStyle}
            onClick={() => toggleTask(dateKey, goal.id, task.id, 0, task, goal)}
          >
            <span className={`text-sm flex-1 ${isChecked ? 'text-slate-600' : theme.textPrimary}`}>{task.action}</span>
            {streak >= 5 && (
              <span className="text-xs text-orange-500 flex items-center gap-0.5 flex-shrink-0">
                <Flame className="w-3 h-3" />{streak}
              </span>
            )}
            {isPointsGoal && (
              <span className={`text-xs font-medium px-1.5 py-0.5 rounded ${isChecked ? 'bg-emerald-500/10 text-emerald-500' : 'bg-amber-500/10 text-amber-500'}`}>
                +{task.pointValue || 1}
              </span>
            )}
            {taskCompletions[`${storageKey}-${goal.id}-${task.id}-0`] && (
              <button onClick={(e) => { e.stopPropagation(); setViewingCompletion({ completion: taskCompletions[`${storageKey}-${goal.id}-${task.id}-0`], taskName: task.action }); }} className="w-2 h-2 rounded-full bg-blue-400 flex-shrink-0" />
            )}
            <div className={`flex-shrink-0 mr-3 ${animatingTasks[taskKey] ? 'checkbox-animate' : ''}`}>
              {isChecked ? (
                <CheckCircle2 className="w-5 h-5 text-emerald-500" />
              ) : (
                <Circle className={`w-5 h-5 ${theme.checkUndone}`} />
              )}
            </div>
          </div>
        );
      } else if (isDaily) {
        // Multiple checkbox daily task (checkbox goals only)
        const rowAnimating = Array.from({ length: totalChecks }).some((_, i) => animatingTasks[`${goal.id}-${task.id}-${i}`]);
        const streak = calculateTaskStreak(goal.id, task.id, totalChecks);
        return (
          <div 
            key={task.id}
            className={`flex items-center gap-3 py-2.5 ${rowAnimating ? 'task-row-animate' : ''}`}
            style={rowStyle}
          >
            <span className={`text-sm flex-1 ${isComplete ? 'text-slate-600' : theme.textPrimary}`}>{task.action}</span>
            {streak >= 5 && (
              <span className="text-xs text-orange-500 flex items-center gap-0.5 flex-shrink-0">
                <Flame className="w-3 h-3" />{streak}
              </span>
            )}
            <span className={`text-xs ${theme.textMuted}`}>{completedCount}/{totalChecks}</span>
            <div className="flex gap-1.5 flex-shrink-0 mr-3">
              {Array.from({ length: totalChecks }).map((_, checkIndex) => {
                const taskKey = `${goal.id}-${task.id}-${checkIndex}`;
                const isChecked = dailyTasks[dateKey]?.[taskKey];
                return (
                  <button 
                    key={checkIndex} 
                    onClick={() => toggleTask(dateKey, goal.id, task.id, checkIndex, task, goal)}
                    className={animatingTasks[taskKey] ? 'checkbox-animate' : ''}
                  >
                    {isChecked ? (
                      <CheckCircle2 className="w-5 h-5 text-emerald-500" />
                    ) : (
                      <Circle className={`w-5 h-5 ${theme.checkUndone}`} />
                    )}
                  </button>
                );
              })}
            </div>
          </div>
        );
      } else {
        // Weekly checkbox task
        const isCheckedToday = isTaskCompleted(dateKey, goal.id, task.id, goal);
        const taskKey = `${goal.id}-${task.id}-0`;
        return (
          <div 
            key={task.id}
            className={`flex items-center gap-3 py-2.5 cursor-pointer ${animatingTasks[taskKey] ? 'task-row-animate' : ''}`}
            style={rowStyle}
            onClick={() => toggleTask(dateKey, goal.id, task.id, 0, task, goal)}
          >
            <span className={`text-sm flex-1 ${isCheckedToday ? 'text-slate-600' : theme.textPrimary}`}>{task.action}</span>
            <span className={`text-xs ${theme.textMuted}`}>{weekProgress.completed}/{weekProgress.target}</span>
            <div className={`flex-shrink-0 mr-3 ${animatingTasks[taskKey] ? 'checkbox-animate' : ''}`}>
              {isCheckedToday ? (
                <CheckCircle2 className="w-5 h-5 text-emerald-500" />
              ) : (
                <Circle className={`w-5 h-5 ${theme.checkUndone}`} />
              )}
            </div>
          </div>
        );
      }
    };

    return (
      <div className="space-y-4">
        {/* Date Navigator - Option 12 Style */}
        <div className="flex items-center justify-between py-2">
          <button onClick={() => changeDate(-1)} className={`w-8 h-8 rounded-full ${theme.btnIcon} shadow-sm flex items-center justify-center`}>
            <ChevronLeft className="w-4 h-4" />
          </button>
          <div className="text-center">
            {isToday(selectedDate) && (
              <p className="text-xs font-medium text-emerald-600 uppercase tracking-wider">Today</p>
            )}
            <p className={`text-lg font-semibold ${theme.textPrimary}`}>
              {selectedDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric' })}
            </p>
            <p className={`text-xs ${theme.textMuted}`}>
              {selectedDate.toLocaleDateString('en-US', { weekday: 'long' })}
            </p>
          </div>
          <button onClick={() => changeDate(1)} className={`w-8 h-8 rounded-full ${theme.btnIcon} shadow-sm flex items-center justify-center`}>
            <ChevronRight className="w-4 h-4" />
          </button>
        </div>

        {/* Daily Tasks Section - Unified Card (including daily points goals) */}
        {dailyItems.length > 0 && (
          <div>
            <div className="flex items-center justify-between mb-2">
              <p className={`text-xs font-semibold uppercase tracking-wider ${theme.textMuted}`}>Daily Tasks</p>
              <p className={`text-xs ${theme.textSecondary}`}>{dailyProgress.percentage}%</p>
            </div>

            <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
              <ProgressBar percentage={dailyProgress.percentage} darkMode={darkMode} />
              
              {dailyItems.map((item, itemIndex) => {
                const isCollapsed = collapsedGoals.has(`daily-${item.goal.id}`);
                const goalComplete = isGoalComplete(item);
                // Keep border color unfaded
                const borderColor = item.categoryColor;
                // A7 style for completed group headers
                const headerBg = goalComplete ? 'rgba(100, 116, 139, 0.12)' : 'transparent';
                const headerShadow = goalComplete ? 'inset 0 2px 4px rgba(0,0,0,0.04)' : 'none';
                
                // Handle points-type goals
                if (item.type === 'points') {
                  return (
                    <div key={item.goal.id} style={{ borderTop: itemIndex > 0 ? '4px solid' : 'none', borderTopColor: darkMode ? '#1e293b' : '#f1f5f9' }}>
                      <button 
                        onClick={() => toggleGoalCollapse(`daily-${item.goal.id}`)}
                        className="w-full px-3 py-2 flex items-center gap-2"
                        style={{ borderLeft: `3px solid ${borderColor}`, backgroundColor: headerBg, boxShadow: headerShadow }}
                      >
                        <ChevronDown className={`w-4 h-4 ${theme.textMuted} transition-transform ${isCollapsed ? '-rotate-90' : ''}`} />
                        <Star className="w-4 h-4 text-amber-500" />
                        <span className={`text-sm font-medium flex-1 text-left ${goalComplete ? 'text-slate-600' : theme.textPrimary}`}>{item.goal.title}</span>
                        <span className={`text-xs font-semibold ${goalComplete ? 'text-emerald-500' : theme.textSecondary}`}>
                          {item.pointsEarned}/{item.pointTarget} {goalComplete && 'âœ“'}
                        </span>
                      </button>
                      
                      {!isCollapsed && (
                        <div className="relative">
                          {/* Dotted connector line */}
                          <div style={{ 
                            position: 'absolute', 
                            left: '11px', 
                            top: 0, 
                            bottom: 0, 
                            width: '1px', 
                            borderLeft: `1px dashed ${item.categoryColor}50` 
                          }} />
                          {item.tasks.map((task, idx) => (
                            <div key={task.id} style={{ borderTop: `1px solid ${darkMode ? '#334155' : '#f1f5f9'}` }}>
                              {renderTaskRow(item.goal, task, true, idx === item.tasks.length - 1, true, item.categoryColor, true)}
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  );
                }
                
                // Handle single-task checkbox goals
                if (item.type === 'single') {
                  const task = item.tasks[0];
                  return (
                    <div key={item.goal.id} style={{ borderTop: itemIndex > 0 ? '4px solid' : 'none', borderTopColor: darkMode ? '#1e293b' : '#f1f5f9' }}>
                      {renderTaskRow(item.goal, task, true, true, false, item.categoryColor)}
                    </div>
                  );
                }
                
                // Handle multi-task checkbox goals (group)
                return (
                  <div key={item.goal.id} style={{ borderTop: itemIndex > 0 ? '4px solid' : 'none', borderTopColor: darkMode ? '#1e293b' : '#f1f5f9' }}>
                    <button 
                      onClick={() => toggleGoalCollapse(`daily-${item.goal.id}`)}
                      className="w-full px-3 py-2 flex items-center gap-2"
                      style={{ borderLeft: `3px solid ${borderColor}`, backgroundColor: headerBg, boxShadow: headerShadow }}
                    >
                      <ChevronDown className={`w-4 h-4 ${theme.textMuted} transition-transform ${isCollapsed ? '-rotate-90' : ''}`} />
                      <span className={`text-sm font-medium flex-1 text-left ${goalComplete ? 'text-slate-600' : theme.textPrimary}`}>{item.goal.title}</span>
                      <MiniProgressBar percentage={item.percentage} darkMode={darkMode} />
                    </button>
                    
                    {!isCollapsed && (
                      <div className="relative">
                        {/* Dotted connector line */}
                        <div style={{ 
                          position: 'absolute', 
                          left: '11px', 
                          top: 0, 
                          bottom: 0, 
                          width: '1px', 
                          borderLeft: `1px dashed ${item.categoryColor}50` 
                        }} />
                        {item.tasks.map((task, idx) => (
                          <div key={task.id} style={{ borderTop: `1px solid ${darkMode ? '#334155' : '#f1f5f9'}` }}>
                            {renderTaskRow(item.goal, task, true, idx === item.tasks.length - 1, true, item.categoryColor)}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                );
              })}
            </div>
          </div>
        )}

        {/* Empty State */}
        {dailyItems.length === 0 && (
          <div className={`${theme.cardBg} rounded-xl shadow-sm p-6 text-center`}>
            <p className={`text-sm ${theme.textMuted}`}>No daily tasks yet</p>
            <button onClick={() => setShowGoalForm(true)} className={`mt-2 text-sm font-medium ${darkMode ? 'text-slate-300' : 'text-slate-700'}`}>+ Add a goal</button>
          </div>
        )}

        {/* Weekly Tasks Section (including weekly points goals) */}
        {weeklyItems.length > 0 && (
          <div>
            <div className="flex items-center justify-between mb-2">
              <p className={`text-xs font-semibold uppercase tracking-wider ${theme.textMuted}`}>Weekly Tasks</p>
              <p className={`text-xs ${theme.textSecondary}`}>{weeklyOverallProgress.percentage}%</p>
            </div>

            <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
              <ProgressBar percentage={weeklyOverallProgress.percentage} darkMode={darkMode} />
              
              {weeklyItems.map((item, itemIndex) => {
                const isCollapsed = collapsedGoals.has(`weekly-${item.goal.id}`);
                const goalComplete = isGoalComplete(item);
                // Keep border color unfaded
                const borderColor = item.categoryColor;
                // A7 style for completed group headers
                const headerBg = goalComplete ? 'rgba(100, 116, 139, 0.12)' : 'transparent';
                const headerShadow = goalComplete ? 'inset 0 2px 4px rgba(0,0,0,0.04)' : 'none';
                
                // Handle points-type weekly goals
                if (item.type === 'points') {
                  return (
                    <div key={item.goal.id} style={{ borderTop: itemIndex > 0 ? '4px solid' : 'none', borderTopColor: darkMode ? '#1e293b' : '#f1f5f9' }}>
                      <button 
                        onClick={() => toggleGoalCollapse(`weekly-${item.goal.id}`)}
                        className="w-full px-3 py-2 flex items-center gap-2"
                        style={{ borderLeft: `3px solid ${borderColor}`, backgroundColor: headerBg, boxShadow: headerShadow }}
                      >
                        <ChevronDown className={`w-4 h-4 ${theme.textMuted} transition-transform ${isCollapsed ? '-rotate-90' : ''}`} />
                        <Star className="w-4 h-4 text-amber-500" />
                        <span className={`text-sm font-medium flex-1 text-left ${goalComplete ? 'text-slate-600' : theme.textPrimary}`}>{item.goal.title}</span>
                        <span className={`text-xs font-semibold ${goalComplete ? 'text-emerald-500' : theme.textSecondary}`}>
                          {item.pointsEarned}/{item.pointTarget} {goalComplete && 'âœ“'}
                        </span>
                      </button>
                      
                      {!isCollapsed && (
                        <div className="relative">
                          {/* Dotted connector line */}
                          <div style={{ 
                            position: 'absolute', 
                            left: '11px', 
                            top: 0, 
                            bottom: 0, 
                            width: '1px', 
                            borderLeft: `1px dashed ${item.categoryColor}50` 
                          }} />
                          {item.tasks.map((task, idx) => (
                            <div key={task.id} style={{ borderTop: `1px solid ${darkMode ? '#334155' : '#f1f5f9'}` }}>
                              {renderTaskRow(item.goal, task, true, idx === item.tasks.length - 1, true, item.categoryColor, true)}
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  );
                }
                
                // Handle single-task checkbox goals
                if (item.type === 'single') {
                  const task = item.tasks[0];
                  return (
                    <div key={item.goal.id} style={{ borderTop: itemIndex > 0 ? '4px solid' : 'none', borderTopColor: darkMode ? '#1e293b' : '#f1f5f9' }}>
                      {renderTaskRow(item.goal, task, false, true, false, item.categoryColor)}
                    </div>
                  );
                }
                
                // Handle multi-task checkbox goals (group)
                return (
                  <div key={item.goal.id} style={{ borderTop: itemIndex > 0 ? '4px solid' : 'none', borderTopColor: darkMode ? '#1e293b' : '#f1f5f9' }}>
                    <button 
                      onClick={() => toggleGoalCollapse(`weekly-${item.goal.id}`)}
                      className="w-full px-3 py-2 flex items-center gap-2"
                      style={{ borderLeft: `3px solid ${borderColor}`, backgroundColor: headerBg, boxShadow: headerShadow }}
                    >
                      <ChevronDown className={`w-4 h-4 ${theme.textMuted} transition-transform ${isCollapsed ? '-rotate-90' : ''}`} />
                      <span className={`text-sm font-medium flex-1 text-left ${goalComplete ? 'text-slate-600' : theme.textPrimary}`}>{item.goal.title}</span>
                      <MiniProgressBar percentage={item.percentage} darkMode={darkMode} />
                    </button>
                    
                    {!isCollapsed && (
                      <div className="relative">
                        {/* Dotted connector line */}
                        <div style={{ 
                          position: 'absolute', 
                          left: '11px', 
                          top: 0, 
                          bottom: 0, 
                          width: '1px', 
                          borderLeft: `1px dashed ${item.categoryColor}50` 
                        }} />
                        {item.tasks.map((task, idx) => (
                          <div key={task.id} style={{ borderTop: `1px solid ${darkMode ? '#334155' : '#f1f5f9'}` }}>
                            {renderTaskRow(item.goal, task, false, idx === item.tasks.length - 1, true, item.categoryColor)}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                );
              })}
            </div>
          </div>
        )}

        {/* Journal Section - Redesigned with card-per-prompt and insights */}
        <div>
          <div className="flex items-center justify-between mb-2">
            <div className="flex items-center gap-2">
              <p className={`text-xs font-semibold uppercase tracking-wider ${theme.textMuted}`}>Journal</p>
              {(() => {
                const filledCount = journalConfig.prompts.filter(prompt => {
                  const val = journalEntries[`${dateKey}-${prompt.id}`];
                  if (prompt.type === 'text') return val && val.trim().length > 0;
                  if (prompt.type === 'slider') return val !== undefined;
                  if (prompt.type === 'yesno') return val !== undefined;
                  return false;
                }).length;
                const totalCount = journalConfig.prompts.length;
                return totalCount > 0 ? (
                  <span className={`text-xs px-1.5 py-0.5 rounded-full ${
                    filledCount === totalCount 
                      ? 'bg-emerald-500/10 text-emerald-500' 
                      : `${darkMode ? 'bg-slate-700' : 'bg-slate-200'} ${theme.textSecondary}`
                  }`}>
                    {filledCount}/{totalCount}
                  </span>
                ) : null;
              })()}
            </div>
            <button onClick={() => setShowJournalSettings(true)} className={theme.textMuted}>
              <Settings className="w-4 h-4" />
            </button>
          </div>
          
          <div className="space-y-3">
            {/* Text prompts - individual cards */}
            {journalConfig.prompts.filter(p => p.type === 'text').map((prompt) => {
              const promptKey = `${dateKey}-${prompt.id}`;
              const value = journalEntries[promptKey] || '';
              const hasContent = value.trim().length > 0;
              
              // Helper to get previous day's value
              const getPrevValue = (daysAgo = 1) => {
                const prevDate = new Date(selectedDate);
                prevDate.setDate(prevDate.getDate() - daysAgo);
                return journalEntries[`${toLocalDateKey(prevDate)}-${prompt.id}`];
              };
              
              // Calculate writing streak
              let writeStreak = 0;
              for (let i = 1; i <= 30; i++) {
                const prev = getPrevValue(i);
                if (prev && prev.trim().length > 0) writeStreak++;
                else break;
              }
              if (hasContent) writeStreak++;
              
              return (
                <div key={prompt.id} className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
                  <div className={`px-3 py-2.5 flex items-center justify-between border-b ${darkMode ? 'border-slate-700/50' : 'border-slate-100'}`}>
                    <span className={`text-sm font-medium ${theme.textPrimary}`}>{prompt.label}</span>
                    {writeStreak >= 3 && (
                      <span className="text-xs flex items-center gap-1 text-orange-500">
                        <Flame className="w-3 h-3" />
                        {writeStreak} days
                      </span>
                    )}
                  </div>
                  <div className="p-3">
                    <textarea
                      value={value}
                      onChange={(e) => setJournalEntries(prev => ({ ...prev, [promptKey]: e.target.value }))}
                      placeholder={prompt.placeholder || 'Write here...'}
                      className={`w-full rounded-lg px-3 py-2.5 text-sm min-h-[100px] resize-none border ${theme.border} ${theme.inputBg} ${theme.textPrimary} focus:outline-none focus:ring-2 focus:ring-slate-300`}
                    />
                  </div>
                </div>
              );
            })}
            
            {/* Slider prompts - individual cards */}
            {journalConfig.prompts.filter(p => p.type === 'slider').map((prompt) => {
              const promptKey = `${dateKey}-${prompt.id}`;
              const currentValue = journalEntries[promptKey];
              const value = currentValue !== undefined ? currentValue : prompt.min || 0;
              const hasValue = currentValue !== undefined;
              
              // Helper to get previous day's value
              const getPrevValue = (daysAgo = 1) => {
                const prevDate = new Date(selectedDate);
                prevDate.setDate(prevDate.getDate() - daysAgo);
                return journalEntries[`${toLocalDateKey(prevDate)}-${prompt.id}`];
              };
              
              const yesterdayValue = getPrevValue(1);
              const min = prompt.min || 0;
              const max = prompt.max || 10;
              const percentage = ((value - min) / (max - min)) * 100;
              const gradientColor = percentage < 33 ? '#f97316' : percentage < 66 ? '#eab308' : '#22c55e';
              
              // Get 7-day trend data
              const trendData = [];
              for (let i = 6; i >= 0; i--) {
                trendData.push(getPrevValue(i) !== undefined ? getPrevValue(i) : null);
              }
              trendData.push(hasValue ? value : null);
              
              // Calculate 7-day average
              const validTrend = trendData.filter(d => d !== null);
              const average = validTrend.length > 0 ? (validTrend.reduce((a, b) => a + b, 0) / validTrend.length).toFixed(1) : null;
              
              // Comparison to yesterday
              let comparison = null;
              if (yesterdayValue !== undefined && hasValue) {
                const diff = value - yesterdayValue;
                if (diff > 0) comparison = { type: 'up', diff };
                else if (diff < 0) comparison = { type: 'down', diff: Math.abs(diff) };
                else comparison = { type: 'same' };
              }
              
              return (
                <div key={prompt.id} className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
                  <div className={`px-3 py-2.5 flex items-center justify-between border-b ${darkMode ? 'border-slate-700/50' : 'border-slate-100'}`}>
                    <span className={`text-sm font-medium ${theme.textPrimary}`}>{prompt.label}</span>
                    <MiniSparkline data={trendData.slice(0, 7)} color={gradientColor} />
                  </div>
                  <div className="p-3">
                    <div className="flex items-center gap-3">
                      <span className={`text-xs ${theme.textMuted}`}>{min}</span>
                      <div className="flex-1 relative">
                        {yesterdayValue !== undefined && (
                          <div 
                            className="absolute top-1/2 -translate-y-1/2 w-0.5 h-3 rounded-full bg-slate-400 opacity-40 z-0"
                            style={{ left: `${((yesterdayValue - min) / (max - min)) * 100}%` }}
                            title={`Yesterday: ${yesterdayValue}`}
                          />
                        )}
                        <input
                          type="range"
                          min={min}
                          max={max}
                          value={value}
                          onChange={(e) => setJournalEntries(prev => ({ ...prev, [promptKey]: parseInt(e.target.value) }))}
                          className="w-full h-2 rounded-full appearance-none cursor-pointer relative z-10"
                          style={{ 
                            background: `linear-gradient(to right, ${gradientColor} 0%, ${gradientColor} ${percentage}%, ${darkMode ? '#334155' : '#e2e8f0'} ${percentage}%, ${darkMode ? '#334155' : '#e2e8f0'} 100%)` 
                          }}
                        />
                      </div>
                      <span className={`text-xs ${theme.textMuted}`}>{max}</span>
                    </div>
                    <div className="flex items-center justify-center mt-2">
                      <span className="text-xl font-bold" style={{ color: gradientColor }}>{value}</span>
                    </div>
                  </div>
                  {(comparison || average) && (
                    <div className={`px-3 py-2 flex items-center justify-between border-t ${darkMode ? 'border-slate-700/50' : 'border-slate-100'}`} style={{ backgroundColor: darkMode ? 'rgba(51,65,85,0.3)' : 'rgba(248,250,252,0.8)' }}>
                      {comparison ? (
                        <span className={`text-xs flex items-center gap-1 ${
                          comparison.type === 'up' ? 'text-emerald-500' : 
                          comparison.type === 'down' ? 'text-amber-500' : 
                          theme.textMuted
                        }`}>
                          {comparison.type === 'up' && <ChevronUp className="w-3 h-3" />}
                          {comparison.type === 'down' && <ChevronDown className="w-3 h-3" />}
                          {comparison.type === 'same' && <Minus className="w-3 h-3" />}
                          {comparison.type === 'up' ? `+${comparison.diff}` : comparison.type === 'down' ? `-${comparison.diff}` : 'Same as'} yesterday
                        </span>
                      ) : <span />}
                      {average && (
                        <span className={`text-xs ${theme.textMuted}`}>7-day avg: {average}</span>
                      )}
                    </div>
                  )}
                </div>
              );
            })}
            
            {/* Yes/No prompts - grouped together in one card */}
            {(() => {
              const yesNoPrompts = journalConfig.prompts.filter(p => p.type === 'yesno');
              if (yesNoPrompts.length === 0) return null;
              
              // Helper to get previous day's value for a prompt
              const getPrevValue = (promptId, daysAgo = 1) => {
                const prevDate = new Date(selectedDate);
                prevDate.setDate(prevDate.getDate() - daysAgo);
                return journalEntries[`${toLocalDateKey(prevDate)}-${promptId}`];
              };
              
              // Calculate streak for a prompt
              const calculateStreak = (promptId) => {
                const value = journalEntries[`${dateKey}-${promptId}`];
                let streak = 0;
                let checkDate = new Date(selectedDate);
                
                if (value === undefined) {
                  // No entry today, start checking from yesterday
                  checkDate.setDate(checkDate.getDate() - 1);
                } else if (value !== 'yes') {
                  // Today is 'no', streak is 0
                  return { current: 0, wasStreak: getPrevValue(promptId, 1) === 'yes' };
                } else {
                  // Today is 'yes' - count 1 for today, then check backwards from yesterday
                  streak = 1;
                  checkDate.setDate(checkDate.getDate() - 1);
                }
                
                for (let i = 0; i < 365; i++) {
                  const checkKey = `${toLocalDateKey(checkDate)}-${promptId}`;
                  if (journalEntries[checkKey] === 'yes') {
                    streak++;
                    checkDate.setDate(checkDate.getDate() - 1);
                  } else {
                    break;
                  }
                }
                
                return { current: streak, wasStreak: false };
              };
              
              // Calculate weekly yes count for a prompt (last 7 days including today)
              const getWeeklyYesCount = (promptId) => {
                let count = 0;
                // i=0 is today, i=6 is 6 days ago (7 days total)
                for (let i = 0; i < 7; i++) {
                  if (getPrevValue(promptId, i) === 'yes') count++;
                }
                return count;
              };
              
              return (
                <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
                  {yesNoPrompts.map((prompt, index) => {
                    const promptKey = `${dateKey}-${prompt.id}`;
                    const value = journalEntries[promptKey];
                    const streak = calculateStreak(prompt.id);
                    const weeklyYes = getWeeklyYesCount(prompt.id);
                    const isLast = index === yesNoPrompts.length - 1;
                    
                    return (
                      <div 
                        key={prompt.id} 
                        className={`px-3 py-2 flex items-center gap-2 ${!isLast ? `border-b ${darkMode ? 'border-slate-700/50' : 'border-slate-100'}` : ''}`}
                      >
                        <span className={`text-sm flex-1 truncate ${theme.textPrimary}`}>{prompt.label}</span>
                        {/* Streak indicator - compact */}
                        {streak.current >= 2 && value === 'yes' && (
                          <span className="text-xs text-orange-500 flex items-center gap-0.5 flex-shrink-0">
                            <Flame className="w-3 h-3" />
                            {streak.current}
                          </span>
                        )}
                        {streak.wasStreak && (
                          <span className="text-xs text-rose-500 flex-shrink-0">!</span>
                        )}
                        <span className={`text-xs w-6 text-right flex-shrink-0 ${theme.textMuted}`}>{weeklyYes}/7</span>
                        <div className="flex items-center gap-1 flex-shrink-0">
                          <button
                            onClick={() => setJournalEntries(prev => ({ ...prev, [promptKey]: value === 'yes' ? undefined : 'yes' }))}
                            className={`w-6 h-6 rounded flex items-center justify-center transition-all ${
                              value === 'yes'
                                ? 'bg-emerald-500 text-white'
                                : `${theme.inputBg} ${theme.textMuted} hover:text-emerald-500`
                            }`}
                          >
                            <Check className="w-3.5 h-3.5" />
                          </button>
                          <button
                            onClick={() => setJournalEntries(prev => ({ ...prev, [promptKey]: value === 'no' ? undefined : 'no' }))}
                            className={`w-6 h-6 rounded flex items-center justify-center transition-all ${
                              value === 'no'
                                ? 'bg-rose-500 text-white'
                                : `${theme.inputBg} ${theme.textMuted} hover:text-rose-500`
                            }`}
                          >
                            <X className="w-3.5 h-3.5" />
                          </button>
                        </div>
                      </div>
                    );
                  })}
                </div>
              );
            })()}
            
            {journalConfig.prompts.length === 0 && (
              <div className={`${theme.cardBg} rounded-xl shadow-sm p-6 text-center`}>
                <p className={`text-sm ${theme.textMuted} mb-2`}>No journal prompts</p>
                <button onClick={() => setShowJournalSettings(true)} className={`text-sm font-medium ${darkMode ? 'text-slate-300' : 'text-slate-700'}`}>
                  + Add prompts
                </button>
              </div>
            )}
          </div>
        </div>

        {/* Photo of the Day */}
        <div>
          <p className={`text-xs font-semibold uppercase tracking-wider mb-2 ${theme.textMuted}`}>Photo of the Day</p>
          {dailyPhotos[dateKey] ? (
            <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden relative`}>
              <img src={dailyPhotos[dateKey]} alt="Photo of the day" className="w-full h-40 object-cover" />
              <button onClick={() => removeDailyPhoto(dateKey)} className="absolute top-2 right-2 p-1.5 bg-red-500 hover:bg-red-600 rounded-lg">
                <Trash2 className="w-3.5 h-3.5 text-white" />
              </button>
            </div>
          ) : (
            <div className={`${theme.cardBg} rounded-xl shadow-sm p-4 border-2 border-dashed ${theme.border} flex items-center justify-center`}>
              <label className="text-center cursor-pointer">
                <Camera className={`w-6 h-6 mx-auto mb-1 ${theme.textMuted}`} />
                <p className={`text-xs ${theme.textMuted}`}>Add photo</p>
                <input type="file" accept="image/*" className="hidden" onChange={(e) => {
                  const file = e.target.files[0];
                  if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => updateDailyPhoto(dateKey, reader.result);
                    reader.readAsDataURL(file);
                  }
                }} />
              </label>
            </div>
          )}
        </div>

        {/* Media Section */}
        <div>
          <div className="flex items-center justify-between mb-2">
            <p className={`text-xs font-semibold uppercase tracking-wider ${theme.textMuted}`}>Media</p>
            <button onClick={() => setShowMediaForm(true)} className={`w-6 h-6 rounded-full ${theme.btnPrimary} flex items-center justify-center`}>
              <Plus className="w-3 h-3" />
            </button>
          </div>
          {todayMedia.length === 0 ? (
            <div className={`${theme.cardBg} rounded-xl shadow-sm p-4 text-center`}>
              <p className={`text-xs ${theme.textMuted}`}>No media logged today</p>
            </div>
          ) : (
            <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden`}>
              {todayMedia.map((item, index) => (
                <div key={item.id} className={`flex items-center gap-3 px-3 py-2.5 group ${index !== todayMedia.length - 1 ? `border-b ${theme.divider}` : ''}`}>
                  <div className={`w-7 h-7 rounded flex items-center justify-center ${theme.inputBg}`}>
                    {item.type === 'book' && <Book className={`w-3.5 h-3.5 ${theme.textSecondary}`} />}
                    {item.type === 'music' && <Music className={`w-3.5 h-3.5 ${theme.textSecondary}`} />}
                    {item.type === 'movie' && <Film className={`w-3.5 h-3.5 ${theme.textSecondary}`} />}
                  </div>
                  <div className="flex-1 min-w-0">
                    <p className={`text-sm truncate ${theme.textPrimary}`}>{item.title}</p>
                    {item.notes && <p className={`text-xs truncate ${theme.textMuted}`}>{item.notes}</p>}
                  </div>
                  <button onClick={() => removeMedia(dateKey, item.id)} className="opacity-0 group-hover:opacity-100 p-1 hover:bg-red-500/10 rounded">
                    <Trash2 className="w-3.5 h-3.5 text-red-500" />
                  </button>
                </div>
              ))}
            </div>
          )}

          {/* Media Form Modal */}
          {showMediaForm && (
            <div className="fixed inset-0 bg-black/30 backdrop-blur-sm flex items-center justify-center z-50 p-4">
              <div className={`${theme.cardBg} rounded-2xl p-5 w-full max-w-md shadow-xl`}>
                <h4 className={`text-base font-semibold mb-4 ${theme.textPrimary}`}>Add Media</h4>
                <div className="space-y-3">
                  <div>
                    <label className={`block text-xs font-medium mb-1 ${theme.textMuted}`}>Type</label>
                    <select value={mediaForm.type} onChange={(e) => setMediaForm({ ...mediaForm, type: e.target.value })} className={`w-full rounded-lg px-3 py-2 text-sm ${theme.inputBg} ${theme.textPrimary}`}>
                      <option value="book">Book</option>
                      <option value="music">Album</option>
                      <option value="movie">Movie</option>
                    </select>
                  </div>
                  <div>
                    <label className={`block text-xs font-medium mb-1 ${theme.textMuted}`}>Title</label>
                    <input type="text" value={mediaForm.title} onChange={(e) => setMediaForm({ ...mediaForm, title: e.target.value })} className={`w-full rounded-lg px-3 py-2 text-sm ${theme.inputBg} ${theme.textPrimary}`} placeholder="Enter title..." />
                  </div>
                  <div>
                    <label className={`block text-xs font-medium mb-1 ${theme.textMuted}`}>Notes (optional)</label>
                    <textarea value={mediaForm.notes} onChange={(e) => setMediaForm({ ...mediaForm, notes: e.target.value })} className={`w-full rounded-lg px-3 py-2 text-sm ${theme.inputBg} ${theme.textPrimary}`} rows="2" placeholder="Your thoughts..." />
                  </div>
                </div>
                <div className="flex gap-2 mt-4">
                  <button onClick={() => { if (mediaForm.title) { addMedia(dateKey, mediaForm); setMediaForm({ type: 'book', title: '', notes: '' }); setShowMediaForm(false); } }} className={`flex-1 py-2 rounded-lg text-sm font-medium ${theme.btnPrimary}`}>Add</button>
                  <button onClick={() => { setShowMediaForm(false); setMediaForm({ type: 'book', title: '', notes: '' }); }} className={`px-4 py-2 rounded-lg text-sm font-medium ${theme.btnSecondary}`}>Cancel</button>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>
    );
  };

  // ============================================
  // GOALS VIEW - Goal management & per-goal stats
  // ============================================
  const GoalsView = () => {
    const [expandedGoal, setExpandedGoal] = useState(null);
    const [collapsedCats, setCollapsedCats] = useState(new Set());

    const toggleCat = (catId) => {
      setCollapsedCats(prev => {
        const n = new Set(prev);
        n.has(catId) ? n.delete(catId) : n.add(catId);
        return n;
      });
    };

    // Calculate goal-level streak (all daily/scheduled tasks completed)
    const calculateGoalStreak = useCallback((goal) => {
      if (!goal.tasks || !Array.isArray(goal.tasks)) return { current: 0, longest: 0 };
      
      const dailyScheduledTasks = goal.tasks.filter(t => 
        !t.frequency || t.frequency === 'daily' || t.frequency === 'scheduled'
      );
      if (dailyScheduledTasks.length === 0) return { current: 0, longest: 0 };

      const isGoalCompletedOnDate = (date) => {
        const dk = toLocalDateKey(date);
        const tasks = dailyTasks[dk] || {};
        let hadAnyTask = false;
        for (const task of dailyScheduledTasks) {
          const isScheduled = task.frequency === 'scheduled';
          if (isScheduled && !isTaskScheduledForDate(task, date)) continue;
          hadAnyTask = true;
          const checks = task.dailyChecks || 1;
          for (let i = 0; i < checks; i++) {
            if (!tasks[`${goal.id}-${task.id}-${i}`]) return false;
          }
        }
        return hadAnyTask;
      };

      const today = new Date();
      today.setHours(12, 0, 0, 0);
      
      // Current streak
      let current = 0;
      let checkDate = new Date(today);
      if (isGoalCompletedOnDate(checkDate)) {
        current = 1;
        checkDate.setDate(checkDate.getDate() - 1);
        while (current < 365) {
          if (isGoalCompletedOnDate(checkDate)) {
            current++;
            checkDate.setDate(checkDate.getDate() - 1);
          } else break;
        }
      } else {
        checkDate.setDate(checkDate.getDate() - 1);
        while (current < 365) {
          if (isGoalCompletedOnDate(checkDate)) {
            current++;
            checkDate.setDate(checkDate.getDate() - 1);
          } else break;
        }
      }

      // Longest streak
      const goalStart = goal.createdAt ? new Date(goal.createdAt) : new Date(today.getFullYear(), 0, 1);
      goalStart.setHours(12, 0, 0, 0);
      let longest = 0;
      let runningStreak = 0;
      const scanDate = new Date(goalStart);
      while (scanDate <= today) {
        if (isGoalCompletedOnDate(scanDate)) {
          runningStreak++;
          if (runningStreak > longest) longest = runningStreak;
        } else {
          runningStreak = 0;
        }
        scanDate.setDate(scanDate.getDate() + 1);
      }

      return { current, longest };
    }, [dailyTasks, isTaskScheduledForDate]);

    // Calculate days active for a goal
    const calculateDaysActive = useCallback((goal) => {
      if (!goal.tasks || !Array.isArray(goal.tasks)) return 0;
      const today = new Date();
      const goalStart = goal.createdAt ? new Date(goal.createdAt) : new Date(today.getFullYear(), 0, 1);
      goalStart.setHours(0, 0, 0, 0);
      today.setHours(23, 59, 59, 999);
      
      let activeDays = 0;
      const d = new Date(goalStart);
      while (d <= today) {
        const dk = toLocalDateKey(d);
        const tasks = dailyTasks[dk] || {};
        const hasAny = Object.keys(tasks).some(key => key.startsWith(`${goal.id}-`) && tasks[key]);
        if (hasAny) activeDays++;
        d.setDate(d.getDate() + 1);
      }
      return activeDays;
    }, [dailyTasks]);

    // Completion rate from goalProgressCache (uses createdAt)
    const getCompletionRate = useCallback((goal) => {
      return goalProgressCache[goal.id]?.percentage || 0;
    }, [goalProgressCache]);

    // Group goals by category
    const groupedGoals = (categories || []).map(cat => ({
      ...cat,
      goals: goals.filter(g => g.category === cat.id)
    })).filter(c => c.goals.length > 0);

    const uncategorizedGoals = goals.filter(g => !(categories || []).some(c => c.id === g.category));

    // Render a goal row + expanded detail
    const GoalItem = ({ goal, catColor, isLast }) => {
      const isExpanded = expandedGoal === goal.id;
      const completionRate = getCompletionRate(goal);
      const streaks = calculateGoalStreak(goal);
      const color = catColor || '#94a3b8';

      return (
        <div>
          {/* Goal row */}
          <button
            onClick={() => setExpandedGoal(isExpanded ? null : goal.id)}
            className={`w-full px-3.5 py-3 text-left flex items-center gap-3 ${
              !isLast && !isExpanded ? `border-b ${theme.divider}` : ''
            }`}
          >
            <div className="flex-1 min-w-0">
              <div className={`text-sm font-semibold ${theme.textPrimary} truncate`}>{goal.title}</div>
              <div className={`text-[11px] ${theme.textMuted} flex items-center gap-2 mt-0.5`}>
                <span>{(goal.tasks || []).length} task{(goal.tasks || []).length !== 1 ? 's' : ''}</span>
                {streaks.current >= 3 && (
                  <span className="flex items-center gap-0.5">
                    <Flame className="w-3 h-3" style={{ color: '#f97316' }} />
                    <span>{streaks.current}d</span>
                  </span>
                )}
              </div>
            </div>
            <div className="relative flex-shrink-0" style={{ width: 38, height: 38 }}>
              <svg width="38" height="38" viewBox="0 0 38 38">
                <circle cx="19" cy="19" r="15" fill="none" stroke={darkMode ? '#334155' : '#f1f5f9'} strokeWidth="3" />
                <circle cx="19" cy="19" r="15" fill="none" stroke={color} strokeWidth="3"
                  strokeDasharray={`${completionRate * 0.94} 94`}
                  strokeLinecap="round"
                  transform="rotate(-90 19 19)"
                  style={{ transition: 'stroke-dasharray 0.5s' }}
                />
              </svg>
              <div className="absolute inset-0 flex items-center justify-center">
                <span className={`text-[10px] font-bold ${theme.textPrimary}`}>{completionRate}%</span>
              </div>
            </div>
          </button>

          {/* Expanded detail */}
          {isExpanded && (
            <div className={`px-3.5 pb-3.5 ${!isLast ? `border-b ${theme.divider}` : ''}`}>
              {/* Yearly target */}
              {goal.yearlyGoal && (
                <div className={`p-2.5 rounded-lg mb-3 ${theme.inputBg}`}>
                  <div className={`text-[9px] font-semibold uppercase tracking-wider mb-1 ${theme.textMuted}`}>Yearly Target</div>
                  <div className={`text-[13px] font-semibold ${theme.textSecondary}`}>{goal.yearlyGoal}</div>
                </div>
              )}

              {/* Stats */}
              <div className="flex gap-1.5 mb-3">
                {[
                  { value: `${streaks.current}d`, label: 'Streak', highlight: streaks.current >= 5 },
                  { value: `${streaks.longest}d`, label: 'Best' },
                  { value: `${calculateDaysActive(goal)}`, label: 'Days active' },
                ].map((s, i) => (
                  <div key={i} className="flex-1 text-center py-2 rounded-lg" style={{
                    background: s.highlight ? `${color}15` : (darkMode ? '#1e293b' : '#f8fafc'),
                    border: s.highlight ? `1px solid ${color}30` : '1px solid transparent'
                  }}>
                    <div className="text-sm font-bold" style={{ color: s.highlight ? color : (darkMode ? '#e2e8f0' : '#1e293b') }}>{s.value}</div>
                    <div className={`text-[9px] ${theme.textMuted}`}>{s.label}</div>
                  </div>
                ))}
              </div>

              {/* Tasks */}
              <div className="mb-3">
                <div className={`text-[9px] font-semibold uppercase tracking-wider mb-1.5 ${theme.textMuted}`}>Tasks</div>
                {(goal.tasks || []).map((task, ti) => (
                  <div key={task.id} className={`flex items-center gap-2 py-1.5 ${
                    ti < (goal.tasks || []).length - 1 ? `border-b ${theme.divider}` : ''
                  }`}>
                    <div className="w-1 h-1 rounded-full flex-shrink-0" style={{ backgroundColor: color, opacity: 0.5 }} />
                    <span className={`text-xs flex-1 ${theme.textSecondary}`}>{task.action}</span>
                    <span className={`text-[10px] px-1.5 py-0.5 rounded ${theme.inputBg} ${theme.textMuted}`}>
                      {task.frequency === 'daily' ? (task.dailyChecks > 1 ? `${task.dailyChecks}x/day` : 'daily')
                        : task.frequency === 'weekly' ? `${task.weeklyTarget || 4}x/wk`
                        : task.frequency === 'scheduled' ? `${(task.scheduledDays || []).length}d/wk`
                        : task.frequency}
                    </span>
                  </div>
                ))}
              </div>

              {/* Created date */}
              {goal.createdAt && (
                <p className={`text-[10px] mb-3 ${theme.textMuted}`}>
                  Created {new Date(goal.createdAt).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}
                </p>
              )}

              {/* Actions */}
              <div className="flex gap-2">
                <button onClick={(e) => { e.stopPropagation(); setEditingGoal(goal); }} className={`flex-1 py-2 rounded-lg text-xs font-semibold ${theme.btnSecondary}`}>Edit Goal</button>
                {deletingGoalId === goal.id ? (
                  <button onClick={(e) => { e.stopPropagation(); deleteGoal(goal.id); setDeletingGoalId(null); setExpandedGoal(null); }} className="px-4 py-2 rounded-lg text-xs font-semibold bg-red-500 text-white">Confirm</button>
                ) : (
                  <button onClick={(e) => { e.stopPropagation(); setDeletingGoalId(goal.id); }} className="px-4 py-2 rounded-lg text-xs font-semibold" style={{ background: darkMode ? '#451a1a' : '#fef2f2', color: '#ef4444' }}>Delete</button>
                )}
              </div>
            </div>
          )}
        </div>
      );
    };

    return (
      <div className="space-y-3">
        {/* Header */}
        <div className="flex items-center justify-between py-2">
          <div>
            <h2 className={`text-lg font-semibold ${theme.textPrimary}`}>Goals</h2>
            <p className={`text-xs ${theme.textMuted}`}>{goals.length} active goal{goals.length !== 1 ? 's' : ''}</p>
          </div>
          <button onClick={() => setShowCategorySettings(true)} className={`p-2 rounded-lg ${theme.btnSecondary}`}>
            <Settings className="w-4 h-4" />
          </button>
        </div>

        {goals.length === 0 ? (
          <div className={`${theme.cardBg} rounded-xl shadow-sm p-8 text-center`}>
            <Target className={`w-10 h-10 mx-auto mb-3 ${theme.textMuted}`} />
            <h3 className={`text-sm font-semibold mb-1 ${theme.textPrimary}`}>No goals yet</h3>
            <p className={`text-xs mb-4 ${theme.textMuted}`}>Create your first goal to start tracking</p>
            <button onClick={() => setShowGoalForm(true)} className={`px-4 py-2 rounded-lg text-sm font-medium ${theme.btnPrimary}`}>Create Goal</button>
          </div>
        ) : (
          <>
            {groupedGoals.map(cat => {
              const isCollapsed = collapsedCats.has(cat.id);
              return (
                <div key={cat.id}>
                  <button
                    onClick={() => toggleCat(cat.id)}
                    className="flex items-center gap-2 mb-2 w-full px-1"
                    style={{ background: 'none', border: 'none' }}
                  >
                    <div className="w-2 h-2 rounded-full flex-shrink-0" style={{ backgroundColor: cat.color }} />
                    <span className={`text-[11px] font-bold uppercase tracking-wider flex-1 text-left ${theme.textMuted}`}>{cat.name}</span>
                    <span className={`text-xs ${theme.textMuted}`}>{cat.goals.length}</span>
                    <ChevronRight className={`w-3 h-3 ${theme.textMuted} transition-transform ${isCollapsed ? '' : 'rotate-90'}`} />
                  </button>

                  {!isCollapsed && (
                    <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden mb-3`}>
                      {cat.goals.map((goal, gi) => (
                        <GoalItem key={goal.id} goal={goal} catColor={cat.color} isLast={gi === cat.goals.length - 1} />
                      ))}
                    </div>
                  )}
                </div>
              );
            })}

            {uncategorizedGoals.length > 0 && (
              <div>
                <div className="flex items-center gap-2 mb-2 px-1">
                  <span className={`text-[11px] font-bold uppercase tracking-wider ${theme.textMuted}`}>Uncategorized</span>
                </div>
                <div className={`${theme.cardBg} rounded-xl shadow-sm overflow-hidden mb-3`}>
                  {uncategorizedGoals.map((goal, gi) => (
                    <GoalItem key={goal.id} goal={goal} catColor="#94a3b8" isLast={gi === uncategorizedGoals.length - 1} />
                  ))}
                </div>
              </div>
            )}
          </>
        )}
      </div>
    );
  };


  // ============================================
  // MAIN RENDER
  // ============================================
  if (!isLoaded) {
    return (
      <div className={`min-h-screen flex items-center justify-center ${theme.pageBg}`}>
        <p className={theme.textMuted}>Loading...</p>
      </div>
    );
  }

  return (
    <div className={`min-h-screen ${theme.pageBg} font-sans`}>
      <style>{`
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        * { font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; }
        input[type="range"]::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
          width: 14px;
          height: 14px;
          border-radius: 50%;
          background: ${darkMode ? '#e2e8f0' : '#334155'};
          cursor: pointer;
        }
        @keyframes taskGlow {
          0% { transform: scale(1); background-color: transparent; }
          20% { transform: scale(0.98); background-color: rgba(34, 197, 94, 0.2); }
          40% { transform: scale(1); background-color: rgba(34, 197, 94, 0.3); }
          60% { transform: scale(1); background-color: rgba(34, 197, 94, 0.2); }
          80% { transform: scale(1); background-color: rgba(34, 197, 94, 0.08); }
          100% { transform: scale(1); background-color: transparent; }
        }
        @keyframes checkPop {
          0% { transform: scale(1); }
          40% { transform: scale(0.85); }
          100% { transform: scale(1); }
        }
        .task-row-animate { animation: taskGlow 1.2s ease-out; }
        .checkbox-animate { animation: checkPop 0.35s ease-out; }
      `}</style>
      
      {/* Sticky Header */}
      <div className={`sticky top-0 z-40 ${theme.headerBg} backdrop-blur-sm border-b ${theme.border}`}>
        <div className="max-w-lg mx-auto px-4 py-3">
          <div className="flex items-center justify-between">
            <h1 className={`text-lg font-semibold tracking-tight ${theme.textPrimary}`}>Life Tracker</h1>
            <div className="flex gap-2">
              <button onClick={() => setDarkMode(!darkMode)} className={`w-8 h-8 rounded-full ${theme.btnIcon} shadow-sm flex items-center justify-center`}>
                {darkMode ? <Sun className="w-4 h-4" /> : <Moon className="w-4 h-4" />}
              </button>
              <button onClick={() => setShowGoalForm(true)} className={`w-8 h-8 rounded-full ${theme.btnPrimary} shadow-sm flex items-center justify-center`}>
                <Plus className="w-4 h-4" />
              </button>
            </div>
          </div>

          {/* Navigation Pills */}
          <div className="mt-3">
            <div className={`flex gap-1 ${theme.cardBg} rounded-full p-1 shadow-sm w-fit`}>
              <button onClick={() => setCurrentView('daily')} className={`px-4 py-1.5 text-xs font-medium rounded-full transition-all ${currentView === 'daily' ? theme.btnPrimary : theme.textSecondary}`}>Daily</button>
              <button onClick={() => setCurrentView('calendar')} className={`px-4 py-1.5 text-xs font-medium rounded-full transition-all ${currentView === 'calendar' ? theme.btnPrimary : theme.textSecondary}`}>Calendar</button>
              <button onClick={() => setCurrentView('goals')} className={`px-4 py-1.5 text-xs font-medium rounded-full transition-all ${currentView === 'goals' ? theme.btnPrimary : theme.textSecondary}`}>Goals</button>
            </div>
          </div>
        </div>
      </div>

      {/* Main Content */}
      <div className="max-w-lg mx-auto px-4 py-4 pb-8">
        {currentView === 'daily' && <DailyView />}
        {currentView === 'calendar' && <CalendarView />}
        {currentView === 'goals' && <GoalsView />}
      </div>

      {/* Modals */}
      {showGoalForm && <GoalForm onSave={addGoal} onCancel={() => setShowGoalForm(false)} />}
      {editingGoal && <GoalForm goal={editingGoal} onSave={(updates) => updateGoal(editingGoal.id, updates)} onCancel={() => setEditingGoal(null)} />}
      {showCompletionModal && <TaskCompletionModal onSave={(note, photo) => saveTaskCompletion(showCompletionModal.dateKey, showCompletionModal.goalId, showCompletionModal.taskId, showCompletionModal.checkIndex, note, photo)} onCancel={() => setShowCompletionModal(null)} taskName={showCompletionModal.task?.action || 'Task'} />}
      {viewingCompletion && <ViewCompletionModal completion={viewingCompletion.completion} taskName={viewingCompletion.taskName} onClose={() => setViewingCompletion(null)} />}
      {showJournalSettings && <JournalSettingsModal config={journalConfig} onSave={(newConfig) => { setJournalConfig(newConfig); setShowJournalSettings(false); }} onCancel={() => setShowJournalSettings(false)} />}
      {showCategorySettings && <CategorySettingsModal categories={categories} onSave={(newCategories) => { setCategories(newCategories); setShowCategorySettings(false); }} onCancel={() => setShowCategorySettings(false)} />}
    </div>
  );
};

export default GoalTrackerApp;

const container = document.getElementById('root');
const root = ReactDOM.createRoot(container);
root.render(React.createElement(GoalTrackerApp));
  </script>
</body>
</html>
